匹配到二进制文件 third_party/apu/libapu-frontend.so
匹配到二进制文件 third_party/apu/mt6785/libapu-platform.so
匹配到二进制文件 third_party/apu/mt6779/libapu-platform.so
third_party/tflite/LICENSE:1:Copyright 2018 The TensorFlow Authors.  All rights reserved.
third_party/tflite/LICENSE:191:   Copyright 2017, The TensorFlow Authors.
third_party/eigen3/LICENSE:248:./unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:29:EIGEN_ALWAYS_INLINE static const TensorStridingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:32:    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:35:        const TensorPatchOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:38:            const TensorPaddingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:52:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:53:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:61:  // Tensor size after patch extraction. We add three dimensions to unpack the
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:63:  DSizes<TensorIndex, ExtDims> pre_stride_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:77:  const TensorIndex inputPlanes = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:78:  const TensorIndex inputRows = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:79:  const TensorIndex inputCols = isColMajor ? in.dimension(3) : in.dimension(NumDims - 4);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:81:  array<IndexPair<TensorIndex>, NumDims> paddings;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:83:    paddings[i] = IndexPair<TensorIndex>(0, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:86:  paddings[isColMajor ? 1 : (NumDims - 2)] = IndexPair<TensorIndex>(paddingZTop, paddingZBottom);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:87:  paddings[isColMajor ? 2 : (NumDims - 3)] = IndexPair<TensorIndex>(paddingTop, paddingBottom);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:88:  paddings[isColMajor ? 3 : (NumDims - 4)] = IndexPair<TensorIndex>(paddingLeft, paddingRight);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:104:  DSizes<TensorIndex, NumDims> patch_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:123:  array<TensorIndex, NumDims + 3> strides;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:160:EIGEN_ALWAYS_INLINE static const TensorStridingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:163:    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:166:        const TensorPatchOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:169:            const TensorPaddingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:179:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:180:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:187:  const TensorIndex inputPlanes = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:188:  const TensorIndex inputRows = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:189:  const TensorIndex inputCols = isColMajor ? in.dimension(3) : in.dimension(NumDims - 4);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:200:      const TensorIndex size_z = ceil(inputPlanes / static_cast<float>(stridePlanes)) * stridePlanes;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:201:      const TensorIndex size_y = ceil(inputRows / static_cast<float>(strideRows)) * strideRows;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:202:      const TensorIndex size_x = ceil(inputCols / static_cast<float>(strideCols)) * strideCols;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:207:      const TensorIndex dz = size_z + patchPlanes - 1 - inputPlanes;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:208:      const TensorIndex dy = size_y + patchRows - 1 - inputRows;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:209:      const TensorIndex dx = size_x + patchCols - 1 - inputCols;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:230:  typedef const TensorStridingOp< const array<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions + 3>,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:231:      const TensorReshapingOp< const DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions + 3>,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:232:      const TensorPatchOp< const DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Patch3d.h:233:      const TensorPaddingOp< const array< IndexPair<typename internal::traits<Input>::Index>, internal::traits<Input>::NumDimensions>,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:42:    typedef TensorRef<Tensor<typename internal::traits<Input>::Scalar, 4,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:60:    typedef TensorRef<Tensor<typename internal::traits<Input>::Scalar, 4,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:129:          TensorFixedSize<Scalar, Sizes<> > mini;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:131:          TensorFixedSize<float, Sizes<> > range;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:136:          TensorMap<Tensor<float, 3> > tmp(NULL, glimpse_size);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:149:            TensorFixedSize<Scalar, Sizes<> > mean;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:151:            TensorFixedSize<float, Sizes<> > sigma;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:154:            TensorFixedSize<Scalar, Sizes<> > mini;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:156:            TensorFixedSize<float, Sizes<> > maxi;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:159:            TensorMap<Tensor<float, 2> > tmp(NULL, glimpse_size);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Attention.h:190:static const TensorCustomUnaryOp<const GlimpseExtractionOp<typename internal::traits<Input>::Index>, const Input>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SoftMax.h:70:static const TensorCustomUnaryOp<const SoftmaxOp, const Input>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:31:static const TensorReshapingOp<const Eigen::DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorReductionOp<internal::MaxReducer<typename internal::remove_const<typename internal::traits<Input>::Scalar>::type>, const Eigen::array<int, 2>, const TensorImagePatchOp<Dynamic, Dynamic, const Input> > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:35:static const TensorReshapingOp<const Eigen::DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorReductionOp<internal::MaxReducer<typename internal::remove_const<typename internal::traits<Input>::Scalar>::type>, typename internal::conditional<internal::traits<Input>::Layout == ColMajor, const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2> >, const Eigen::IndexList<Eigen::type2index<2>, Eigen::type2index<3> > >::type, const TensorImagePatchOp<Dynamic, Dynamic, const Input> > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:43:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:44:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:59:  Eigen::DSizes<TensorIndex, internal::traits<Input>::NumDimensions> post_reduce_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:103:EIGEN_ALWAYS_INLINE static const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:105:    const TensorReductionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:107:        const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:109:            const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Input> > > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:112:EIGEN_ALWAYS_INLINE static const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:114:    const TensorReductionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:117:        const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:119:            const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Input> > > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:128:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:129:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:275:static const TensorReshapingOp<const Eigen::DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorReductionOp<internal::AvgPoolMeanReducer<typename internal::remove_const<typename internal::traits<Input>::Scalar>::type>, const Eigen::array<int, 2>, const TensorImagePatchOp<Dynamic, Dynamic, const Input> > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:279:static const TensorReshapingOp<const Eigen::DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorReductionOp<internal::AvgPoolMeanReducer<typename internal::remove_const<typename internal::traits<Input>::Scalar>::type>, typename internal::conditional<internal::traits<Input>::Layout == ColMajor, const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2> >, const Eigen::IndexList<Eigen::type2index<2>, Eigen::type2index<3> > >::type, const TensorImagePatchOp<Dynamic, Dynamic, const Input> > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:287:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:288:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:303:  Eigen::DSizes<TensorIndex, internal::traits<Input>::NumDimensions> post_reduce_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:350:EIGEN_ALWAYS_INLINE static const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:352:    const TensorReductionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:354:        const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:356:            const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Input> > > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:359:EIGEN_ALWAYS_INLINE static const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:361:      const TensorReductionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:364:          const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:366:              const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Input> > > >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:375:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/Pooling.h:376:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:27:    TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:30:        const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:32:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:34:                const TensorReverseOp<const array<bool, 5>, const Kernel>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:36:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:38:                const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const OutputBackward>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:42:    TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:45:        const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:47:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:49:                const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const OutputBackward>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:51:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:53:                const TensorReverseOp<const array<bool, 5>, const Kernel>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:65:  typedef typename internal::traits<OutputBackward>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:66:  const TensorRef<const Tensor<typename internal::traits<Kernel>::Scalar, internal::traits<Kernel>::NumDimensions, internal::traits<Kernel>::Layout, TensorIndex> > kern(kernel);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:67:  const TensorRef<const Tensor<typename internal::traits<OutputBackward>::Scalar, internal::traits<OutputBackward>::NumDimensions, internal::traits<OutputBackward>::Layout, TensorIndex> > out(output_backward);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:76:  const TensorIndex kernelFilters = isColMajor ? kern.dimensions()[0] : kern.dimensions()[4];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:78:  const TensorIndex kernelChannels = isColMajor ? kern.dimensions()[1] : kern.dimensions()[3];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:79:  const TensorIndex kernelPlanes = isColMajor ? kern.dimensions()[2] : kern.dimensions()[2];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:80:  const TensorIndex kernelRows = isColMajor ? kern.dimensions()[3] : kern.dimensions()[1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:81:  const TensorIndex kernelCols = isColMajor ? kern.dimensions()[4] : kern.dimensions()[0];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:83:  const TensorIndex outputPlanes = isColMajor ? out.dimensions()[1] : out.dimensions()[NumDims - 2];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:84:  const TensorIndex outputRows = isColMajor ? out.dimensions()[2] : out.dimensions()[NumDims - 3];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:85:  const TensorIndex outputCols = isColMajor ? out.dimensions()[3] : out.dimensions()[NumDims - 4];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:87:  TensorIndex forward_pad_z, forward_pad_y, forward_pad_x;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:88:  const TensorIndex size_z = ceil(inputPlanes / static_cast<float>(stridePlanes));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:89:  const TensorIndex size_y = ceil(inputRows / static_cast<float>(strideRows));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:90:  const TensorIndex size_x = ceil(inputCols / static_cast<float>(strideCols));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:95:    const TensorIndex dz = size_z * stridePlanes + kernelPlanes - 1 - inputPlanes;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:96:    const TensorIndex dy = size_y * strideRows + kernelRows - 1 - inputRows;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:97:    const TensorIndex dx = size_x * strideCols + kernelCols - 1 - inputCols;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:108:  const TensorIndex padding_ztop = kernelPlanes - 1 - forward_pad_z;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:109:  const TensorIndex padding_top = kernelRows - 1 - forward_pad_y;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:110:  const TensorIndex padding_left = kernelCols - 1 - forward_pad_x;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:112:  const TensorIndex padding_zbottom = inputPlanes + kernelPlanes - 1 - (outputPlanes - 1) * stridePlanes - 1 - padding_ztop;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:113:  const TensorIndex padding_bottom = inputRows + kernelRows - 1 - (outputRows - 1) * strideRows - 1 - padding_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:114:  const TensorIndex padding_right = inputCols + kernelCols - 1 - (outputCols - 1) * strideCols - 1 - padding_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:140:  DSizes<TensorIndex, 3> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:154:  DSizes<TensorIndex, 3> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:174:  array<IndexPair<TensorIndex>, 2> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:177:    contract_dims[0] = IndexPair<TensorIndex>(0, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:178:    contract_dims[1] = IndexPair<TensorIndex>(2, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:181:    contract_dims[0] = IndexPair<TensorIndex>(1, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:182:    contract_dims[1] = IndexPair<TensorIndex>(2, 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:187:  DSizes<TensorIndex, NumDims> post_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:206:  DSizes<TensorIndex, NumDims> strides;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:263:    const TensorShufflingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:265:        const TensorReverseOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:267:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:269:                const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:271:                    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:274:                    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:276:                        const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const OutputBackward>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:282:    const TensorShufflingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:284:        const TensorReverseOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:286:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:288:                const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:290:                    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:292:                        const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const OutputBackward>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:294:                    const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:311:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:312:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:313:  TensorRef<Tensor<typename internal::traits<OutputBackward>::Scalar, internal::traits<OutputBackward>::NumDimensions, internal::traits<OutputBackward>::Layout, TensorIndex> > out(output_backward);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:322:  const TensorIndex inputPlanes = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:323:  const TensorIndex inputRows = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:324:  const TensorIndex inputCols = isColMajor ? in.dimension(3) : in.dimension(NumDims - 4);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:326:  const TensorIndex outputPlanes = isColMajor ? out.dimension(1) : out.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:327:  const TensorIndex outputRows = isColMajor ? out.dimension(2) : out.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:328:  const TensorIndex outputCols = isColMajor ? out.dimension(3) : out.dimension(NumDims - 4);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:330:  const TensorIndex kernelFilters = isColMajor ? out.dimension(0) : out.dimension(NumDims - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:331:  const TensorIndex kernelChannels = isColMajor ? in.dimension(0) : in.dimension(NumDims - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:333:  TensorIndex forward_pad_z, forward_pad_y, forward_pad_x;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:334:  const TensorIndex size_z = ceil(inputPlanes / static_cast<float>(stridePlanes));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:335:  const TensorIndex size_y = ceil(inputRows / static_cast<float>(strideRows));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:336:  const TensorIndex size_x = ceil(inputCols / static_cast<float>(strideCols));
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:341:    const TensorIndex dz = size_z * stridePlanes + kernelPlanes - 1 - inputPlanes;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:342:    const TensorIndex dy = size_y * strideRows + kernelRows - 1 - inputRows;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:343:    const TensorIndex dx = size_x * strideCols + kernelCols - 1 - inputCols;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:355:  const TensorIndex padding_ztop = kernelPlanes - 1 - forward_pad_z;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:356:  const TensorIndex padding_top = kernelRows - 1 - forward_pad_y;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:357:  const TensorIndex padding_left = kernelCols - 1 - forward_pad_x;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:359:  const TensorIndex padding_zbottom = inputPlanes + kernelPlanes - 1 - (outputPlanes - 1) * stridePlanes - 1 - padding_ztop;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:360:  const TensorIndex padding_bottom = inputRows + kernelRows - 1 - (outputRows - 1) * strideRows - 1 - padding_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:361:  const TensorIndex padding_right = inputCols + kernelCols - 1 - (outputCols - 1) * strideCols - 1 - padding_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:374:  DSizes<TensorIndex, 4> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:394:  DSizes<TensorIndex, 3> input_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:416:  array<IndexPair<TensorIndex>, 2> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:419:    contract_dims[0] = IndexPair<TensorIndex>(1, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:420:    contract_dims[1] = IndexPair<TensorIndex>(2, 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:423:    contract_dims[0] = IndexPair<TensorIndex>(0, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:424:    contract_dims[1] = IndexPair<TensorIndex>(2, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:434:  DSizes<TensorIndex, 5> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:450:  array<TensorIndex, 5> kernel_shuffle;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardCuboidConvolutions.h:481:  DSizes<TensorIndex, NumDims> strides;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:16:/** \class TensorConvolutionByFFT
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:17:  * \ingroup CXX11_Tensor_Module
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:19:  * \brief Tensor convolution class.
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:27:struct traits<TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType> >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:50:struct eval<TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType>, Eigen::Dense>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:52:  typedef const TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType>& type;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:56:struct nested<TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType>, 1, typename eval<TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType> >::type>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:58:  typedef TensorConvolutionByFFTOp<Dimensions, InputXprType, KernelXprType> type;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:66:class TensorConvolutionByFFTOp : public TensorBase<TensorConvolutionByFFTOp<Indices, InputXprType, KernelXprType> >
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:69:  typedef typename Eigen::internal::traits<TensorConvolutionByFFTOp>::Scalar Scalar;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:70:  typedef typename Eigen::internal::traits<TensorConvolutionByFFTOp>::Packet Packet;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:76:  typedef typename Eigen::internal::nested<TensorConvolutionByFFTOp>::type Nested;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:77:  typedef typename Eigen::internal::traits<TensorConvolutionByFFTOp>::StorageKind StorageKind;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:78:  typedef typename Eigen::internal::traits<TensorConvolutionByFFTOp>::Index Index;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:80:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConvolutionByFFTOp(const InputXprType& input, const KernelXprType& kernel, const Indices& dims)
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:103:struct TensorEvaluator<const TensorConvolutionByFFTOp<Indices, InputArgType, KernelArgType>, Device>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:105:  typedef TensorConvolutionByFFTOp<Indices, InputArgType, KernelArgType> XprType;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:113:  static const int NumDims = internal::array_size<typename TensorEvaluator<InputArgType, Device>::Dimensions>::value;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:119:    IsAligned = TensorEvaluator<InputArgType, Device>::IsAligned &
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:120:                TensorEvaluator<KernelArgType, Device>::IsAligned,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:123:    Layout = TensorEvaluator<InputArgType, Device>::Layout,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:127:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:130:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<InputArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<KernelArgType, Device>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:132:    const typename TensorEvaluator<InputArgType, Device>::Dimensions& input_dims = m_inputImpl.dimensions();
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:133:    const typename TensorEvaluator<KernelArgType, Device>::Dimensions& kernel_dims = m_kernelImpl.dimensions();
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:196:    typedef typename internal::traits<InputArgType>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:198:    Tensor<Scalar, NumDims, Layout, TensorIndex> input(m_inputImpl.dimensions());
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:203:    Tensor<Scalar, NumDims, Layout, TensorIndex> kernel(m_kernelImpl.dimensions());
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:223:    Eigen::DSizes<TensorIndex, NumDims> slice_offsets;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:228:    Eigen::DSizes<TensorIndex, NumDims> slice_extents;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:233:    Tensor<Scalar, NumDims, Layout, TensorIndex> kernel_variant =  kernel.reverse(reverse).pad(paddings);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:234:    Tensor<std::complex<Scalar>, NumDims, Layout, TensorIndex> kernel_fft =  kernel_variant.template fft<Eigen::BothParts, FFT_FORWARD>(fft);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:235:    //Tensor<std::complex<Scalar>, NumDims, Layout|IndexType> kernel_fft =  kernel.reverse(reverse).pad(paddings).template fft<2>(fft);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:236:    Tensor<std::complex<Scalar>, NumDims, Layout, TensorIndex> input_fft = input.template fft<Eigen::BothParts, FFT_FORWARD>(fft);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:237:    Tensor<std::complex<Scalar>, NumDims, Layout, TensorIndex> prod = (input_fft * kernel_fft).template fft<Eigen::BothParts, FFT_REVERSE>(fft);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:238:    Tensor<std::complex<Scalar>, NumDims, Layout, TensorIndex> tensor_result = prod.slice(slice_offsets, slice_extents);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:277:  TensorEvaluator<InputArgType, Device> m_inputImpl;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/TensorConvolutionByFFT.h:278:  TensorEvaluator<KernelArgType, Device> m_kernelImpl;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:26:class TensorContractionInputMapper<Scalar_, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:29:  typedef TensorContractionInputMapper<Scalar_, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> Self;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:30:  typedef TensorContractionSubMapper<Scalar_, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> SubMapper;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:36:  TensorContractionInputMapper(const TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>& tensor,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:83:    m_fastInputRowStride = internal::TensorIntDivisor<Index>(m_patch_row_inflate_strides);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:84:    m_fastInputColStride = internal::TensorIntDivisor<Index>(m_patch_col_inflate_strides);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:85:    m_fastNumPatches = internal::TensorIntDivisor<Index>(m_num_patches);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:86:    m_fastColStride = internal::TensorIntDivisor<Index>(m_colStride);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:87:    m_fastOutputRows = internal::TensorIntDivisor<Index>(m_outputRows);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:88:    m_fastDimZero = internal::TensorIntDivisor<Index>(patch_depth);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:91:  TensorContractionInputMapper(const TensorContractionInputMapper& base_mapper) :
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:176:  EIGEN_ALWAYS_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:192:  friend class TensorContractionSubMapper<Scalar, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment>;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:326:    const int NumInputDims = array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:341:  internal::TensorIntDivisor<Index> m_fastInputRowStride;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:342:  internal::TensorIntDivisor<Index> m_fastInputColStride;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:346:  internal::TensorIntDivisor<Index> m_fastNumPatches;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:347:  internal::TensorIntDivisor<Index> m_fastColStride;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:367:  internal::TensorIntDivisor<Index> m_fastOutputRows;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:368:  internal::TensorIntDivisor<Index> m_fastDimZero;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:370:  const TensorEvaluator<ArgType, Device> m_impl;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:379:class TensorContractionSubMapper<Scalar_, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment>
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:386:  typedef TensorContractionInputMapper<Scalar, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> ParentMapper;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:387:  typedef TensorContractionSubMapper<Scalar, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> Self;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:390:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorContractionSubMapper(const ParentMapper& base_mapper, Index vert_offset, Index horiz_offset)
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:394:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorContractionSubMapper(const Self& base_mapper, Index vert_offset, Index horiz_offset)
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:503:struct gemm_pack_rhs<Scalar, Index, TensorContractionSubMapper<Scalar, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment>, nr, ColMajor, false, false> {
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:505:  typedef TensorContractionSubMapper<Scalar, Index, Side, TensorEvaluator<const TensorReshapingOp<NewDimension, const TensorImagePatchOp<Rows, Cols, ArgType> >, Device>, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> SubMapper;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:673:  TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorContractionOp<const array<IndexPair<typename internal::traits<Input>::Index>, 1>, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 2>, const Kernel>, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 2>, const TensorImagePatchOp<Dynamic, Dynamic, const Input> > > >,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:674:  TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, internal::traits<Input>::NumDimensions>, const TensorContractionOp<const array<IndexPair<typename internal::traits<Input>::Index>, 1>, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 2>, const TensorImagePatchOp<Dynamic, Dynamic, const Input> >, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 2>, const Kernel> > > >::type
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:677:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:678:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:679:  TensorRef<Tensor<typename internal::traits<Kernel>::Scalar, internal::traits<Kernel>::NumDimensions, internal::traits<Kernel>::Layout, TensorIndex> > kern(kernel);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:687:  const TensorIndex kernelFilters = isColMajor ? kern.dimensions()[0] : kern.dimensions()[3];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:689:  const TensorIndex kernelChannels = isColMajor ? kern.dimensions()[1] : kern.dimensions()[2];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:690:  const TensorIndex kernelRows = isColMajor ? kern.dimensions()[2] : kern.dimensions()[1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:691:  const TensorIndex kernelCols = isColMajor ? kern.dimensions()[3] : kern.dimensions()[0];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:696:  array<IndexPair<TensorIndex>, 1> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:697:  contract_dims[0] = IndexPair<TensorIndex>(1, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:699:  const TensorIndex InputRows = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:700:  const TensorIndex InputCols = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:702:  TensorIndex out_height;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:703:  TensorIndex out_width;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:720:  DSizes<TensorIndex, 2> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:741:  DSizes<TensorIndex, NumDims> post_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:758:  DSizes<TensorIndex, 2> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/SpatialConvolutions.h:766:  // TODO(yangke): choose() is defined in TensorContraction.h -- consider
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:27:    TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:30:        const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:32:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:35:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:37:                const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:39:    TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:42:        const TensorContractionOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:44:            const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:46:                const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:48:                const TensorReshapingOp<
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:56:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:57:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:58:  TensorRef<Tensor<typename internal::traits<Kernel>::Scalar, internal::traits<Kernel>::NumDimensions, internal::traits<Kernel>::Layout, TensorIndex> > kern(kernel);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:65:  const TensorIndex kernelFilters = isColMajor ? kern.dimensions()[0] : kern.dimensions()[4];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:66:  const TensorIndex kernelChannels = isColMajor ? kern.dimensions()[1] : kern.dimensions()[3];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:69:  const TensorIndex kernelDepth = isColMajor ? kern.dimensions()[2] : kern.dimensions()[2];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:70:  const TensorIndex kernelRows = isColMajor ? kern.dimensions()[3] : kern.dimensions()[1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:71:  const TensorIndex kernelCols = isColMajor ? kern.dimensions()[4] : kern.dimensions()[0];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:79:  const TensorIndex inputPlanes = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:80:  const TensorIndex inputRows = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:81:  const TensorIndex inputCols = isColMajor ? in.dimension(3) : in.dimension(NumDims - 4);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:86:  TensorIndex out_depth;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:87:  TensorIndex out_height;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:88:  TensorIndex out_width;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:104:  DSizes<TensorIndex, 2> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:116:  DSizes<TensorIndex, 2> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:131:  array<IndexPair<TensorIndex>, 1> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:132:  contract_dims[0] = IndexPair<TensorIndex>(1, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/CuboidConvolution.h:141:  DSizes<TensorIndex, NumDims> post_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:36:  TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, internal::traits<OutputBackward>::NumDimensions>, const TensorContractionOp<const array<IndexPair<typename internal::traits<OutputBackward>::Index>, 2>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 3>, const TensorReverseOp<const array<bool, 4>, const Kernel> >, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 3>, const TensorImagePatchOp<Dynamic, Dynamic, const OutputBackward> > > >,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:37:  TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, internal::traits<OutputBackward>::NumDimensions>, const TensorContractionOp<const array<IndexPair<typename internal::traits<OutputBackward>::Index>, 2>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 3>, const TensorImagePatchOp<Dynamic, Dynamic, const OutputBackward> >, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 3>, const TensorReverseOp<const array<bool, 4>, const Kernel> > > > >::type
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:40:  typedef typename internal::traits<OutputBackward>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:41:  TensorRef<Tensor<typename internal::traits<Kernel>::Scalar, internal::traits<Kernel>::NumDimensions, internal::traits<Kernel>::Layout, TensorIndex> > kern(kernel);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:42:  TensorRef<Tensor<typename internal::traits<OutputBackward>::Scalar, internal::traits<OutputBackward>::NumDimensions, internal::traits<OutputBackward>::Layout, TensorIndex> > out(output_backward);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:51:  const TensorIndex kernelFilters = isColMajor ? kern.dimensions()[0] : kern.dimensions()[3];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:53:  const TensorIndex kernelChannels = isColMajor ? kern.dimensions()[1] : kern.dimensions()[2];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:54:  const TensorIndex kernelRows = isColMajor ? kern.dimensions()[2] : kern.dimensions()[1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:55:  const TensorIndex kernelCols = isColMajor ? kern.dimensions()[3] : kern.dimensions()[0];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:59:  const TensorIndex kernelRowsEff = kernelRows + (kernelRows - 1) * (in_stride - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:60:  const TensorIndex kernelColsEff = kernelCols + (kernelCols - 1) * (in_stride - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:62:  const TensorIndex outputRows = isColMajor ? output_backward.dimension(1) : output_backward.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:63:  const TensorIndex outputCols = isColMajor ? output_backward.dimension(2) : output_backward.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:66:  const TensorIndex forward_pad_top = ((outputRows - 1) * stride + kernelRowsEff - inputRows) / 2;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:67:  const TensorIndex forward_pad_left = ((outputCols - 1) * stride + kernelColsEff - inputCols) / 2;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:69:  const TensorIndex padding_top = kernelRowsEff - 1 - forward_pad_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:70:  const TensorIndex padding_left = kernelColsEff - 1 - forward_pad_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:71:  const TensorIndex padding_bottom = inputRows + kernelRowsEff - 1 - (outputRows - 1) * stride - 1 - padding_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:72:  const TensorIndex padding_right = inputCols + kernelColsEff - 1 - (outputCols - 1) * stride - 1 - padding_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:97:  DSizes<TensorIndex, 3> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:111:  DSizes<TensorIndex, 3> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:131:  array<IndexPair<TensorIndex>, 2> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:134:    contract_dims[0] = IndexPair<TensorIndex>(0, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:135:    contract_dims[1] = IndexPair<TensorIndex>(2, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:138:    contract_dims[0] = IndexPair<TensorIndex>(1, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:139:    contract_dims[1] = IndexPair<TensorIndex>(2, 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:144:  DSizes<TensorIndex, NumDims> post_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:183:// TODO(gpapan): Resolve a bug in TensorContractionInputMapper at SpatialConvolutions.h that yangke circumvented by using .reshape().reshape().
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:190:  const TensorShufflingOp<const array<typename internal::traits<OutputBackward>::Index, 4>, const TensorReverseOp<const array<bool, 4>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorContractionOp<const array<IndexPair<typename internal::traits<Input>::Index>, 2>, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 3>, const Input>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorImagePatchOp<Dynamic, Dynamic, const OutputBackward> > > > > > >,
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:191:  const TensorShufflingOp<const array<typename internal::traits<OutputBackward>::Index, 4>, const TensorReverseOp<const array<bool, 4>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorContractionOp<const array<IndexPair<typename internal::traits<Input>::Index>, 2>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorReshapingOp<const DSizes<typename internal::traits<OutputBackward>::Index, 4>, const TensorImagePatchOp<Dynamic, Dynamic, const OutputBackward> > >, const TensorReshapingOp<const DSizes<typename internal::traits<Input>::Index, 3>, const Input> > > > > >::type
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:194:  typedef typename internal::traits<Input>::Index TensorIndex;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:195:  TensorRef<Tensor<typename internal::traits<Input>::Scalar, internal::traits<Input>::NumDimensions, internal::traits<Input>::Layout, TensorIndex> > in(input);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:196:  TensorRef<Tensor<typename internal::traits<OutputBackward>::Scalar, internal::traits<OutputBackward>::NumDimensions, internal::traits<OutputBackward>::Layout, TensorIndex> > out(output_backward);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:208:  const TensorIndex inputRows = isColMajor ? in.dimension(1) : in.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:209:  const TensorIndex inputCols = isColMajor ? in.dimension(2) : in.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:211:  const TensorIndex outputRows = isColMajor ? output_backward.dimension(1) : output_backward.dimension(NumDims - 2);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:212:  const TensorIndex outputCols = isColMajor ? output_backward.dimension(2) : output_backward.dimension(NumDims - 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:215:  const TensorIndex kernelFilters = isColMajor ? out.dimensions()[0] : out.dimensions()[NumDims - 1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:218:  const TensorIndex kernelChannels = isColMajor ? in.dimensions()[0] : in.dimensions()[NumDims - 1];
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:222:  const TensorIndex kernelRowsEff = kernelRows + (kernelRows - 1) * (in_stride - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:223:  const TensorIndex kernelColsEff = kernelCols + (kernelCols - 1) * (in_stride - 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:226:  const TensorIndex forward_pad_top = ((outputRows - 1) * stride + kernelRowsEff - inputRows) / 2;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:227:  const TensorIndex forward_pad_left = ((outputCols - 1) * stride + kernelColsEff - inputCols) / 2;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:230:  const TensorIndex padding_top = kernelRowsEff - 1 - forward_pad_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:231:  const TensorIndex padding_left = kernelColsEff - 1 - forward_pad_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:232:  const TensorIndex padding_bottom = inputRows + kernelRowsEff - 1 - (outputRows - 1) * stride - 1 - padding_top;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:233:  const TensorIndex padding_right = inputCols + kernelColsEff - 1 - (outputCols - 1) * stride - 1 - padding_left;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:244:  DSizes<TensorIndex, 4> pre_contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:264:  DSizes<TensorIndex, 3> input_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:286:  array<IndexPair<TensorIndex>, 2> contract_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:289:    contract_dims[0] = IndexPair<TensorIndex>(1, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:290:    contract_dims[1] = IndexPair<TensorIndex>(2, 3);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:293:    contract_dims[0] = IndexPair<TensorIndex>(0, 0);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:294:    contract_dims[1] = IndexPair<TensorIndex>(2, 1);
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:305:  DSizes<TensorIndex, 4> kernel_dims;
third_party/eigen3/unsupported/Eigen/CXX11/src/NeuralNetworks/BackwardSpatialConvolutions.h:318:  array<TensorIndex, 4> kernel_shuffle;
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:43:// Used by TensorContractionThreadPool, inputs must have dimensions that are
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:46:         typename LeftTensor,
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:49:         typename RightTensor,
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:52:class TensorContractionBlocking<TensorContractionInputMapper<QInt8, Index, Lhs, LeftTensor, left_nocontract_t, left_contract_t, 32, left_inner_dim_contiguous, left_inner_dim_reordered, LeftAlignment>, TensorContractionInputMapper<QUInt8, Index, Rhs, RightTensor, right_nocontract_t, right_contract_t, 32, right_inner_dim_contiguous, right_inner_dim_reordered, RightAlignment>, Index, ShardingType> {
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:58:  TensorContractionBlocking(Index k, Index m, Index n, Index num_threads = 1) :
third_party/eigen3/unsupported/Eigen/CXX11/src/FixedPoint/MatMatProductAVX2.h:92:// Used by TensorContraction and GeneralMatrixMatrix, inputs are padded to
third_party/eigen3/unsupported/Eigen/CXX11/Tensor:1:#include "unsupported/Eigen/CXX11/Tensor"
third_party/eigen3/unsupported/Eigen/CXX11/Tensor:10:// macros that conflict with TensorFlow symbols. Undefine them here to
third_party/eigen3/unsupported/Eigen/CXX11/NeuralNetworks:13:#include "unsupported/Eigen/CXX11/Tensor"
third_party/eigen3/unsupported/Eigen/CXX11/Core:21:  * explicitly depend on C++11. Currently, this is only the Tensor
third_party/eigen3/unsupported/Eigen/CXX11/FixedPoint:19:  * explicitly depend on C++11. Currently, this is only the Tensor
third_party/eigen3/BUILD.bazel:26:        "unsupported/Eigen/CXX11/Tensor",
mace/proto/mace.proto:25:message ConstTensor {
mace/proto/mace.proto:103:  repeated ConstTensor tensors = 3;
mace/core/memory_optimizer.cc:41:void MemoryOptimizer::UpdateTensorRef(const std::string &tensor_name) {
mace/core/memory_optimizer.cc:49:void MemoryOptimizer::UpdateTensorRef(const mace::OperatorDef *op_def) {
mace/core/memory_optimizer.cc:213:      tensor_mem_map_.emplace(op_def->output(i), TensorMemInfo(best_mem_id,
mace/core/memory_optimizer.cc:246:const std::unordered_map<std::string, MemoryOptimizer::TensorMemInfo>&
mace/core/operator.cc:25:    OpConditionContext::TensorShapeMap *info)
mace/core/operator.cc:122:    const Tensor *tensor = ws->GetTensor(input_str);
mace/core/operator.cc:129:    if (ws->HasTensor(output_str)) {
mace/core/operator.cc:130:      outputs_.push_back(ws->GetTensor(output_str));
mace/core/operator.cc:146:      outputs_.push_back(MACE_CHECK_NOTNULL(ws->CreateTensor(
mace/core/operator.cc:155:      ws->GetTensor(output_str)->SetShapeConfigured(shape_configured);
mace/core/operator.h:38:  typedef std::unordered_map<std::string, std::vector<index_t>> TensorShapeMap;
mace/core/operator.h:39:  OpConditionContext(const Workspace *ws, TensorShapeMap *info);
mace/core/operator.h:60:  inline TensorShapeMap *tensor_shape_info() const {
mace/core/operator.h:85:  TensorShapeMap *tensor_shape_info_;
mace/core/operator.h:97:  typedef std::unordered_map<std::string, std::vector<index_t>> TensorShapeMap;
mace/core/operator.h:188:  inline const Tensor *Input(unsigned int idx) {
mace/core/operator.h:193:  inline Tensor *Output(int idx) { return outputs_[idx]; }
mace/core/operator.h:197:  inline const std::vector<const Tensor *> &Inputs() const { return inputs_; }
mace/core/operator.h:198:  inline const std::vector<Tensor *> &Outputs() { return outputs_; }
mace/core/operator.h:222:  std::vector<const Tensor *> inputs_;
mace/core/operator.h:223:  std::vector<Tensor *> outputs_;
mace/core/memory_optimizer.h:82:  struct TensorMemInfo {
mace/core/memory_optimizer.h:87:    TensorMemInfo(int mem_id, DataType data_type, DataFormat data_format) :
mace/core/memory_optimizer.h:94:  void UpdateTensorRef(const std::string &tensor_name);
mace/core/memory_optimizer.h:95:  void UpdateTensorRef(const OperatorDef *op_def);
mace/core/memory_optimizer.h:102:  const std::unordered_map<std::string, TensorMemInfo> &tensor_mem_map() const;
mace/core/memory_optimizer.h:118:  std::unordered_map<std::string, TensorMemInfo> tensor_mem_map_;
mace/core/tensor.h:99:class Tensor {
mace/core/tensor.h:101:  Tensor(Allocator *alloc, DataType type,
mace/core/tensor.h:117:  Tensor(BufferBase *buffer, DataType dtype,
mace/core/tensor.h:132:  Tensor(const BufferSlice &buffer_slice,
mace/core/tensor.h:150:  explicit Tensor(bool is_weight = false)
mace/core/tensor.h:151:      : Tensor(GetCPUAllocator(), DT_FLOAT, is_weight) {}
mace/core/tensor.h:153:  ~Tensor() {
mace/core/tensor.h:226:    MACE_CHECK(buffer_ != nullptr, "Tensor ", name_, " is empty");
mace/core/tensor.h:327:  inline void ReuseTensorBuffer(const Tensor &other) {
mace/core/tensor.h:363:  inline MaceStatus ResizeLike(const Tensor &other) {
mace/core/tensor.h:367:  inline MaceStatus ResizeLike(const Tensor *other) {
mace/core/tensor.h:394:  inline void Copy(const Tensor &other) {
mace/core/tensor.h:412:    os << "Tensor " << name_ << " size: [";
mace/core/tensor.h:429:    explicit MappingGuard(const Tensor *tensor) : tensor_(tensor) {
mace/core/tensor.h:450:    const Tensor *tensor_;
mace/core/tensor.h:518:  MACE_DISABLE_COPY_AND_ASSIGN(Tensor);
mace/core/quantize.h:152:  void Quantize(const Tensor &input,
mace/core/quantize.h:153:                Tensor *output,
mace/core/quantize.h:157:    Tensor::MappingGuard input_guard(&input);
mace/core/quantize.h:158:    Tensor::MappingGuard output_guard(output);
mace/core/quantize.h:182:  void DeQuantize(const Tensor &input,
mace/core/quantize.h:185:                  Tensor *output) {
mace/core/quantize.h:187:    Tensor::MappingGuard input_guard(&input);
mace/core/quantize.h:188:    Tensor::MappingGuard output_guard(output);
mace/core/net_def_adapter.h:91:  typedef std::unordered_map<std::string, InternalOutputInfo> TensorInfoMap;
mace/core/net_def_adapter.h:92:  typedef std::unordered_map<std::string, std::vector<index_t>> TensorShapeMap;
mace/core/net_def_adapter.h:98:                         const TensorInfoMap &output_map,
mace/core/net_def_adapter.h:107:      TensorInfoMap *output_map,
mace/core/net_def_adapter.h:108:      TensorShapeMap *tensor_shape_map,
mace/core/net_def_adapter.h:116:      TensorInfoMap *output_map,
mace/core/net_def_adapter.h:117:      TensorShapeMap *tensor_shape_map,
mace/core/runtime/apu/apu_wrapper.cc:238:bool ApuWrapper::Run(const std::map<std::string, Tensor *> &input_tensors,
mace/core/runtime/apu/apu_wrapper.cc:239:                     std::map<std::string, Tensor *> *output_tensors) {
mace/core/runtime/apu/apu_wrapper.cc:246:    Tensor* tensor = input_tensors.at(input_infos[i].name);
mace/core/runtime/apu/apu_wrapper.cc:267:    Tensor* tensor = output_tensors->at(output_infos[i].name);
mace/core/runtime/apu/apu_wrapper.h:45:    bool Run(const std::map<std::string, Tensor *> &input_tensors,
mace/core/runtime/apu/apu_wrapper.h:46:             std::map<std::string, Tensor *> *output_tensors);
mace/core/runtime/hexagon/hexagon_dsp_wrapper.h:38:  bool ExecuteGraph(const Tensor &input_tensor,
mace/core/runtime/hexagon/hexagon_dsp_wrapper.h:39:                    Tensor *output_tensor) override;
mace/core/runtime/hexagon/hexagon_dsp_wrapper.h:40:  bool ExecuteGraphNew(const std::map<std::string, Tensor*> &input_tensors,
mace/core/runtime/hexagon/hexagon_dsp_wrapper.h:41:                       std::map<std::string, Tensor*> *output_tensors) override;
mace/core/runtime/hexagon/hexagon_control_wrapper.h:35:            std::unique_ptr<Tensor> tensor_u8)
mace/core/runtime/hexagon/hexagon_control_wrapper.h:48:  std::unique_ptr<Tensor> tensor_u8;
mace/core/runtime/hexagon/hexagon_control_wrapper.h:62:  virtual bool ExecuteGraph(const Tensor &input_tensor,
mace/core/runtime/hexagon/hexagon_control_wrapper.h:63:                            Tensor *output_tensor) = 0;
mace/core/runtime/hexagon/hexagon_control_wrapper.h:65:      const std::map<std::string, Tensor*> &input_tensors,
mace/core/runtime/hexagon/hexagon_control_wrapper.h:66:      std::map<std::string, Tensor*> *output_tensors) = 0;
mace/core/runtime/hexagon/hexagon_hta_wrapper.h:41:  bool ExecuteGraph(const Tensor &input_tensor,
mace/core/runtime/hexagon/hexagon_hta_wrapper.h:42:                    Tensor *output_tensor) override;
mace/core/runtime/hexagon/hexagon_hta_wrapper.h:43:  bool ExecuteGraphNew(const std::map<std::string, Tensor*> &input_tensors,
mace/core/runtime/hexagon/hexagon_hta_wrapper.h:44:                       std::map<std::string, Tensor*> *output_tensors) override;
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:125:  for (const ConstTensor &const_tensor : net_def.tensors()) {
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:249:                             make_unique<Tensor>());
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:266:                              make_unique<Tensor>());
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:399:bool HexagonDSPWrapper::ExecuteGraph(const Tensor &input_tensor,
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:400:                                     Tensor *output_tensor) {
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:439:    const std::map<std::string, Tensor*> &input_tensors,
mace/core/runtime/hexagon/hexagon_dsp_wrapper.cc:440:    std::map<std::string, Tensor*> *output_tensors) {
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:69:  for (const ConstTensor &const_tensor : net_def.tensors()) {
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:173:                             make_unique<Tensor>());
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:190:                              make_unique<Tensor>());
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:235:bool HexagonHTAWrapper::ExecuteGraph(const Tensor &input_tensor,
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:236:                                     Tensor *output_tensor) {
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:244:    const std::map<std::string, Tensor *> &input_tensors,
mace/core/runtime/hexagon/hexagon_hta_wrapper.cc:245:    std::map<std::string, Tensor *> *output_tensors) {
mace/core/workspace.cc:31:bool HasQuantizedTensor(const NetDef &net_def) {
mace/core/workspace.cc:40:bool HasHalfTensor(const NetDef &net_def) {
mace/core/workspace.cc:50:void DequantizeTensor(Device *device,
mace/core/workspace.cc:52:                      const ConstTensor &const_tensor,
mace/core/workspace.cc:53:                      Tensor *output_tensor) {
mace/core/workspace.cc:54:  Tensor::MappingGuard guard(output_tensor);
mace/core/workspace.cc:71:Tensor *Workspace::CreateTensor(const std::string &name,
mace/core/workspace.cc:75:  if (HasTensor(name)) {
mace/core/workspace.cc:76:    VLOG(3) << "Tensor " << name << " already exists. Skipping.";
mace/core/workspace.cc:78:    VLOG(3) << "Creating Tensor " << name;
mace/core/workspace.cc:79:    tensor_map_[name] = std::unique_ptr<Tensor>(new Tensor(alloc, type,
mace/core/workspace.cc:82:  return GetTensor(name);
mace/core/workspace.cc:85:const Tensor *Workspace::GetTensor(const std::string &name) const {
mace/core/workspace.cc:89:    VLOG(1) << "Tensor " << name << " does not exist.";
mace/core/workspace.cc:94:Tensor *Workspace::GetTensor(const std::string &name) {
mace/core/workspace.cc:95:  return const_cast<Tensor *>(
mace/core/workspace.cc:96:      static_cast<const Workspace *>(this)->GetTensor(name));
mace/core/workspace.cc:99:std::vector<std::string> Workspace::Tensors() const {
mace/core/workspace.cc:107:MaceStatus Workspace::LoadModelTensor(const NetDef &net_def,
mace/core/workspace.cc:126:        (device_type == DeviceType::CPU && HasHalfTensor(net_def)) ||
mace/core/workspace.cc:127:            (!is_quantize_model && HasQuantizedTensor(net_def));
mace/core/workspace.cc:136:        VLOG(3) << "Tensor name: " << const_tensor.name()
mace/core/workspace.cc:157:        std::unique_ptr<Tensor> tensor(
mace/core/workspace.cc:158:            new Tensor(device->allocator(), dst_data_type, true,
mace/core/workspace.cc:163:                   "Tensor's data_size not equal with the shape");
mace/core/workspace.cc:186:            DequantizeTensor<half>(device,
mace/core/workspace.cc:191:            DequantizeTensor<float>(device,
mace/core/workspace.cc:221:        VLOG(3) << "Tensor name: " << const_tensor.name()
mace/core/workspace.cc:230:        std::unique_ptr<Tensor> tensor(
mace/core/workspace.cc:231:            new Tensor(BufferSlice(
mace/core/workspace.cc:250:MaceStatus Workspace::PreallocateOutputTensor(
mace/core/workspace.cc:285:    std::unique_ptr<Tensor> tensor
mace/core/workspace.cc:286:        (new Tensor(preallocated_allocator_.GetBuffer(tensor_mem.second.mem_id),
mace/core/workspace.cc:293:        VLOG(1) << "Tensor: " << tensor_mem.first
mace/core/workspace.cc:301:        VLOG(1) << "Tensor: " << tensor_mem.first
mace/core/workspace.cc:319:        Tensor *tensor = GetTensor(op.output(i));
mace/core/workspace.cc:366:        std::unique_ptr<Tensor> tensor(
mace/core/workspace.cc:367:            new Tensor(alloc, DataType::DT_FLOAT,
mace/core/workspace.cc:371:                   "Tensor's data_size not equal with the shape");
mace/core/workspace.cc:372:        Tensor::MappingGuard guard(tensor.get());
mace/core/workspace.cc:381:        std::unique_ptr<Tensor> tensor(
mace/core/workspace.cc:382:            new Tensor(alloc, const_tensor.data_type(),
mace/core/workspace.cc:386:                   "Tensor's data_size not equal with the shape");
mace/core/workspace.cc:397:void Workspace::RemoveTensor(const std::string &name) {
mace/core/workspace.h:34:  typedef std::map<std::string, std::unique_ptr<Tensor>> TensorMap;
mace/core/workspace.h:39:  Tensor *CreateTensor(const std::string &name,
mace/core/workspace.h:44:  inline bool HasTensor(const std::string &name) const {
mace/core/workspace.h:52:  const Tensor *GetTensor(const std::string &name) const;
mace/core/workspace.h:54:  Tensor *GetTensor(const std::string &name);
mace/core/workspace.h:56:  std::vector<std::string> Tensors() const;
mace/core/workspace.h:58:  MaceStatus LoadModelTensor(const NetDef &net_def,
mace/core/workspace.h:62:  MaceStatus PreallocateOutputTensor(const NetDef &net_def,
mace/core/workspace.h:72:  void RemoveTensor(const std::string &name);
mace/core/workspace.h:75:  TensorMap tensor_map_;
mace/core/net.cc:75:    mem_optimizer->UpdateTensorRef(op_def.get());
mace/core/net.cc:93:    mem_optimizer->UpdateTensorRef(output_info.name());
mace/core/net.cc:219:            Tensor::MappingGuard guard(op->Output(i));
mace/core/net.cc:225:            LOG(INFO) << "Tensor range @@" << op->debug_def().output(i)
mace/core/net.cc:235:            Tensor::MappingGuard guard(op->Output(i));
mace/core/net.cc:245:            LOG(INFO) << "Tensor range @@" << op->debug_def().output(i)
mace/core/net_def_adapter.cc:108:  TensorShapeMap tensor_shape_map;
mace/core/net_def_adapter.cc:110:  TensorInfoMap output_map;
mace/core/net_def_adapter.cc:318:                                      const TensorInfoMap &output_map,
mace/core/net_def_adapter.cc:373:    TensorInfoMap *output_map,
mace/core/net_def_adapter.cc:374:    TensorShapeMap *tensor_shape_map,
mace/core/net_def_adapter.cc:417:      MACE_CHECK(ws_->GetTensor(op_def->input(i)) != nullptr
mace/core/net_def_adapter.cc:418:                     && ws_->GetTensor(op_def->input(i))->is_weight(),
mace/core/net_def_adapter.cc:419:                 "Tensor ", op_def->input(i), " of ",
mace/core/net_def_adapter.cc:498:    NetDefAdapter::TensorInfoMap *output_map,
mace/core/net_def_adapter.cc:499:    TensorShapeMap *tensor_shape_map,
mace/core/net_def_adapter.cc:511:      MACE_CHECK(ws_->GetTensor(op_def->input(i)) != nullptr
mace/core/net_def_adapter.cc:512:                     && ws_->GetTensor(op_def->input(i))->is_weight(),
mace/core/net_def_adapter.cc:513:                 "Tensor ", op_def->input(i), " of ",
mace/tools/mace_run.cc:279:  std::map<std::string, mace::MaceTensor> inputs;
mace/tools/mace_run.cc:280:  std::map<std::string, mace::MaceTensor> outputs;
mace/tools/mace_run.cc:302:    inputs[input_names[i]] = mace::MaceTensor(input_shapes[i], buffer_in,
mace/tools/mace_run.cc:313:    outputs[output_names[i]] = mace::MaceTensor(output_shapes[i], buffer_out,
mace/libmace/mace.cc:278:// Mace Tensor
mace/libmace/mace.cc:279:class MaceTensor::Impl {
mace/libmace/mace.cc:287:MaceTensor::MaceTensor(const std::vector<int64_t> &shape,
mace/libmace/mace.cc:295:  impl_ = make_unique<MaceTensor::Impl>();
mace/libmace/mace.cc:303:MaceTensor::MaceTensor() {
mace/libmace/mace.cc:304:  impl_ = make_unique<MaceTensor::Impl>();
mace/libmace/mace.cc:307:MaceTensor::MaceTensor(const MaceTensor &other) {
mace/libmace/mace.cc:308:  impl_ = make_unique<MaceTensor::Impl>();
mace/libmace/mace.cc:315:MaceTensor::MaceTensor(const MaceTensor &&other) {
mace/libmace/mace.cc:316:  impl_ = make_unique<MaceTensor::Impl>();
mace/libmace/mace.cc:323:MaceTensor &MaceTensor::operator=(const MaceTensor &other) {
mace/libmace/mace.cc:331:MaceTensor &MaceTensor::operator=(const MaceTensor &&other) {
mace/libmace/mace.cc:339:MaceTensor::~MaceTensor() = default;
mace/libmace/mace.cc:341:const std::vector<int64_t> &MaceTensor::shape() const { return impl_->shape; }
mace/libmace/mace.cc:343:const std::shared_ptr<float> MaceTensor::data() const {
mace/libmace/mace.cc:347:std::shared_ptr<float> MaceTensor::data() {
mace/libmace/mace.cc:351:std::shared_ptr<void> MaceTensor::raw_data() const {
mace/libmace/mace.cc:355:std::shared_ptr<void> MaceTensor::raw_mutable_data() {
mace/libmace/mace.cc:359:DataFormat MaceTensor::data_format() const {
mace/libmace/mace.cc:380:  MaceStatus Run(const std::map<std::string, MaceTensor> &inputs,
mace/libmace/mace.cc:381:                 std::map<std::string, MaceTensor> *outputs,
mace/libmace/mace.cc:386:      const std::pair<const std::string, MaceTensor> &input,
mace/libmace/mace.cc:387:      Tensor *input_tensor);
mace/libmace/mace.cc:389:  MaceStatus TransposeOutput(const Tensor *output_tensor,
mace/libmace/mace.cc:390:                             std::pair<const std::string, MaceTensor> *output);
mace/libmace/mace.cc:493:    Tensor *input_tensor =
mace/libmace/mace.cc:494:        ws_->CreateTensor(input_name, device_->allocator(), input_dt);
mace/libmace/mace.cc:513:    Tensor *output_tensor =
mace/libmace/mace.cc:514:        ws_->CreateTensor(output_name, device_->allocator(), output_dt);
mace/libmace/mace.cc:518:    Tensor *output_tensor =
mace/libmace/mace.cc:519:        ws_->CreateTensor(output_name, device_->allocator(), DT_FLOAT);
mace/libmace/mace.cc:543:    MACE_RETURN_IF_ERROR(ws_->LoadModelTensor(*net_def,
mace/libmace/mace.cc:560:    MACE_RETURN_IF_ERROR(ws_->PreallocateOutputTensor(adapted_net_def,
mace/libmace/mace.cc:621:    const std::pair<const std::string, MaceTensor> &input,
mace/libmace/mace.cc:622:    Tensor *input_tensor) {
mace/libmace/mace.cc:647:      Tensor::MappingGuard input_guard(input_tensor);
mace/libmace/mace.cc:671:  Tensor::MappingGuard input_guard(input_tensor);
mace/libmace/mace.cc:687:    const mace::Tensor *output_tensor,
mace/libmace/mace.cc:688:    std::pair<const std::string, mace::MaceTensor> *output) {
mace/libmace/mace.cc:724:      Tensor::MappingGuard output_guard(output_tensor);
mace/libmace/mace.cc:744:      Tensor::MappingGuard output_guard(output_tensor);
mace/libmace/mace.cc:772:    const std::map<std::string, MaceTensor> &inputs,
mace/libmace/mace.cc:773:    std::map<std::string, MaceTensor> *outputs,
mace/libmace/mace.cc:776:  std::map<std::string, Tensor *> input_tensors;
mace/libmace/mace.cc:777:  std::map<std::string, Tensor *> output_tensors;
mace/libmace/mace.cc:784:    Tensor *input_tensor = ws_->GetTensor(input.first);
mace/libmace/mace.cc:794:    Tensor *output_tensor = ws_->GetTensor(output.first);
mace/libmace/mace.cc:827:    Tensor *output_tensor = ws_->GetTensor(output.first);
mace/libmace/mace.cc:853:MaceStatus MaceEngine::Run(const std::map<std::string, MaceTensor> &inputs,
mace/libmace/mace.cc:854:                           std::map<std::string, MaceTensor> *outputs,
mace/libmace/mace.cc:859:MaceStatus MaceEngine::Run(const std::map<std::string, MaceTensor> &inputs,
mace/libmace/mace.cc:860:                           std::map<std::string, MaceTensor> *outputs) {
mace/libmace/mace_version_script.lds:5:    *MaceTensor*;
mace/libmace/mace_version_script.lds:21:    *mace*ConstTensor*;
mace/libmace/capability.cc:89:  void AddTensor(const std::string &name,
mace/libmace/capability.cc:194:void BMNet::AddTensor(const std::string &name,
mace/libmace/capability.cc:198:  ConstTensor *tensor_ptr = net_.add_tensors();
mace/libmace/capability.cc:229:  AddTensor(filter_name, filter_shape, weight_size_, filter_size);
mace/libmace/capability.cc:237:    AddTensor(bias_tensor_name, {output_shape[3]},
mace/libmace/capability.cc:361:  std::map<std::string, mace::MaceTensor> inputs;
mace/libmace/capability.cc:362:  std::map<std::string, mace::MaceTensor> outputs;
mace/libmace/capability.cc:369:    inputs[input_names_[i]] = mace::MaceTensor(input_shapes_[i], buffer_in);
mace/libmace/capability.cc:378:    outputs[output_names_[i]] = mace::MaceTensor(output_shapes_[i], buffer_out);
mace/ops/fully_connected.cc:80:    const Tensor *input = this->Input(INPUT);
mace/ops/fully_connected.cc:81:    const Tensor *weight = this->Input(WEIGHT);  // OIHW
mace/ops/fully_connected.cc:82:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/fully_connected.cc:83:    Tensor *output = this->Output(OUTPUT);
mace/ops/fully_connected.cc:138:    const Tensor *input = this->Input(INPUT);
mace/ops/fully_connected.cc:139:    const Tensor *weight = this->Input(WEIGHT);  // OIHW
mace/ops/fully_connected.cc:140:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/fully_connected.cc:141:    Tensor *output = this->Output(OUTPUT);
mace/ops/fully_connected.cc:213:    const Tensor *input = this->Input(INPUT);
mace/ops/fully_connected.cc:214:    const Tensor *weight = this->Input(WEIGHT);  // OIHW
mace/ops/fully_connected.cc:215:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/fully_connected.cc:216:    Tensor *output = this->Output(OUTPUT);
mace/ops/splice.cc:49:    const Tensor *input = this->Input(0);
mace/ops/splice.cc:55:    Tensor *output = this->Output(0);
mace/ops/splice.cc:84:    Tensor::MappingGuard input_guard(input);
mace/ops/splice.cc:85:    Tensor::MappingGuard output_guard(output);
mace/ops/split.cc:56:    const Tensor *input = this->Input(0);
mace/ops/split.cc:57:    const std::vector<Tensor *> output_list = this->Outputs();
mace/ops/split.cc:118:    const Tensor *input = this->Input(0);
mace/ops/split.cc:119:    const std::vector<Tensor *> output_list = this->Outputs();
mace/ops/bias_add.cc:50:    const Tensor *input = this->Input(0);
mace/ops/bias_add.cc:51:    const Tensor *bias = this->Input(1);
mace/ops/bias_add.cc:56:    Tensor *output = this->Output(0);
mace/ops/bias_add.cc:64:      Tensor::MappingGuard input_mapper(input);
mace/ops/bias_add.cc:65:      Tensor::MappingGuard bias_mapper(bias);
mace/ops/bias_add.cc:66:      Tensor::MappingGuard output_mapper(output);
mace/ops/bias_add.cc:117:    const Tensor *input = this->Input(0);
mace/ops/bias_add.cc:118:    const Tensor *bias = this->Input(1);
mace/ops/bias_add.cc:123:    Tensor *output = this->Output(0);
mace/ops/local_response_norm.cc:38:    const Tensor *input = this->Input(0);
mace/ops/local_response_norm.cc:43:    Tensor *output = this->Output(0);
mace/ops/conv_2d.cc:84:    const Tensor *input = this->Input(INPUT);
mace/ops/conv_2d.cc:85:    const Tensor *filter = this->Input(FILTER);
mace/ops/conv_2d.cc:86:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/conv_2d.cc:87:    Tensor *output = this->Output(OUTPUT);
mace/ops/conv_2d.cc:219:    const Tensor *input = this->Input(INPUT);
mace/ops/conv_2d.cc:220:    const Tensor *filter = this->Input(FILTER);
mace/ops/conv_2d.cc:221:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/conv_2d.cc:222:    Tensor *output = this->Output(OUTPUT);
mace/ops/conv_2d.cc:285:    Tensor::MappingGuard input_guard(input);
mace/ops/conv_2d.cc:286:    Tensor::MappingGuard filter_guard(filter);
mace/ops/conv_2d.cc:287:    Tensor::MappingGuard output_guard(output);
mace/ops/conv_2d.cc:299:    std::unique_ptr<Tensor> im2col;
mace/ops/conv_2d.cc:308:      im2col = make_unique<Tensor>(scratch->Scratch(im2col_size), DT_UINT8);
mace/ops/conv_2d.cc:473:          context->workspace()->GetTensor(
mace/ops/conv_2d.cc:498:    const Tensor *input = this->Input(INPUT);
mace/ops/conv_2d.cc:499:    const Tensor *filter = this->Input(FILTER);
mace/ops/conv_2d.cc:500:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/conv_2d.cc:501:    Tensor *output = this->Output(OUTPUT);
mace/ops/reverse.cc:31:    const Tensor *input = this->Input(INPUT);
mace/ops/reverse.cc:32:    const Tensor *axis = this->Input(AXIS);
mace/ops/reverse.cc:33:    Tensor *output = this->Output(OUTPUT);
mace/ops/identity.cc:28:    const Tensor *input = this->Input(0);
mace/ops/identity.cc:29:    Tensor *output = this->Output(0);
mace/ops/identity.cc:30:    output->ReuseTensorBuffer(*input);
mace/ops/pad_context.cc:40:    const Tensor *input = this->Input(0);
mace/ops/pad_context.cc:41:    Tensor *output = this->Output(0);
mace/ops/pad_context.cc:58:    Tensor::MappingGuard input_guard(input);
mace/ops/pad_context.cc:59:    Tensor::MappingGuard output_guard(output);
mace/ops/resize_bilinear.cc:196:    const Tensor *input = this->Input(0);
mace/ops/resize_bilinear.cc:197:    Tensor *output = this->Output(0);
mace/ops/resize_bilinear.cc:212:    Tensor::MappingGuard input_mapper(input);
mace/ops/resize_bilinear.cc:213:    Tensor::MappingGuard output_mapper(output);
mace/ops/resize_bilinear.cc:272:    const Tensor *input = this->Input(0);
mace/ops/resize_bilinear.cc:273:    Tensor *output = this->Output(0);
mace/ops/resize_bilinear.cc:288:    Tensor::MappingGuard input_mapper(input);
mace/ops/resize_bilinear.cc:289:    Tensor::MappingGuard output_mapper(output);
mace/ops/resize_bilinear.cc:356:    const Tensor *input = this->Input(0);
mace/ops/resize_bilinear.cc:357:    Tensor *output = this->Output(0);
mace/ops/pnorm.cc:47:    const Tensor *input = this->Input(0);
mace/ops/pnorm.cc:48:    Tensor *output = this->Output(0);
mace/ops/pnorm.cc:63:    Tensor::MappingGuard guard_input(input);
mace/ops/pnorm.cc:64:    Tensor::MappingGuard guard_output(output);
mace/ops/unsqueeze.cc:32:    const Tensor *input = this->Input(INPUT);
mace/ops/unsqueeze.cc:33:    Tensor *output = this->Output(0);
mace/ops/unsqueeze.cc:42:    Tensor::MappingGuard input_guard(input);
mace/ops/unsqueeze.cc:43:    Tensor::MappingGuard output_guard(output);
mace/ops/common/conv_pool_2d_util.cc:89:  // Note: TensorFlow may padded one more on the right/bottom side
mace/ops/arm/fp32/conv_2d_7x7.cc:158:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.cc:159:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.cc:160:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_7x7.cc:161:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_7x7.cc:162:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_7x7.cc:171:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_7x7.cc:175:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_7x7.cc:181:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_7x7.cc:182:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_7x7.cc:183:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_7x7.cc:340:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.cc:341:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.cc:342:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_7x7.cc:343:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_7x7.cc:344:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_7x7.cc:353:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_7x7.cc:357:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_7x7.cc:363:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_7x7.cc:364:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_7x7.cc:365:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_7x7.cc:532:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.cc:533:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.cc:534:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_7x7.cc:535:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_7x7.cc:536:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_7x7.cc:545:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_7x7.cc:549:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_7x7.cc:555:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_7x7.cc:556:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_7x7.cc:557:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:47:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:48:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:49:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:50:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:67:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:68:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:69:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:70:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:89:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:90:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:91:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:92:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:111:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:112:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:113:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.h:114:      Tensor *output) override;
mace/ops/arm/fp32/bias_add.cc:25:                            const Tensor *input,
mace/ops/arm/fp32/bias_add.cc:26:                            const Tensor *bias,
mace/ops/arm/fp32/bias_add.cc:27:                            Tensor *output) {
mace/ops/arm/fp32/bias_add.cc:28:  Tensor::MappingGuard input_guard(input);
mace/ops/arm/fp32/bias_add.cc:29:  Tensor::MappingGuard bias_guard(bias);
mace/ops/arm/fp32/bias_add.cc:35:      Tensor::MappingGuard output_guard(output);
mace/ops/arm/fp32/bias_add.cc:48:                      const Tensor *input,
mace/ops/arm/fp32/bias_add.cc:49:                      const Tensor *bias,
mace/ops/arm/fp32/bias_add.cc:50:                      mace::Tensor *output) {
mace/ops/arm/fp32/deconv_2d_general.h:49:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_general.h:50:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_general.h:51:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_general.h:52:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_5x5.h:37:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_5x5.h:38:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_5x5.h:39:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:29:                                       const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:30:                                       const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:31:                                       Tensor *output) {
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:57:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:58:  Tensor::MappingGuard input_guard(input);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:59:  Tensor::MappingGuard output_guard(output);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:105:  const Tensor *padded_in = input;
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:106:  Tensor tmp_padded_in
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:111:    Tensor::MappingGuard guard(&tmp_padded_in);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:116:  Tensor *padded_out = output;
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:117:  Tensor tmp_padded_out
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:135:    transformed_filter_.reset(new Tensor);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:196:    Tensor transformed_in_this_batch(transformed_in_slice, DataType::DT_FLOAT);
mace/ops/arm/fp32/conv_2d_3x3_winograd.cc:198:    Tensor
mace/ops/arm/fp32/conv_2d.cc:71:void Conv2dBase::CalOutputShapeAndPadSize(const Tensor *input,
mace/ops/arm/fp32/conv_2d.cc:72:                                          const Tensor *filter,
mace/ops/arm/fp32/conv_2d.cc:124:                                            const Tensor *input,
mace/ops/arm/fp32/conv_2d.cc:125:                                            const Tensor *filter,
mace/ops/arm/fp32/conv_2d.cc:126:                                            Tensor *output,
mace/ops/arm/fp32/conv_2d.cc:129:                                            std::unique_ptr<const Tensor>
mace/ops/arm/fp32/conv_2d.cc:131:                                            std::unique_ptr<Tensor>
mace/ops/arm/fp32/conv_2d.cc:176:    std::unique_ptr<Tensor>
mace/ops/arm/fp32/conv_2d.cc:178:        make_unique<Tensor>(scratch_buffer->Scratch(padded_in_size),
mace/ops/arm/fp32/conv_2d.cc:185:    std::unique_ptr<Tensor>
mace/ops/arm/fp32/conv_2d.cc:187:        make_unique<Tensor>(scratch_buffer->Scratch(padded_out_size),
mace/ops/arm/fp32/conv_2d.cc:196:void Conv2dBase::PadInput(const Tensor &src,
mace/ops/arm/fp32/conv_2d.cc:199:                          Tensor *dst) {
mace/ops/arm/fp32/conv_2d.cc:241:void Conv2dBase::UnPadOutput(const Tensor &src, Tensor *dst) {
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:26:                                            const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:27:                                            const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:28:                                            const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:29:                                            Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:30:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:41:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:48:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:49:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:50:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:200:                                            const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:201:                                            const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:202:                                            const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:203:                                            Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:204:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:215:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:222:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:223:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:224:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:367:                                        const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:368:                                        const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:369:                                        const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:370:                                        Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:371:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:381:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:388:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:389:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:390:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:781:                                        const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:782:                                        const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:783:                                        const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:784:                                        Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:785:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:795:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:802:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:803:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_4x4.cc:804:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/conv_2d_1xn.cc:26:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.cc:27:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.cc:28:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_1xn.cc:29:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_1xn.cc:30:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_1xn.cc:40:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_1xn.cc:44:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_1xn.cc:50:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_1xn.cc:51:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_1xn.cc:52:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_1xn.cc:283:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.cc:284:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.cc:285:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_1xn.cc:286:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_1xn.cc:287:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_1xn.cc:297:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_1xn.cc:301:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_1xn.cc:307:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_1xn.cc:308:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_1xn.cc:309:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_1xn.cc:580:                                  const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.cc:581:                                  const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.cc:582:                                  Tensor *output) {
mace/ops/arm/fp32/conv_2d_1xn.cc:583:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_1xn.cc:584:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_1xn.cc:594:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_1xn.cc:598:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_1xn.cc:604:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_1xn.cc:605:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_1xn.cc:606:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_1xn.cc:714:                                  const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.cc:715:                                  const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.cc:716:                                  Tensor *output) {
mace/ops/arm/fp32/conv_2d_1xn.cc:717:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_1xn.cc:718:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_1xn.cc:728:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_1xn.cc:732:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_1xn.cc:738:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_1xn.cc:739:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_1xn.cc:740:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_1x1.h:38:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_1x1.h:39:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1x1.h:40:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_general.cc:25:                                    const Tensor *input,
mace/ops/arm/fp32/deconv_2d_general.cc:26:                                    const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_general.cc:27:                                    const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_general.cc:28:                                    Tensor *output) {
mace/ops/arm/fp32/deconv_2d_general.cc:29:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_general.cc:38:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_general.cc:45:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_general.cc:46:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_general.cc:47:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/conv_general.cc:25:                                  const Tensor *input,
mace/ops/arm/fp32/conv_general.cc:26:                                  const Tensor *filter,
mace/ops/arm/fp32/conv_general.cc:27:                                  Tensor *output) {
mace/ops/arm/fp32/conv_general.cc:28:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_general.cc:29:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_general.cc:40:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_general.cc:44:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_general.cc:50:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_general.cc:51:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_general.cc:52:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/gemm.cc:32:                         const Tensor *lhs,
mace/ops/arm/fp32/gemm.cc:33:                         const Tensor *rhs,
mace/ops/arm/fp32/gemm.cc:43:                         Tensor *output) {
mace/ops/arm/fp32/gemm.cc:46:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/arm/fp32/gemm.cc:47:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/arm/fp32/gemm.cc:48:  Tensor::MappingGuard output_guard(output);
mace/ops/arm/fp32/gemm.cc:1189:                         const Tensor *lhs,
mace/ops/arm/fp32/gemm.cc:1190:                         const Tensor *rhs,
mace/ops/arm/fp32/gemm.cc:1201:                         Tensor *output) {
mace/ops/arm/fp32/conv_2d_3x3.cc:26:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3.cc:27:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3.cc:28:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_3x3.cc:29:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_3x3.cc:30:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_3x3.cc:39:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_3x3.cc:43:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_3x3.cc:49:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_3x3.cc:50:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_3x3.cc:51:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d_3x3.cc:545:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3.cc:546:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3.cc:547:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_3x3.cc:548:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_3x3.cc:549:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_3x3.cc:559:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_3x3.cc:563:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_3x3.cc:569:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_3x3.cc:570:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_3x3.cc:571:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:26:                                            const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:27:                                            const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:28:                                            const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:29:                                            Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:30:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:41:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:48:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:49:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:50:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:168:                                            const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:169:                                            const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:170:                                            const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:171:                                            Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:172:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:183:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:190:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:191:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:192:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:313:                                        const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:314:                                        const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:315:                                        const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:316:                                        Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:317:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:327:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:334:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:335:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:336:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:623:                                        const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:624:                                        const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:625:                                        const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:626:                                        Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:627:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:637:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:644:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:645:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.cc:646:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/deconv_2d.cc:29:    const Tensor *input,
mace/ops/arm/fp32/deconv_2d.cc:30:    const Tensor *filter,
mace/ops/arm/fp32/deconv_2d.cc:31:    const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d.cc:32:    Tensor *output,
mace/ops/arm/fp32/deconv_2d.cc:34:    std::unique_ptr<Tensor> *padded_output) {
mace/ops/arm/fp32/deconv_2d.cc:37:    Tensor::MappingGuard out_shape_guard(output_shape);
mace/ops/arm/fp32/deconv_2d.cc:76:    std::unique_ptr<Tensor>
mace/ops/arm/fp32/deconv_2d.cc:78:        (make_unique<Tensor>(scratch->Scratch(scratch_size), DT_FLOAT));
mace/ops/arm/fp32/deconv_2d.cc:86:void Deconv2dBase::UnPadOutput(const Tensor &src,
mace/ops/arm/fp32/deconv_2d.cc:88:                               Tensor *dst) {
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:52:                                          const mace::Tensor *input,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:53:                                          const mace::Tensor *filter,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:54:                                          mace::Tensor *output) {
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:89:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:90:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:91:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:306:                                          const mace::Tensor *input,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:307:                                          const mace::Tensor *filter,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:308:                                          mace::Tensor *output) {
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:345:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:346:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.cc:347:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/conv_2d.h:47:      const Tensor *input,
mace/ops/arm/fp32/conv_2d.h:48:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d.h:49:      Tensor *output) = 0;
mace/ops/arm/fp32/conv_2d.h:64:  void CalOutputShapeAndPadSize(const Tensor *input,
mace/ops/arm/fp32/conv_2d.h:65:                                const Tensor *filter,
mace/ops/arm/fp32/conv_2d.h:73:                                  const Tensor *input,
mace/ops/arm/fp32/conv_2d.h:74:                                  const Tensor *filter,
mace/ops/arm/fp32/conv_2d.h:75:                                  Tensor *output,
mace/ops/arm/fp32/conv_2d.h:78:                                  std::unique_ptr<const Tensor> *padded_input,
mace/ops/arm/fp32/conv_2d.h:79:                                  std::unique_ptr<Tensor> *padded_output);
mace/ops/arm/fp32/conv_2d.h:81:  void PadInput(const Tensor &src,
mace/ops/arm/fp32/conv_2d.h:84:                Tensor *dst);
mace/ops/arm/fp32/conv_2d.h:85:  void UnPadOutput(const Tensor &src, Tensor *dst);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:23:                                             const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:24:                                             const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:25:                                             const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:26:                                             Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:27:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:38:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:45:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:46:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:47:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:109:                                         const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:110:                                         const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:111:                                         const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:112:                                         Tensor *output) {
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:113:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:123:  Tensor *out_tensor = output;
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:130:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:131:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/depthwise_deconv_2d_general.cc:132:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:38:      const Tensor *input,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:39:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:40:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:52:      const Tensor *input,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:53:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_conv_2d_3x3.h:54:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_7x7.h:37:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.h:38:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.h:39:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_7x7.h:50:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.h:51:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.h:52:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_7x7.h:63:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_7x7.h:64:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_7x7.h:65:      Tensor *output) override;
mace/ops/arm/fp32/gemv.h:34:      const Tensor *lhs,
mace/ops/arm/fp32/gemv.h:35:      const Tensor *rhs,
mace/ops/arm/fp32/gemv.h:36:      const Tensor *bias,
mace/ops/arm/fp32/gemv.h:42:      Tensor *output);
mace/ops/arm/fp32/conv_2d_1x1.cc:23:                               const Tensor *input,
mace/ops/arm/fp32/conv_2d_1x1.cc:24:                               const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1x1.cc:25:                               Tensor *output) {
mace/ops/arm/fp32/conv_2d_1x1.cc:71:  const Tensor *padded_in = input;
mace/ops/arm/fp32/conv_2d_1x1.cc:72:  Tensor tmp_padded_in
mace/ops/arm/fp32/deconv_2d_2x2.h:43:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_2x2.h:44:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_2x2.h:45:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_2x2.h:46:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_2x2.h:59:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_2x2.h:60:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_2x2.h:61:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_2x2.h:62:      Tensor *output) override;
mace/ops/arm/fp32/bias_add.h:32:      const Tensor *input,
mace/ops/arm/fp32/bias_add.h:33:      const Tensor *bias,
mace/ops/arm/fp32/bias_add.h:34:      Tensor *output);
mace/ops/arm/fp32/bias_add.h:38:               const Tensor *input,
mace/ops/arm/fp32/bias_add.h:39:               const Tensor *bias,
mace/ops/arm/fp32/bias_add.h:40:               Tensor *output);
mace/ops/arm/fp32/conv_2d_5x5.cc:81:                                 const Tensor *input,
mace/ops/arm/fp32/conv_2d_5x5.cc:82:                                 const Tensor *filter,
mace/ops/arm/fp32/conv_2d_5x5.cc:83:                                 Tensor *output) {
mace/ops/arm/fp32/conv_2d_5x5.cc:84:  std::unique_ptr<const Tensor> padded_input;
mace/ops/arm/fp32/conv_2d_5x5.cc:85:  std::unique_ptr<Tensor> padded_output;
mace/ops/arm/fp32/conv_2d_5x5.cc:94:  const Tensor *in_tensor = input;
mace/ops/arm/fp32/conv_2d_5x5.cc:98:  Tensor *out_tensor = output;
mace/ops/arm/fp32/conv_2d_5x5.cc:104:  Tensor::MappingGuard in_guard(input);
mace/ops/arm/fp32/conv_2d_5x5.cc:105:  Tensor::MappingGuard filter_guard(filter);
mace/ops/arm/fp32/conv_2d_5x5.cc:106:  Tensor::MappingGuard out_guard(output);
mace/ops/arm/fp32/deconv_2d_3x3.cc:26:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_3x3.cc:27:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_3x3.cc:28:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_3x3.cc:29:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_3x3.cc:30:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_3x3.cc:39:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_3x3.cc:46:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_3x3.cc:47:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_3x3.cc:48:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/deconv_2d_3x3.cc:322:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_3x3.cc:323:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_3x3.cc:324:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_3x3.cc:325:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_3x3.cc:326:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_3x3.cc:336:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_3x3.cc:343:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_3x3.cc:344:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_3x3.cc:345:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/activation.cc:33:                               const Tensor *input,
mace/ops/arm/fp32/activation.cc:34:                               Tensor *output) {
mace/ops/arm/fp32/activation.cc:35:  Tensor::MappingGuard input_guard(input);
mace/ops/arm/fp32/activation.cc:38:    Tensor::MappingGuard output_guard(output);
mace/ops/arm/fp32/activation.cc:48:                              const Tensor *input,
mace/ops/arm/fp32/activation.cc:49:                              Tensor *output) {
mace/ops/arm/fp32/activation.h:35:      const Tensor *input,
mace/ops/arm/fp32/activation.h:36:      Tensor *output);
mace/ops/arm/fp32/activation.h:40:                    const Tensor *input,
mace/ops/arm/fp32/activation.h:41:                    Tensor *output);
mace/ops/arm/fp32/deconv_2d.h:64:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d.h:65:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d.h:66:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d.h:67:      Tensor *output) = 0;
mace/ops/arm/fp32/deconv_2d.h:71:                                const Tensor *input,
mace/ops/arm/fp32/deconv_2d.h:72:                                const Tensor *filter,
mace/ops/arm/fp32/deconv_2d.h:73:                                const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d.h:74:                                Tensor *output,
mace/ops/arm/fp32/deconv_2d.h:76:                                std::unique_ptr<Tensor> *padded_output);
mace/ops/arm/fp32/deconv_2d.h:78:  void UnPadOutput(const Tensor &src,
mace/ops/arm/fp32/deconv_2d.h:80:                   Tensor *dst);
mace/ops/arm/fp32/conv_general.h:40:      const Tensor *input,
mace/ops/arm/fp32/conv_general.h:41:      const Tensor *filter,
mace/ops/arm/fp32/conv_general.h:42:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_4x4.h:43:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_4x4.h:44:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_4x4.h:45:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_4x4.h:46:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_4x4.h:59:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_4x4.h:60:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_4x4.h:61:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_4x4.h:62:      Tensor *output) override;
mace/ops/arm/fp32/gemv.cc:40:                         const Tensor *lhs,
mace/ops/arm/fp32/gemv.cc:41:                         const Tensor *rhs,
mace/ops/arm/fp32/gemv.cc:42:                         const Tensor *bias,
mace/ops/arm/fp32/gemv.cc:48:                         Tensor *output) {
mace/ops/arm/fp32/gemv.cc:54:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/arm/fp32/gemv.cc:55:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/arm/fp32/gemv.cc:56:  Tensor::MappingGuard bias_guard(bias);
mace/ops/arm/fp32/gemv.cc:57:  Tensor::MappingGuard output_guard(output);
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:49:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:50:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:51:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:52:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:73:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:74:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:75:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_general.h:76:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_3x3.h:37:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3.h:38:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3.h:39:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_3x3.h:50:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3.h:51:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3.h:52:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_1xn.h:37:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.h:38:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.h:39:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_1xn.h:50:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.h:51:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.h:52:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_1xn.h:63:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.h:64:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.h:65:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_1xn.h:76:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_1xn.h:77:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_1xn.h:78:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:47:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:48:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:49:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:50:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:67:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:68:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:69:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:70:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:89:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:90:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:91:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:92:      Tensor *output) override;
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:111:      const Tensor *input,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:112:      const Tensor *filter,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:113:      const Tensor *output_shape,
mace/ops/arm/fp32/depthwise_deconv_2d_3x3.h:114:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_3x3_winograd.h:45:      const Tensor *input,
mace/ops/arm/fp32/conv_2d_3x3_winograd.h:46:      const Tensor *filter,
mace/ops/arm/fp32/conv_2d_3x3_winograd.h:47:      Tensor *output) override;
mace/ops/arm/fp32/conv_2d_3x3_winograd.h:99:  std::unique_ptr<Tensor> transformed_filter_;
mace/ops/arm/fp32/deconv_2d_3x3.h:43:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_3x3.h:44:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_3x3.h:45:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_3x3.h:46:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_3x3.h:59:      const Tensor *input,
mace/ops/arm/fp32/deconv_2d_3x3.h:60:      const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_3x3.h:61:      const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_3x3.h:62:      Tensor *output) override;
mace/ops/arm/fp32/deconv_2d_2x2.cc:26:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_2x2.cc:27:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_2x2.cc:28:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_2x2.cc:29:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_2x2.cc:30:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_2x2.cc:40:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_2x2.cc:47:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_2x2.cc:48:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_2x2.cc:49:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/deconv_2d_2x2.cc:229:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_2x2.cc:230:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_2x2.cc:231:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_2x2.cc:232:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_2x2.cc:233:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_2x2.cc:243:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_2x2.cc:250:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_2x2.cc:251:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_2x2.cc:252:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/deconv_2d_4x4.cc:26:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_4x4.cc:27:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_4x4.cc:28:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_4x4.cc:29:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_4x4.cc:30:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_4x4.cc:39:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_4x4.cc:45:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_4x4.cc:46:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_4x4.cc:47:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/deconv_2d_4x4.cc:412:                                   const Tensor *input,
mace/ops/arm/fp32/deconv_2d_4x4.cc:413:                                   const Tensor *filter,
mace/ops/arm/fp32/deconv_2d_4x4.cc:414:                                   const Tensor *output_shape,
mace/ops/arm/fp32/deconv_2d_4x4.cc:415:                                   Tensor *output) {
mace/ops/arm/fp32/deconv_2d_4x4.cc:416:  std::unique_ptr<Tensor> padded_out;
mace/ops/arm/fp32/deconv_2d_4x4.cc:425:  Tensor *out_tensor = output;
mace/ops/arm/fp32/deconv_2d_4x4.cc:431:  Tensor::MappingGuard input_mapper(input);
mace/ops/arm/fp32/deconv_2d_4x4.cc:432:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/arm/fp32/deconv_2d_4x4.cc:433:  Tensor::MappingGuard output_mapper(output);
mace/ops/arm/fp32/gemm.h:43:      const Tensor *lhs,
mace/ops/arm/fp32/gemm.h:44:      const Tensor *rhs,
mace/ops/arm/fp32/gemm.h:54:      Tensor *output);
mace/ops/arm/fp32/gemm.h:59:      const Tensor *lhs,
mace/ops/arm/fp32/gemm.h:60:      const Tensor *rhs,
mace/ops/arm/fp32/gemm.h:71:      Tensor *output);
mace/ops/arm/README:13:input/output parameters should be of `Tensor` type instead of raw pointer, as
mace/ops/arm/README:14:`Tensor` has more information kernel might use.
mace/ops/arm/q8/quantization_util.h:25:const int32_t *GetBiasData(const Tensor *bias,
mace/ops/arm/q8/gemv.h:40:      const Tensor *lhs,
mace/ops/arm/q8/gemv.h:41:      const Tensor *rhs,
mace/ops/arm/q8/gemv.h:42:      const Tensor *bias,
mace/ops/arm/q8/gemv.h:48:      Tensor *output);
mace/ops/arm/q8/quantize.cc:44:    const Tensor *input = this->Input(0);
mace/ops/arm/q8/quantize.cc:45:    Tensor *output = this->Output(0);
mace/ops/arm/q8/quantize.cc:47:    Tensor::MappingGuard input_guard(input);
mace/ops/arm/q8/quantize.cc:48:    Tensor::MappingGuard output_guard(output);
mace/ops/arm/q8/quantize.cc:90:    const Tensor *input = this->Input(0);
mace/ops/arm/q8/quantize.cc:91:    Tensor *output = this->Output(0);
mace/ops/arm/q8/quantize.cc:93:    Tensor::MappingGuard input_guard(input);
mace/ops/arm/q8/quantize.cc:94:    Tensor::MappingGuard output_guard(output);
mace/ops/arm/q8/gemv.cc:37:                                      const Tensor *lhs,
mace/ops/arm/q8/gemv.cc:38:                                      const Tensor *rhs,
mace/ops/arm/q8/gemv.cc:39:                                      const Tensor *bias,
mace/ops/arm/q8/gemv.cc:45:                                      Tensor *output) {
mace/ops/arm/q8/gemv.cc:48:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/arm/q8/gemv.cc:49:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/arm/q8/gemv.cc:50:  Tensor::MappingGuard bias_guard(bias);
mace/ops/arm/q8/gemv.cc:51:  Tensor::MappingGuard output_guard(output);
mace/ops/arm/q8/quantization_util.cc:20:const int32_t *GetBiasData(const Tensor *bias,
mace/ops/arm/q8/eltwise.h:35:                     const Tensor *input0,
mace/ops/arm/q8/eltwise.h:36:                     const Tensor *input1,
mace/ops/arm/q8/eltwise.h:37:                     Tensor *output);
mace/ops/arm/q8/eltwise.cc:29:                            const Tensor *input0,
mace/ops/arm/q8/eltwise.cc:30:                            const Tensor *input1,
mace/ops/arm/q8/eltwise.cc:31:                            Tensor *output) {
mace/ops/arm/q8/eltwise.cc:53:  Tensor::MappingGuard input0_guard(input0);
mace/ops/arm/q8/eltwise.cc:54:  Tensor::MappingGuard input1_guard(input1);
mace/ops/arm/q8/eltwise.cc:55:  Tensor::MappingGuard output_guard(output);
mace/ops/crop.cc:49:    Tensor *output = this->Output(0);
mace/ops/crop.cc:50:    const Tensor *input0 = inputs_[0];
mace/ops/crop.cc:51:    const Tensor *input1 = inputs_[1];
mace/ops/deconv_2d.cc:65:    const Tensor *input = this->Input(0);
mace/ops/deconv_2d.cc:66:    const Tensor *filter = this->Input(1);
mace/ops/deconv_2d.cc:67:    const Tensor *bias = nullptr;
mace/ops/deconv_2d.cc:68:    const Tensor *output_shape_tensor = nullptr;
mace/ops/deconv_2d.cc:76:    Tensor *output = this->Output(0);
mace/ops/deconv_2d.cc:203:    const Tensor *input = this->Input(0);
mace/ops/deconv_2d.cc:204:    const Tensor *filter = this->Input(1);
mace/ops/deconv_2d.cc:205:    const Tensor *bias = nullptr;
mace/ops/deconv_2d.cc:206:    const Tensor *output_shape_tensor = nullptr;
mace/ops/deconv_2d.cc:214:    Tensor *output = this->Output(0);
mace/ops/deconv_2d.cc:222:      Tensor::MappingGuard out_shape_guard(output_shape_tensor);
mace/ops/resize_bicubic.cc:146:    const Tensor *input = this->Input(0);
mace/ops/resize_bicubic.cc:147:    Tensor *output = this->Output(0);
mace/ops/resize_bicubic.cc:162:    Tensor::MappingGuard input_mapper(input);
mace/ops/resize_bicubic.cc:163:    Tensor::MappingGuard output_mapper(output);
mace/ops/resize_bicubic.cc:222:    const Tensor *input = this->Input(0);
mace/ops/resize_bicubic.cc:223:    Tensor *output = this->Output(0);
mace/ops/space_to_depth.cc:39:    const Tensor *input = this->Input(0);
mace/ops/space_to_depth.cc:40:    Tensor *output = this->Output(0);
mace/ops/space_to_depth.cc:59:    Tensor::MappingGuard logits_guard(input);
mace/ops/space_to_depth.cc:60:    Tensor::MappingGuard output_guard(output);
mace/ops/space_to_depth.cc:103:    const Tensor *input = this->Input(0);
mace/ops/space_to_depth.cc:104:    Tensor *output = this->Output(0);
mace/ops/space_to_depth.cc:123:    Tensor::MappingGuard logits_guard(input);
mace/ops/space_to_depth.cc:124:    Tensor::MappingGuard output_guard(output);
mace/ops/space_to_depth.cc:172:    const Tensor *input = this->Input(0);
mace/ops/space_to_depth.cc:173:    Tensor *output = this->Output(0);
mace/ops/pad.cc:53:    const Tensor *input = this->Input(0);
mace/ops/pad.cc:54:    Tensor *output = this->Output(0);
mace/ops/pad.cc:74:    Tensor::MappingGuard input_guard(input);
mace/ops/pad.cc:75:    Tensor::MappingGuard output_guard(output);
mace/ops/pad.cc:190:    const Tensor *input = this->Input(0);
mace/ops/pad.cc:191:    Tensor *output = this->Output(0);
mace/ops/matmul.cc:62:    const Tensor *A = this->Input(INPUT_A);
mace/ops/matmul.cc:63:    const Tensor *B = this->Input(INPUT_B);
mace/ops/matmul.cc:110:    const Tensor *lhs = this->Input(INPUT_A);
mace/ops/matmul.cc:111:    const Tensor *rhs = this->Input(INPUT_B);
mace/ops/matmul.cc:112:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(BIAS) : nullptr;
mace/ops/matmul.cc:113:    Tensor *C = this->Output(OUTPUT);
mace/ops/matmul.cc:197:        Tensor::MappingGuard bias_guard(bias);
mace/ops/matmul.cc:198:        Tensor::MappingGuard c_guard(C);
mace/ops/matmul.cc:238:                  const Tensor *A,
mace/ops/matmul.cc:239:                  const Tensor *B,
mace/ops/matmul.cc:246:                  Tensor *C) {
mace/ops/matmul.cc:272:      Tensor::MappingGuard guarda(A);
mace/ops/matmul.cc:273:      Tensor::MappingGuard guardb(B);
mace/ops/matmul.cc:274:      Tensor::MappingGuard guardc(C);
mace/ops/matmul.cc:322:                  const Tensor *A,
mace/ops/matmul.cc:323:                  const Tensor *B,
mace/ops/matmul.cc:330:                  Tensor *C) {
mace/ops/matmul.cc:359:      Tensor::MappingGuard guarda(A);
mace/ops/matmul.cc:360:      Tensor::MappingGuard guardb(B);
mace/ops/matmul.cc:361:      Tensor::MappingGuard guardc(C);
mace/ops/matmul.cc:412:    const Tensor *lhs = this->Input(INPUT_A);
mace/ops/matmul.cc:413:    const Tensor *rhs = this->Input(INPUT_B);
mace/ops/matmul.cc:414:    Tensor *C = this->Output(OUTPUT);
mace/ops/matmul.cc:505:    const Tensor *A = this->Input(INPUT_A);
mace/ops/matmul.cc:506:    const Tensor *B = this->Input(INPUT_B);
mace/ops/matmul.cc:507:    Tensor *C = this->Output(OUTPUT);
mace/ops/matmul.cc:526:    const Tensor *A = this->Input(INPUT_A);
mace/ops/matmul.cc:527:    const Tensor *B = this->Input(INPUT_B);
mace/ops/matmul.cc:528:    Tensor *C = this->Output(OUTPUT);
mace/ops/matmul.cc:555:    Tensor::MappingGuard guarda(A);
mace/ops/matmul.cc:556:    Tensor::MappingGuard guardb(B);
mace/ops/matmul.cc:557:    Tensor::MappingGuard guardc(C);
mace/ops/infer_conv2d_shape.cc:29:    const Tensor *input = this->Input(0);
mace/ops/infer_conv2d_shape.cc:30:    Tensor *output = this->Output(0);
mace/ops/infer_conv2d_shape.cc:33:    Tensor::MappingGuard output_guard(output);
mace/ops/channel_shuffle.cc:38:    const Tensor *input = this->Input(0);
mace/ops/channel_shuffle.cc:39:    Tensor *output = this->Output(0);
mace/ops/channel_shuffle.cc:45:    Tensor::MappingGuard logits_guard(input);
mace/ops/channel_shuffle.cc:46:    Tensor::MappingGuard output_guard(output);
mace/ops/channel_shuffle.cc:91:    const Tensor *input = this->Input(0);
mace/ops/channel_shuffle.cc:92:    Tensor *output = this->Output(0);
mace/ops/cast.cc:32:    const Tensor *input = this->Input(INPUT);
mace/ops/cast.cc:33:    Tensor *output = this->Output(OUTPUT);
mace/ops/cast.cc:36:    Tensor::MappingGuard input_guard(input);
mace/ops/cast.cc:37:    Tensor::MappingGuard output_guard(output);
mace/ops/batch_norm.cc:57:    const Tensor *input = this->Input(INPUT);
mace/ops/batch_norm.cc:58:    const Tensor *scale = this->Input(SCALE);
mace/ops/batch_norm.cc:59:    const Tensor *offset = this->Input(OFFSET);
mace/ops/batch_norm.cc:68:    Tensor *output = this->Output(OUTPUT);
mace/ops/batch_norm.cc:88:      Tensor::MappingGuard input_mapper(input);
mace/ops/batch_norm.cc:89:      Tensor::MappingGuard scale_mapper(scale);
mace/ops/batch_norm.cc:90:      Tensor::MappingGuard offset_mapper(offset);
mace/ops/batch_norm.cc:91:      Tensor::MappingGuard output_mapper(output);
mace/ops/batch_norm.cc:101:        const Tensor *mean = this->Input(MEAN);
mace/ops/batch_norm.cc:102:        const Tensor *var = this->Input(VAR);
mace/ops/batch_norm.cc:109:        Tensor::MappingGuard mean_mapper(mean);
mace/ops/batch_norm.cc:110:        Tensor::MappingGuard var_mapper(var);
mace/ops/batch_norm.cc:187:      const Tensor *input_tensor = context->workspace()->GetTensor(
mace/ops/batch_norm.cc:200:    const Tensor *input = this->Input(INPUT);
mace/ops/batch_norm.cc:201:    const Tensor *scale = this->Input(SCALE);
mace/ops/batch_norm.cc:202:    const Tensor *offset = this->Input(OFFSET);
mace/ops/batch_norm.cc:203:    const Tensor *mean = not_folded ? this->Input(MEAN) : nullptr;
mace/ops/batch_norm.cc:204:    const Tensor *var = not_folded ? this->Input(VAR) : nullptr;
mace/ops/batch_norm.cc:219:    Tensor *output = this->Output(OUTPUT);
mace/ops/expand_dims.cc:34:    const Tensor *input = this->Input(0);
mace/ops/expand_dims.cc:35:    Tensor *output = this->Output(0);
mace/ops/expand_dims.cc:46:    output->ReuseTensorBuffer(*input);
mace/ops/target_rms_norm.cc:94:    const Tensor *input = this->Input(0);
mace/ops/target_rms_norm.cc:95:    Tensor *output = this->Output(0);
mace/ops/target_rms_norm.cc:114:    Tensor::MappingGuard guard_input(input);
mace/ops/target_rms_norm.cc:115:    Tensor::MappingGuard guard_output(output);
mace/ops/kaldi_batch_norm.cc:68:    const Tensor *input = this->Input(INPUT);
mace/ops/kaldi_batch_norm.cc:81:    Tensor *output = this->Output(OUTPUT);
mace/ops/kaldi_batch_norm.cc:84:    Tensor::MappingGuard input_guard(input);
mace/ops/kaldi_batch_norm.cc:85:    Tensor::MappingGuard output_guard(output);
mace/ops/kaldi_batch_norm.cc:94:      const Tensor *scale = this->Input(SCALE);
mace/ops/kaldi_batch_norm.cc:95:      const Tensor *offset = this->Input(OFFSET);
mace/ops/kaldi_batch_norm.cc:102:      Tensor::MappingGuard scale_guard(scale);
mace/ops/kaldi_batch_norm.cc:103:      Tensor::MappingGuard offset_guard(offset);
mace/ops/kaldi_batch_norm.cc:123:      Tensor mean(scratch->Scratch(buf_size), DT_FLOAT);
mace/ops/kaldi_batch_norm.cc:127:      Tensor var(scratch->Scratch(buf_size), DT_FLOAT);
mace/ops/reduce.cc:46:    const Tensor *input = this->Input(0);
mace/ops/reduce.cc:74:    const Tensor *input = this->Input(0);
mace/ops/reduce.cc:75:    Tensor *output = this->Output(0);
mace/ops/reduce.cc:86:  void Simplify(const Tensor *input) {
mace/ops/reduce.cc:589:  void Compute(const OpContext *context, const Tensor *input, Tensor *output) {
mace/ops/reduce.cc:590:    Tensor::MappingGuard input_mapper(input);
mace/ops/reduce.cc:592:    Tensor::MappingGuard output_map(output);
mace/ops/reduce.cc:1024:    const Tensor *input = this->Input(0);
mace/ops/reduce.cc:1025:    Tensor *output = this->Output(0);
mace/ops/depthwise_deconv2d.cc:65:    const Tensor *input = this->Input(0);
mace/ops/depthwise_deconv2d.cc:66:    const Tensor *filter = this->Input(1);
mace/ops/depthwise_deconv2d.cc:67:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(2) : nullptr;
mace/ops/depthwise_deconv2d.cc:68:    Tensor *output = this->Output(0);
mace/ops/depthwise_deconv2d.cc:210:    const Tensor *input = this->Input(0);
mace/ops/depthwise_deconv2d.cc:211:    const Tensor *filter = this->Input(1);
mace/ops/depthwise_deconv2d.cc:212:    const Tensor *bias = this->InputSize() >= 3 ? this->Input(2) : nullptr;
mace/ops/depthwise_deconv2d.cc:213:    Tensor *output = this->Output(0);
mace/ops/depthwise_conv2d.cc:33:// We reuse TensorFlow Lite's optimized depthwiseconv_uint8 and parallelized it
mace/ops/depthwise_conv2d.cc:84:    const Tensor *input = this->Input(INPUT);
mace/ops/depthwise_conv2d.cc:85:    const Tensor *filter = this->Input(FILTER);
mace/ops/depthwise_conv2d.cc:86:    const Tensor *bias = nullptr;
mace/ops/depthwise_conv2d.cc:90:    Tensor *output = this->Output(OUTPUT);
mace/ops/depthwise_conv2d.cc:172:    const Tensor *input = this->Input(INPUT);
mace/ops/depthwise_conv2d.cc:173:    const Tensor *filter = this->Input(FILTER);
mace/ops/depthwise_conv2d.cc:174:    const Tensor *bias = nullptr;
mace/ops/depthwise_conv2d.cc:178:    Tensor *output = this->Output(OUTPUT);
mace/ops/depthwise_conv2d.cc:228:    Tensor::MappingGuard input_guard(input);
mace/ops/depthwise_conv2d.cc:229:    Tensor::MappingGuard filter_guard(filter);
mace/ops/depthwise_conv2d.cc:230:    Tensor::MappingGuard bias_guard(bias);
mace/ops/depthwise_conv2d.cc:231:    Tensor::MappingGuard output_guard(output);
mace/ops/depthwise_conv2d.cc:385:    Tensor *filter_tensor = context->workspace()->GetTensor(
mace/ops/depthwise_conv2d.cc:403:    const Tensor *input = this->Input(INPUT);
mace/ops/depthwise_conv2d.cc:404:    const Tensor *filter = this->Input(FILTER);
mace/ops/depthwise_conv2d.cc:405:    const Tensor *bias = nullptr;
mace/ops/depthwise_conv2d.cc:409:    Tensor *output = this->Output(OUTPUT);
mace/ops/depthwise_conv2d.cc:449:                  auto filter_tensor = context->workspace()->GetTensor(
mace/ops/strided_slice.cc:91:    const Tensor *input = this->Input(INPUT);
mace/ops/strided_slice.cc:92:    const Tensor *begin_indices = this->Input(BEGIN);
mace/ops/strided_slice.cc:93:    const Tensor *end_indices = this->Input(END);
mace/ops/strided_slice.cc:94:    const Tensor *strides = nullptr;
mace/ops/strided_slice.cc:101:      Tensor::MappingGuard strides_guard(&tmp_strides_tensor_);
mace/ops/strided_slice.cc:112:    Tensor::MappingGuard input_guard(input);
mace/ops/strided_slice.cc:113:    Tensor::MappingGuard begin_indices_guard(begin_indices);
mace/ops/strided_slice.cc:114:    Tensor::MappingGuard end_indices_guard(end_indices);
mace/ops/strided_slice.cc:115:    Tensor::MappingGuard strides_guard(strides);
mace/ops/strided_slice.cc:247:    Tensor *output = this->Output(OUTPUT);
mace/ops/strided_slice.cc:249:    Tensor::MappingGuard output_guard(output);
mace/ops/strided_slice.cc:347:  Tensor tmp_strides_tensor_;
mace/ops/cumsum.cc:58:    const Tensor *input = this->Input(0);
mace/ops/cumsum.cc:61:    Tensor *output = this->Output(0);
mace/ops/cumsum.cc:64:    Tensor::MappingGuard input_mapper(input);
mace/ops/cumsum.cc:65:    Tensor::MappingGuard output_mapper(output);
mace/ops/one_hot.cc:51:    const Tensor *input = this->Input(0);
mace/ops/one_hot.cc:52:    Tensor *output = this->Output(0);
mace/ops/one_hot.cc:72:    Tensor::MappingGuard input_guard(input);
mace/ops/one_hot.cc:73:    Tensor::MappingGuard output_guard(output);
mace/ops/one_hot.cc:103:  void run(const Tensor *input, const T **input_ptr,
mace/ops/transpose.cc:41:    const Tensor *input = this->Input(0);
mace/ops/transpose.cc:42:    Tensor *output = this->Output(0);
mace/ops/transpose.cc:54:    Tensor::MappingGuard input_guard(input);
mace/ops/transpose.cc:55:    Tensor::MappingGuard output_guard(output);
mace/ops/slice.cc:37:    const Tensor *input = this->Input(0);
mace/ops/slice.cc:38:    Tensor *output = this->Output(0);
mace/ops/slice.cc:64:    Tensor::MappingGuard input_guard(input);
mace/ops/slice.cc:65:    Tensor::MappingGuard output_guard(output);
mace/ops/activation.cc:56:    const Tensor *input = this->Input(0);
mace/ops/activation.cc:57:    Tensor *output = this->Output(0);
mace/ops/activation.cc:64:      const Tensor *alpha = this->Input(1);
mace/ops/activation.cc:112:    const Tensor *input = this->Input(0);
mace/ops/activation.cc:113:    const Tensor *alpha = this->InputSize() > 1 ? this->Input(1) : nullptr;
mace/ops/activation.cc:114:    Tensor *output = this->Output(0);
mace/ops/scalar_math.cc:107:    Tensor *output = this->Output(0);
mace/ops/scalar_math.cc:108:    const Tensor* input0 = inputs_[0];
mace/ops/scalar_math.cc:109:    const Tensor* input1 = (inputs_.size() >= 2) ? inputs_[1] : nullptr;
mace/ops/scalar_math.cc:112:    Tensor::MappingGuard in0_guard(input0);
mace/ops/scalar_math.cc:116:    Tensor::MappingGuard in1_guard(input1);
mace/ops/scalar_math.cc:127:    Tensor::MappingGuard output_guard(output);
mace/ops/shape.cc:28:    const Tensor *input = this->Input(INPUT);
mace/ops/shape.cc:29:    Tensor *output = this->Output(OUTPUT);
mace/ops/shape.cc:35:    Tensor::MappingGuard output_guard(output);
mace/ops/delay.cc:39:    const Tensor *input = this->Input(0);
mace/ops/delay.cc:40:    Tensor *output = this->Output(0);
mace/ops/delay.cc:57:    Tensor::MappingGuard input_guard(input);
mace/ops/delay.cc:58:    Tensor::MappingGuard output_guard(output);
mace/ops/batch_to_space.cc:44:  void CalculateBatchToSpaceOutputShape(const Tensor *input_tensor,
mace/ops/batch_to_space.cc:94:    const Tensor *batch_tensor = this->Input(0);
mace/ops/batch_to_space.cc:95:    Tensor *space_tensor = this->Output(0);
mace/ops/batch_to_space.cc:102:    Tensor::MappingGuard input_guard(batch_tensor);
mace/ops/batch_to_space.cc:103:    Tensor::MappingGuard output_guard(space_tensor);
mace/ops/batch_to_space.cc:186:    const Tensor *batch_tensor = this->Input(0);
mace/ops/batch_to_space.cc:187:    Tensor *space_tensor = this->Output(0);
mace/ops/batch_to_space.cc:194:    Tensor::MappingGuard input_guard(batch_tensor);
mace/ops/batch_to_space.cc:195:    Tensor::MappingGuard output_guard(space_tensor);
mace/ops/batch_to_space.cc:274:    const Tensor *batch_tensor = this->Input(0);
mace/ops/batch_to_space.cc:275:    Tensor *space_tensor = this->Output(0);
mace/ops/unstack.cc:32:    const Tensor *input = this->Input(0);
mace/ops/unstack.cc:33:    const std::vector<Tensor *> outputs = this->Outputs();
mace/ops/depth_to_space.cc:39:    const Tensor *input = this->Input(0);
mace/ops/depth_to_space.cc:40:    Tensor *output = this->Output(0);
mace/ops/depth_to_space.cc:59:    Tensor::MappingGuard logits_guard(input);
mace/ops/depth_to_space.cc:60:    Tensor::MappingGuard output_guard(output);
mace/ops/depth_to_space.cc:105:    const Tensor *input = this->Input(0);
mace/ops/depth_to_space.cc:106:    Tensor *output = this->Output(0);
mace/ops/depth_to_space.cc:125:    Tensor::MappingGuard logits_guard(input);
mace/ops/depth_to_space.cc:126:    Tensor::MappingGuard output_guard(output);
mace/ops/depth_to_space.cc:176:    const Tensor *input = this->Input(0);
mace/ops/depth_to_space.cc:177:    Tensor *output = this->Output(0);
mace/ops/opencl/batch_to_space.h:27:class Tensor;
mace/ops/opencl/batch_to_space.h:34:      const Tensor *batch_tensor,
mace/ops/opencl/batch_to_space.h:38:      Tensor *space_tensor) = 0;
mace/ops/opencl/buffer/conv_2d.cc:40:    const Tensor *input,
mace/ops/opencl/buffer/conv_2d.cc:41:    const Tensor *filter,
mace/ops/opencl/buffer/conv_2d.cc:42:    const Tensor *bias,
mace/ops/opencl/buffer/conv_2d.cc:51:    Tensor *output) {
mace/ops/opencl/buffer/conv_2d.cc:87:  std::function<MaceStatus(const Tensor *input, Tensor *output)> conv_func;
mace/ops/opencl/buffer/conv_2d.cc:110:  const Tensor *padded_input_ptr = input;
mace/ops/opencl/buffer/conv_2d.cc:112:  std::unique_ptr<Tensor> padded_input;
mace/ops/opencl/buffer/conv_2d.cc:137:    padded_input = make_unique<Tensor>(scratch->Scratch(padded_input_size),
mace/ops/opencl/buffer/conv_2d.cc:147:    conv_func = [&](const Tensor *pad_input, Tensor *output) -> MaceStatus {
mace/ops/opencl/buffer/conv_2d.cc:154:    conv_func = [&](const Tensor *pad_input, Tensor *output) -> MaceStatus {
mace/ops/opencl/buffer/buffer_transform.h:34:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.h:35:    Tensor *output);
mace/ops/opencl/buffer/buffer_transform.h:40:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.h:41:    Tensor *output);
mace/ops/opencl/buffer/buffer_transform.h:46:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.h:47:    Tensor *output);
mace/ops/opencl/buffer/buffer_transform.h:52:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.h:53:    Tensor *output);
mace/ops/opencl/buffer/buffer_transform.h:59:      const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.h:62:      Tensor *output) override;
mace/ops/opencl/buffer/utils.cc:31:                    const Tensor *input,
mace/ops/opencl/buffer/utils.cc:35:                    Tensor *padded_input,
mace/ops/opencl/buffer/utils.h:30:                    const Tensor *input,
mace/ops/opencl/buffer/utils.h:34:                    Tensor *padded_input,
mace/ops/opencl/buffer/pooling.h:39:      const Tensor *input,
mace/ops/opencl/buffer/pooling.h:47:      Tensor *output) override;
mace/ops/opencl/buffer/conv_2d.h:35:                            const Tensor *padded_input,
mace/ops/opencl/buffer/conv_2d.h:36:                            const Tensor *filter,
mace/ops/opencl/buffer/conv_2d.h:37:                            const Tensor *bias,
mace/ops/opencl/buffer/conv_2d.h:43:                            Tensor *output,
mace/ops/opencl/buffer/conv_2d.h:48:                                const Tensor *input,
mace/ops/opencl/buffer/conv_2d.h:49:                                const Tensor *filter,
mace/ops/opencl/buffer/conv_2d.h:50:                                const Tensor *bias,
mace/ops/opencl/buffer/conv_2d.h:57:                                Tensor *output,
mace/ops/opencl/buffer/conv_2d.h:75:      const Tensor *input,
mace/ops/opencl/buffer/conv_2d.h:76:      const Tensor *filter,
mace/ops/opencl/buffer/conv_2d.h:77:      const Tensor *bias,
mace/ops/opencl/buffer/conv_2d.h:86:      Tensor *output) override;
mace/ops/opencl/buffer/softmax.h:40:      const Tensor *logits,
mace/ops/opencl/buffer/softmax.h:41:      Tensor *output) override;
mace/ops/opencl/buffer/conv_2d_1x1.cc:28:                     const Tensor *padded_input,
mace/ops/opencl/buffer/conv_2d_1x1.cc:29:                     const Tensor *filter,
mace/ops/opencl/buffer/conv_2d_1x1.cc:30:                     const Tensor *bias,
mace/ops/opencl/buffer/conv_2d_1x1.cc:36:                     Tensor *output,
mace/ops/opencl/buffer/depthwise_conv2d.cc:28:                           const Tensor *padded_input,   // NHWC
mace/ops/opencl/buffer/depthwise_conv2d.cc:29:                           const Tensor *filter,  // HWIM
mace/ops/opencl/buffer/depthwise_conv2d.cc:30:                           const Tensor *bias,
mace/ops/opencl/buffer/depthwise_conv2d.cc:37:                           Tensor *output,
mace/ops/opencl/buffer/depthwise_conv2d.cc:141:    const Tensor *input,
mace/ops/opencl/buffer/depthwise_conv2d.cc:142:    const Tensor *filter,
mace/ops/opencl/buffer/depthwise_conv2d.cc:143:    const Tensor *bias,
mace/ops/opencl/buffer/depthwise_conv2d.cc:151:    Tensor *output) {
mace/ops/opencl/buffer/depthwise_conv2d.cc:206:  const Tensor *padded_input_ptr = input;
mace/ops/opencl/buffer/depthwise_conv2d.cc:208:  std::unique_ptr<Tensor> padded_input;
mace/ops/opencl/buffer/depthwise_conv2d.cc:232:    padded_input = make_unique<Tensor>(scratch->Scratch(padded_input_size),
mace/ops/opencl/buffer/buffer_transform.cc:29:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.cc:30:    Tensor *output) {
mace/ops/opencl/buffer/buffer_transform.cc:100:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.cc:101:    Tensor *output) {
mace/ops/opencl/buffer/buffer_transform.cc:166:    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.cc:167:    Tensor *output) {
mace/ops/opencl/buffer/buffer_transform.cc:233:                                    const Tensor *input,
mace/ops/opencl/buffer/buffer_transform.cc:236:                                    Tensor *output) {
mace/ops/opencl/buffer/buffer_transform.cc:250:        output->ReuseTensorBuffer(*input);
mace/ops/opencl/buffer/conv_2d_general.cc:28:                         const Tensor *padded_input,
mace/ops/opencl/buffer/conv_2d_general.cc:29:                         const Tensor *filter,
mace/ops/opencl/buffer/conv_2d_general.cc:30:                         const Tensor *bias,
mace/ops/opencl/buffer/conv_2d_general.cc:37:                         Tensor *output,
mace/ops/opencl/buffer/softmax.cc:25:    const Tensor *logits,
mace/ops/opencl/buffer/softmax.cc:26:    Tensor *output) {
mace/ops/opencl/buffer/depthwise_conv2d.h:35:                           const Tensor *padded_input,   // NHWC
mace/ops/opencl/buffer/depthwise_conv2d.h:36:                           const Tensor *filter,  // HWIM
mace/ops/opencl/buffer/depthwise_conv2d.h:37:                           const Tensor *bias,
mace/ops/opencl/buffer/depthwise_conv2d.h:44:                           Tensor *output,
mace/ops/opencl/buffer/depthwise_conv2d.h:53:      const Tensor *input,
mace/ops/opencl/buffer/depthwise_conv2d.h:54:      const Tensor *filter,
mace/ops/opencl/buffer/depthwise_conv2d.h:55:      const Tensor *bias,
mace/ops/opencl/buffer/depthwise_conv2d.h:63:      Tensor *output) override;
mace/ops/opencl/buffer/pooling.cc:25:    const Tensor *input,
mace/ops/opencl/buffer/pooling.cc:33:    Tensor *output) {
mace/ops/opencl/buffer/pooling.cc:69:  const Tensor *padded_input_ptr = input;
mace/ops/opencl/buffer/pooling.cc:71:  std::unique_ptr<Tensor> padded_input;
mace/ops/opencl/buffer/pooling.cc:93:    padded_input = make_unique<Tensor>(scratch->Scratch(padded_input_size),
mace/ops/opencl/buffer/buffer_type_transform.cc:29:    const Tensor *input,
mace/ops/opencl/buffer/buffer_type_transform.cc:30:    Tensor *output) {
mace/ops/opencl/lstm_cell.cc:46:    const Tensor *pre_output = context->workspace()->GetTensor(
mace/ops/opencl/lstm_cell.cc:62:    const Tensor *pre_cell =
mace/ops/opencl/lstm_cell.cc:63:        context->workspace()->GetTensor(operator_def_->input(4));
mace/ops/opencl/lstm_cell.cc:73:    const Tensor *input = this->Input(INPUT);
mace/ops/opencl/lstm_cell.cc:74:    const Tensor *pre_output = this->Input(PRE_OUTPUT);
mace/ops/opencl/lstm_cell.cc:75:    const Tensor *weight = this->Input(WEIGHT);
mace/ops/opencl/lstm_cell.cc:76:    const Tensor *bias = this->Input(BIAS);
mace/ops/opencl/lstm_cell.cc:77:    const Tensor *pre_cell = this->Input(PRE_CELL);
mace/ops/opencl/lstm_cell.cc:78:    Tensor *cell = this->Output(CELL);
mace/ops/opencl/lstm_cell.cc:79:    Tensor *output = this->Output(OUTPUT);
mace/ops/opencl/image/batch_to_space.h:37:      const Tensor *batch_tensor,
mace/ops/opencl/image/batch_to_space.h:41:      Tensor *space_tensor) override;
mace/ops/opencl/image/fully_connected.cc:25:    const Tensor *input,
mace/ops/opencl/image/fully_connected.cc:26:    const Tensor *weight,
mace/ops/opencl/image/fully_connected.cc:27:    const Tensor *bias,
mace/ops/opencl/image/fully_connected.cc:31:    Tensor *output) {
mace/ops/opencl/image/split.cc:24:    const Tensor *input,
mace/ops/opencl/image/split.cc:25:    const std::vector<Tensor *> &output_list) {
mace/ops/opencl/image/bias_add.cc:24:    const Tensor *input,
mace/ops/opencl/image/bias_add.cc:25:    const Tensor *bias,
mace/ops/opencl/image/bias_add.cc:26:    Tensor *output) {
mace/ops/opencl/image/conv_2d.cc:62:    const Tensor *input,
mace/ops/opencl/image/conv_2d.cc:63:    const Tensor *filter,
mace/ops/opencl/image/conv_2d.cc:64:    const Tensor *bias,
mace/ops/opencl/image/conv_2d.cc:73:    Tensor *output) {
mace/ops/opencl/image/lstm_cell.cc:24:    const Tensor *input,
mace/ops/opencl/image/lstm_cell.cc:25:    const Tensor *pre_output,
mace/ops/opencl/image/lstm_cell.cc:26:    const Tensor *weight,
mace/ops/opencl/image/lstm_cell.cc:27:    const Tensor *bias,
mace/ops/opencl/image/lstm_cell.cc:28:    const Tensor *pre_cell,
mace/ops/opencl/image/lstm_cell.cc:29:    Tensor *cell,
mace/ops/opencl/image/lstm_cell.cc:30:    Tensor *output) {
mace/ops/opencl/image/resize_bilinear.cc:27:    const Tensor *input,
mace/ops/opencl/image/resize_bilinear.cc:28:    Tensor *output) {
mace/ops/opencl/image/matmul.h:38:      const Tensor *A,
mace/ops/opencl/image/matmul.h:39:      const Tensor *B,
mace/ops/opencl/image/matmul.h:40:      Tensor *C,
mace/ops/opencl/image/addn.h:37:      const std::vector<const Tensor *> &input_tensors,
mace/ops/opencl/image/addn.h:38:      Tensor *output_tensor) override;
mace/ops/opencl/image/reduce.h:42:      const Tensor *input,
mace/ops/opencl/image/reduce.h:43:      Tensor *output) override;
mace/ops/opencl/image/lstm_cell.h:40:      const Tensor *input,
mace/ops/opencl/image/lstm_cell.h:41:      const Tensor *pre_output,
mace/ops/opencl/image/lstm_cell.h:42:      const Tensor *weight,
mace/ops/opencl/image/lstm_cell.h:43:      const Tensor *bias,
mace/ops/opencl/image/lstm_cell.h:44:      const Tensor *pre_cell,
mace/ops/opencl/image/lstm_cell.h:45:      Tensor *cell,
mace/ops/opencl/image/lstm_cell.h:46:      Tensor *output) override;
mace/ops/opencl/image/pooling.h:64:      const Tensor *input,
mace/ops/opencl/image/pooling.h:72:      Tensor *output) override;
mace/ops/opencl/image/winograd_conv2d.cc:31:                                  const Tensor *input_tensor,
mace/ops/opencl/image/winograd_conv2d.cc:37:                                  Tensor *output_tensor,
mace/ops/opencl/image/winograd_conv2d.cc:109:                                   const Tensor *input_tensor,
mace/ops/opencl/image/winograd_conv2d.cc:110:                                   const Tensor *bias,
mace/ops/opencl/image/winograd_conv2d.cc:118:                                   Tensor *output_tensor,
mace/ops/opencl/image/winograd_conv2d.cc:230:                                       const Tensor *input,
mace/ops/opencl/image/winograd_conv2d.cc:231:                                       const Tensor *filter,
mace/ops/opencl/image/winograd_conv2d.cc:232:                                       const Tensor *bias,
mace/ops/opencl/image/winograd_conv2d.cc:239:                                       Tensor *output,
mace/ops/opencl/image/winograd_conv2d.cc:275:  auto transformed_input = make_unique<Tensor>(image, input_dt);
mace/ops/opencl/image/winograd_conv2d.cc:299:  std::unique_ptr<Tensor> mm_output = make_unique<Tensor>(
mace/ops/opencl/image/sqrdiff_mean.h:37:      const Tensor *input,
mace/ops/opencl/image/sqrdiff_mean.h:38:      const Tensor *input1,
mace/ops/opencl/image/sqrdiff_mean.h:39:      Tensor *output) override;
mace/ops/opencl/image/conv_2d_3x3.cc:64:                      const Tensor *input,
mace/ops/opencl/image/conv_2d_3x3.cc:65:                      const Tensor *filter,
mace/ops/opencl/image/conv_2d_3x3.cc:66:                      const Tensor *bias,
mace/ops/opencl/image/conv_2d_3x3.cc:74:                      Tensor *output,
mace/ops/opencl/image/crop.cc:25:    const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/crop.cc:26:    Tensor *output) {
mace/ops/opencl/image/crop.cc:30:  const Tensor *input0 = input_list[0];
mace/ops/opencl/image/crop.cc:31:  const Tensor *input1 = input_list[1];
mace/ops/opencl/image/deconv_2d.cc:25:    const Tensor *input,
mace/ops/opencl/image/deconv_2d.cc:26:    const Tensor *filter,
mace/ops/opencl/image/deconv_2d.cc:27:    const Tensor *bias,
mace/ops/opencl/image/deconv_2d.cc:34:    Tensor *output) {
mace/ops/opencl/image/conv_2d.h:33:                             const Tensor *input,
mace/ops/opencl/image/conv_2d.h:34:                             const Tensor *filter,
mace/ops/opencl/image/conv_2d.h:35:                             const Tensor *bias,
mace/ops/opencl/image/conv_2d.h:43:                             Tensor *output,
mace/ops/opencl/image/conv_2d.h:48:                             const Tensor *input,
mace/ops/opencl/image/conv_2d.h:49:                             const Tensor *filter,
mace/ops/opencl/image/conv_2d.h:50:                             const Tensor *bias,
mace/ops/opencl/image/conv_2d.h:58:                             Tensor *output,
mace/ops/opencl/image/conv_2d.h:63:                         const Tensor *input,
mace/ops/opencl/image/conv_2d.h:64:                         const Tensor *filter,
mace/ops/opencl/image/conv_2d.h:65:                         const Tensor *bias,
mace/ops/opencl/image/conv_2d.h:73:                         Tensor *output,
mace/ops/opencl/image/conv_2d.h:78:                                       const Tensor *input,
mace/ops/opencl/image/conv_2d.h:79:                                       const Tensor *filter,
mace/ops/opencl/image/conv_2d.h:80:                                       const Tensor *bias,
mace/ops/opencl/image/conv_2d.h:87:                                       Tensor *output,
mace/ops/opencl/image/conv_2d.h:102:      const Tensor *input,
mace/ops/opencl/image/conv_2d.h:103:      const Tensor *filter,
mace/ops/opencl/image/conv_2d.h:104:      const Tensor *bias,
mace/ops/opencl/image/conv_2d.h:113:      Tensor *output) override;
mace/ops/opencl/image/resize_bicubic.cc:26:    const Tensor *input,
mace/ops/opencl/image/resize_bicubic.cc:27:    Tensor *output) {
mace/ops/opencl/image/buffer_to_image.cc:24:    const Tensor *input,
mace/ops/opencl/image/buffer_to_image.cc:27:    Tensor *output) {
mace/ops/opencl/image/space_to_depth.cc:24:    const Tensor *input,
mace/ops/opencl/image/space_to_depth.cc:25:    Tensor *output) {
mace/ops/opencl/image/softmax.h:66:      const Tensor *logits,
mace/ops/opencl/image/softmax.h:67:      Tensor *output) override;
mace/ops/opencl/image/pad.cc:24:    const Tensor *input,
mace/ops/opencl/image/pad.cc:25:    Tensor *output) {
mace/ops/opencl/image/concat.h:33:                   const Tensor *input0,
mace/ops/opencl/image/concat.h:34:                   const Tensor *input1,
mace/ops/opencl/image/concat.h:36:                   Tensor *output,
mace/ops/opencl/image/concat.h:41:                   const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/concat.h:42:                   Tensor *output,
mace/ops/opencl/image/concat.h:51:      const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/concat.h:53:      Tensor *output) override;
mace/ops/opencl/image/matmul.cc:24:    const Tensor *A,
mace/ops/opencl/image/matmul.cc:25:    const Tensor *B,
mace/ops/opencl/image/matmul.cc:26:    Tensor *C,
mace/ops/opencl/image/channel_shuffle.h:38:      const Tensor *input,
mace/ops/opencl/image/channel_shuffle.h:39:      Tensor *output) override;
mace/ops/opencl/image/image_to_buffer.h:34:                     const Tensor *input,
mace/ops/opencl/image/image_to_buffer.h:37:                     Tensor *output) override;
mace/ops/opencl/image/conv_2d_1x1.cc:71:                      const Tensor *input,
mace/ops/opencl/image/conv_2d_1x1.cc:72:                      const Tensor *filter,
mace/ops/opencl/image/conv_2d_1x1.cc:73:                      const Tensor *bias,
mace/ops/opencl/image/conv_2d_1x1.cc:81:                      Tensor *output,
mace/ops/opencl/image/channel_shuffle.cc:24:    const Tensor *input,
mace/ops/opencl/image/channel_shuffle.cc:25:    Tensor *output) {
mace/ops/opencl/image/batch_norm.cc:33:    const Tensor *input,
mace/ops/opencl/image/batch_norm.cc:34:    const Tensor *scale,
mace/ops/opencl/image/batch_norm.cc:35:    const Tensor *offset,
mace/ops/opencl/image/batch_norm.cc:36:    const Tensor *mean,
mace/ops/opencl/image/batch_norm.cc:37:    const Tensor *var,
mace/ops/opencl/image/batch_norm.cc:38:    Tensor *output) {
mace/ops/opencl/image/crop.h:40:      const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/crop.h:41:      Tensor *output) override;
mace/ops/opencl/image/reduce.cc:24:    const Tensor *input,
mace/ops/opencl/image/reduce.cc:25:    Tensor *output) {
mace/ops/opencl/image/depthwise_deconv2d.cc:25:    const Tensor *input,
mace/ops/opencl/image/depthwise_deconv2d.cc:26:    const Tensor *filter,
mace/ops/opencl/image/depthwise_deconv2d.cc:27:    const Tensor *bias,
mace/ops/opencl/image/depthwise_deconv2d.cc:35:    Tensor *output) {
mace/ops/opencl/image/space_to_depth.h:39:      const Tensor *input,
mace/ops/opencl/image/space_to_depth.h:40:      Tensor *output) override;
mace/ops/opencl/image/depthwise_conv2d.cc:68:                           const Tensor *input,   // NHWC
mace/ops/opencl/image/depthwise_conv2d.cc:69:                           const Tensor *filter,  // HWIM
mace/ops/opencl/image/depthwise_conv2d.cc:70:                           const Tensor *bias,
mace/ops/opencl/image/depthwise_conv2d.cc:78:                           Tensor *output,
mace/ops/opencl/image/depthwise_conv2d.cc:198:    const Tensor *input,
mace/ops/opencl/image/depthwise_conv2d.cc:199:    const Tensor *filter,
mace/ops/opencl/image/depthwise_conv2d.cc:200:    const Tensor *bias,
mace/ops/opencl/image/depthwise_conv2d.cc:208:    Tensor *output) {
mace/ops/opencl/image/space_to_batch.h:37:      const Tensor *space_tensor,
mace/ops/opencl/image/space_to_batch.h:41:      Tensor *batch_tensor) override;
mace/ops/opencl/image/resize_nearest_neighbor.h:74:      const Tensor *input,
mace/ops/opencl/image/resize_nearest_neighbor.h:75:      const Tensor *size,
mace/ops/opencl/image/resize_nearest_neighbor.h:76:      Tensor *output) override;
mace/ops/opencl/image/bias_add.h:37:      const Tensor *input,
mace/ops/opencl/image/bias_add.h:38:      const Tensor *bias,
mace/ops/opencl/image/bias_add.h:39:      Tensor *output) override;
mace/ops/opencl/image/fully_connected.h:38:      const Tensor *input,
mace/ops/opencl/image/fully_connected.h:39:      const Tensor *weight,
mace/ops/opencl/image/fully_connected.h:40:      const Tensor *bias,
mace/ops/opencl/image/fully_connected.h:44:      Tensor *output) override;
mace/ops/opencl/image/activation.cc:24:    const Tensor *input,
mace/ops/opencl/image/activation.cc:25:    const Tensor *alpha,
mace/ops/opencl/image/activation.cc:26:    Tensor *output) {
mace/ops/opencl/image/activation.h:44:      const Tensor *input,
mace/ops/opencl/image/activation.h:45:      const Tensor *alpha,
mace/ops/opencl/image/activation.h:46:      Tensor *output) override;
mace/ops/opencl/image/deconv_2d.h:37:      const Tensor *input,
mace/ops/opencl/image/deconv_2d.h:38:      const Tensor *filter,
mace/ops/opencl/image/deconv_2d.h:39:      const Tensor *bias,
mace/ops/opencl/image/deconv_2d.h:46:      Tensor *output) override;
mace/ops/opencl/image/buffer_to_image.h:37:      const Tensor *input,
mace/ops/opencl/image/buffer_to_image.h:40:      Tensor *output) override;
mace/ops/opencl/image/pad.h:43:      const Tensor *input,
mace/ops/opencl/image/pad.h:44:      Tensor *output) override;
mace/ops/opencl/image/batch_to_space.cc:24:    const Tensor *batch_tensor,
mace/ops/opencl/image/batch_to_space.cc:28:    Tensor *space_tensor) {
mace/ops/opencl/image/depth_to_space.cc:25:    const Tensor *input,
mace/ops/opencl/image/depth_to_space.cc:26:    Tensor *output) {
mace/ops/opencl/image/sqrdiff_mean.cc:24:    const Tensor *input0,
mace/ops/opencl/image/sqrdiff_mean.cc:25:    const Tensor *input1,
mace/ops/opencl/image/sqrdiff_mean.cc:26:    Tensor *output) {
mace/ops/opencl/image/addn.cc:24:    const std::vector<const Tensor *> &input_tensors,
mace/ops/opencl/image/addn.cc:25:    Tensor *output_tensor) {
mace/ops/opencl/image/resize_bilinear.h:78:      const Tensor *input,
mace/ops/opencl/image/resize_bilinear.h:79:      Tensor *output) override;
mace/ops/opencl/image/image_to_buffer.cc:23:                                  const Tensor *input,
mace/ops/opencl/image/image_to_buffer.cc:26:                                  Tensor *output) {
mace/ops/opencl/image/conv_2d_general.cc:72:                  const Tensor *input,
mace/ops/opencl/image/conv_2d_general.cc:73:                  const Tensor *filter,
mace/ops/opencl/image/conv_2d_general.cc:74:                  const Tensor *bias,
mace/ops/opencl/image/conv_2d_general.cc:82:                  Tensor *output,
mace/ops/opencl/image/batch_norm.h:42:                     const Tensor *input,
mace/ops/opencl/image/batch_norm.h:43:                     const Tensor *scale,
mace/ops/opencl/image/batch_norm.h:44:                     const Tensor *offset,
mace/ops/opencl/image/batch_norm.h:45:                     const Tensor *mean,
mace/ops/opencl/image/batch_norm.h:46:                     const Tensor *var,
mace/ops/opencl/image/batch_norm.h:47:                     Tensor *output) override;
mace/ops/opencl/image/softmax.cc:24:    const Tensor *logits,
mace/ops/opencl/image/softmax.cc:25:    Tensor *output) {
mace/ops/opencl/image/resize_bicubic.h:75:      const Tensor *input,
mace/ops/opencl/image/resize_bicubic.h:76:      Tensor *output) override;
mace/ops/opencl/image/space_to_batch.cc:24:    const Tensor *space_tensor,
mace/ops/opencl/image/space_to_batch.cc:28:    Tensor *batch_tensor) {
mace/ops/opencl/image/depth_to_space.h:39:      const Tensor *input,
mace/ops/opencl/image/depth_to_space.h:40:      Tensor *output) override;
mace/ops/opencl/image/eltwise.h:48:      const Tensor *input0,
mace/ops/opencl/image/eltwise.h:49:      const Tensor *input1,
mace/ops/opencl/image/eltwise.h:50:      Tensor *output) override;
mace/ops/opencl/image/depthwise_conv2d.h:34:                           const Tensor *input,   // NHWC
mace/ops/opencl/image/depthwise_conv2d.h:35:                           const Tensor *filter,  // HWIM
mace/ops/opencl/image/depthwise_conv2d.h:36:                           const Tensor *bias,
mace/ops/opencl/image/depthwise_conv2d.h:44:                           Tensor *output,
mace/ops/opencl/image/depthwise_conv2d.h:52:      const Tensor *input,
mace/ops/opencl/image/depthwise_conv2d.h:53:      const Tensor *filter,
mace/ops/opencl/image/depthwise_conv2d.h:54:      const Tensor *bias,
mace/ops/opencl/image/depthwise_conv2d.h:62:      Tensor *output) override;
mace/ops/opencl/image/depthwise_deconv2d.h:37:      const Tensor *input,
mace/ops/opencl/image/depthwise_deconv2d.h:38:      const Tensor *filter,
mace/ops/opencl/image/depthwise_deconv2d.h:39:      const Tensor *bias,
mace/ops/opencl/image/depthwise_deconv2d.h:47:      Tensor *output) override;
mace/ops/opencl/image/resize_nearest_neighbor.cc:26:    const Tensor *input,
mace/ops/opencl/image/resize_nearest_neighbor.cc:27:    const Tensor *size,
mace/ops/opencl/image/resize_nearest_neighbor.cc:28:    Tensor *output) {
mace/ops/opencl/image/resize_nearest_neighbor.cc:33:  Tensor::MappingGuard size_mapper(size);
mace/ops/opencl/image/split.h:39:      const Tensor *input,
mace/ops/opencl/image/split.h:40:      const std::vector<Tensor *> &output_list) override;
mace/ops/opencl/image/pooling.cc:24:    const Tensor *input,
mace/ops/opencl/image/pooling.cc:32:    Tensor *output) {
mace/ops/opencl/image/eltwise.cc:25:    const Tensor *input0,
mace/ops/opencl/image/eltwise.cc:26:    const Tensor *input1,
mace/ops/opencl/image/eltwise.cc:27:    Tensor *output) {
mace/ops/opencl/image/eltwise.cc:50:        // Tensor-Vector element wise
mace/ops/opencl/image/eltwise.cc:73:                        "Tensor-BatchVector(4D-[N,1,1,C]) "
mace/ops/opencl/image/eltwise.cc:74:                        "and Tensor-Tensor(4D-[N,H,W,1]). but got "
mace/ops/opencl/image/concat.cc:51:                   const Tensor *input0,
mace/ops/opencl/image/concat.cc:52:                   const Tensor *input1,
mace/ops/opencl/image/concat.cc:54:                   Tensor *output,
mace/ops/opencl/image/concat.cc:123:                   const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/concat.cc:124:                   Tensor *output,
mace/ops/opencl/image/concat.cc:154:    const Tensor *input = input_list[i];
mace/ops/opencl/image/concat.cc:213:    const std::vector<const Tensor *> &input_list,
mace/ops/opencl/image/concat.cc:215:    Tensor *output) {
mace/ops/opencl/image/concat.cc:218:  const Tensor *input0 = input_list[0];
mace/ops/opencl/image/concat.cc:222:    const Tensor *input = input_list[i];
mace/ops/opencl/matmul.h:24:class Tensor;
mace/ops/opencl/matmul.h:31:      const Tensor *A,
mace/ops/opencl/matmul.h:32:      const Tensor *B,
mace/ops/opencl/matmul.h:33:      Tensor *C,
mace/ops/opencl/buffer_transform_kernel.h:24:class Tensor;
mace/ops/opencl/buffer_transform_kernel.h:29:                             const Tensor *input,
mace/ops/opencl/buffer_transform_kernel.h:32:                             Tensor *output) = 0;
mace/ops/opencl/addn.h:26:class Tensor;
mace/ops/opencl/addn.h:34:      const std::vector<const Tensor *> &input_tensors,
mace/ops/opencl/addn.h:35:      Tensor *output_tensor) = 0;
mace/ops/opencl/buffer_transformer.cc:36:  Tensor *input = ws->GetTensor(input_name);
mace/ops/opencl/buffer_transformer.cc:39:  Tensor *output =
mace/ops/opencl/buffer_transformer.cc:40:      ws->CreateTensor(output_name, context->device()->allocator(), dt, true);
mace/ops/opencl/reduce.h:24:class Tensor;
mace/ops/opencl/reduce.h:31:      const Tensor *input,
mace/ops/opencl/reduce.h:32:      Tensor *output) = 0;
mace/ops/opencl/lstm_cell.h:24:class Tensor;
mace/ops/opencl/lstm_cell.h:31:      const Tensor *input,
mace/ops/opencl/lstm_cell.h:32:      const Tensor *pre_output,
mace/ops/opencl/lstm_cell.h:33:      const Tensor *weight,
mace/ops/opencl/lstm_cell.h:34:      const Tensor *bias,
mace/ops/opencl/lstm_cell.h:35:      const Tensor *pre_cell,
mace/ops/opencl/lstm_cell.h:36:      Tensor *cell,
mace/ops/opencl/lstm_cell.h:37:      Tensor *output) = 0;
mace/ops/opencl/pooling.h:26:class Tensor;
mace/ops/opencl/pooling.h:32:      const Tensor *input,
mace/ops/opencl/pooling.h:40:      Tensor *output) = 0;
mace/ops/opencl/sqrdiff_mean.h:23:class Tensor;
mace/ops/opencl/sqrdiff_mean.h:30:      const Tensor *input0,
mace/ops/opencl/sqrdiff_mean.h:31:      const Tensor *input1,
mace/ops/opencl/sqrdiff_mean.h:32:      Tensor *output) = 0;
mace/ops/opencl/conv_2d.h:40:      const Tensor *input,
mace/ops/opencl/conv_2d.h:41:      const Tensor *filter,
mace/ops/opencl/conv_2d.h:42:      const Tensor *bias,
mace/ops/opencl/conv_2d.h:51:      Tensor *output) = 0;
mace/ops/opencl/softmax.h:24:class Tensor;
mace/ops/opencl/softmax.h:31:      const Tensor *logits,
mace/ops/opencl/softmax.h:32:      Tensor *output) = 0;
mace/ops/opencl/concat.h:26:class Tensor;
mace/ops/opencl/concat.h:33:      const std::vector<const Tensor *> &input_list,
mace/ops/opencl/concat.h:35:      Tensor *output) = 0;
mace/ops/opencl/channel_shuffle.h:24:class Tensor;
mace/ops/opencl/channel_shuffle.h:31:      const Tensor *input,
mace/ops/opencl/channel_shuffle.h:32:      Tensor *output) = 0;
mace/ops/opencl/crop.h:26:class Tensor;
mace/ops/opencl/crop.h:33:      const std::vector<const Tensor *> &input_list,
mace/ops/opencl/crop.h:34:      Tensor *output) = 0;
mace/ops/opencl/space_to_depth.h:24:class Tensor;
mace/ops/opencl/space_to_depth.h:31:      const Tensor *input,
mace/ops/opencl/space_to_depth.h:32:      Tensor *output) = 0;
mace/ops/opencl/space_to_batch.h:27:class Tensor;
mace/ops/opencl/space_to_batch.h:34:      const Tensor *space_tensor,
mace/ops/opencl/space_to_batch.h:38:      Tensor *batch_tensor) = 0;
mace/ops/opencl/resize_nearest_neighbor.h:25:class Tensor;
mace/ops/opencl/resize_nearest_neighbor.h:32:      const Tensor *input,
mace/ops/opencl/resize_nearest_neighbor.h:33:      const Tensor *size,
mace/ops/opencl/resize_nearest_neighbor.h:34:      Tensor *output) = 0;
mace/ops/opencl/bias_add.h:24:class Tensor;
mace/ops/opencl/bias_add.h:31:      const Tensor *input,
mace/ops/opencl/bias_add.h:32:      const Tensor *bias,
mace/ops/opencl/bias_add.h:33:      Tensor *output) = 0;
mace/ops/opencl/fully_connected.h:25:class Tensor;
mace/ops/opencl/fully_connected.h:32:      const Tensor *input,
mace/ops/opencl/fully_connected.h:33:      const Tensor *weight,
mace/ops/opencl/fully_connected.h:34:      const Tensor *bias,
mace/ops/opencl/fully_connected.h:38:      Tensor *output) = 0;
mace/ops/opencl/activation.h:24:class Tensor;
mace/ops/opencl/activation.h:31:      const Tensor *input,
mace/ops/opencl/activation.h:32:      const Tensor *alpha,
mace/ops/opencl/activation.h:33:      Tensor *output) = 0;
mace/ops/opencl/deconv_2d.h:28:class Tensor;
mace/ops/opencl/deconv_2d.h:35:      const Tensor *input,
mace/ops/opencl/deconv_2d.h:36:      const Tensor *filter,
mace/ops/opencl/deconv_2d.h:37:      const Tensor *bias,
mace/ops/opencl/deconv_2d.h:44:      Tensor *output) = 0;
mace/ops/opencl/pad.h:23:class Tensor;
mace/ops/opencl/pad.h:30:      const Tensor *input,
mace/ops/opencl/pad.h:31:      Tensor *output) = 0;
mace/ops/opencl/buffer_transform.cc:36:    const Tensor *input = this->Input(0);
mace/ops/opencl/buffer_transform.cc:37:    Tensor *output = this->Output(0);
mace/ops/opencl/buffer_transform.cc:43:    MemoryType in_mem_type = context->workspace()->GetTensor(
mace/ops/opencl/buffer_transformer.h:45:                       const Tensor *input,
mace/ops/opencl/buffer_transformer.h:49:                       Tensor *output) {
mace/ops/opencl/buffer_transformer.h:61:        Tensor *internal_tensor = ws->CreateTensor(
mace/ops/opencl/buffer_transformer.h:69:        Tensor::MappingGuard guard(internal_tensor);
mace/ops/opencl/buffer_transformer.h:78:      Tensor internal_tensor(context->device()->allocator(),
mace/ops/opencl/buffer_transformer.h:88:      Tensor::MappingGuard guard(&internal_tensor);
mace/ops/opencl/resize_bilinear.h:25:class Tensor;
mace/ops/opencl/resize_bilinear.h:32:      const Tensor *input,
mace/ops/opencl/resize_bilinear.h:33:      Tensor *output) = 0;
mace/ops/opencl/batch_norm.h:24:class Tensor;
mace/ops/opencl/batch_norm.h:31:      const Tensor *input,
mace/ops/opencl/batch_norm.h:32:      const Tensor *scale,
mace/ops/opencl/batch_norm.h:33:      const Tensor *offset,
mace/ops/opencl/batch_norm.h:34:      const Tensor *mean,
mace/ops/opencl/batch_norm.h:35:      const Tensor *var,
mace/ops/opencl/batch_norm.h:36:      Tensor *output) = 0;
mace/ops/opencl/resize_bicubic.h:25:class Tensor;
mace/ops/opencl/resize_bicubic.h:32:      const Tensor *input,
mace/ops/opencl/resize_bicubic.h:33:      Tensor *output) = 0;
mace/ops/opencl/depth_to_space.h:23:class Tensor;
mace/ops/opencl/depth_to_space.h:31:      const Tensor *input,
mace/ops/opencl/depth_to_space.h:32:      Tensor *output) = 0;
mace/ops/opencl/eltwise.h:24:class Tensor;
mace/ops/opencl/eltwise.h:31:      const Tensor *input0,
mace/ops/opencl/eltwise.h:32:      const Tensor *input1,
mace/ops/opencl/eltwise.h:33:      Tensor *output) = 0;
mace/ops/opencl/depthwise_conv2d.h:32:      const Tensor *input,
mace/ops/opencl/depthwise_conv2d.h:33:      const Tensor *filter,
mace/ops/opencl/depthwise_conv2d.h:34:      const Tensor *bias,
mace/ops/opencl/depthwise_conv2d.h:42:      Tensor *output) = 0;
mace/ops/opencl/depthwise_deconv2d.h:29:class Tensor;
mace/ops/opencl/depthwise_deconv2d.h:37:      const Tensor *input,
mace/ops/opencl/depthwise_deconv2d.h:38:      const Tensor *filter,
mace/ops/opencl/depthwise_deconv2d.h:39:      const Tensor *bias,
mace/ops/opencl/depthwise_deconv2d.h:47:      Tensor *output) = 0;
mace/ops/opencl/split.h:26:class Tensor;
mace/ops/opencl/split.h:33:      const Tensor *input,
mace/ops/opencl/split.h:34:      const std::vector<Tensor *> &output_list) = 0;
mace/ops/sqrdiff_mean.cc:35:    const Tensor *input0 = this->Input(0);
mace/ops/sqrdiff_mean.cc:36:    const Tensor *input1 = this->Input(1);
mace/ops/sqrdiff_mean.cc:37:    Tensor *output = this->Output(0);
mace/ops/sqrdiff_mean.cc:55:  void Compute(const Tensor *input0,
mace/ops/sqrdiff_mean.cc:56:               const Tensor *input1,
mace/ops/sqrdiff_mean.cc:57:               Tensor *output) {
mace/ops/sqrdiff_mean.cc:58:    Tensor::MappingGuard input0_mapper(input0);
mace/ops/sqrdiff_mean.cc:59:    Tensor::MappingGuard input1_mapper(input1);
mace/ops/sqrdiff_mean.cc:62:    Tensor::MappingGuard output_map(output);
mace/ops/sqrdiff_mean.cc:92:    const Tensor *input0 = this->Input(0);
mace/ops/sqrdiff_mean.cc:93:    const Tensor *input1 = this->Input(1);
mace/ops/sqrdiff_mean.cc:94:    Tensor *output = this->Output(0);
mace/ops/stack.cc:32:    const std::vector<const Tensor *> &inputs = this->Inputs();
mace/ops/stack.cc:33:    Tensor *output = this->Output(0);
mace/ops/stack.cc:47:    std::vector<Tensor::MappingGuard> mappers;
mace/ops/stack.cc:49:      mappers.emplace_back(Tensor::MappingGuard(inputs[i]));
mace/ops/stack.cc:53:    Tensor::MappingGuard output_guard(output);
mace/ops/argmax.cc:37:    const Tensor *input = this->Input(0);
mace/ops/argmax.cc:38:    const Tensor *axis = this->InputSize() == 2 ?
mace/ops/argmax.cc:40:    Tensor *output = this->Output(0);
mace/ops/argmax.cc:48:      Tensor::MappingGuard axis_guard(axis);
mace/ops/argmax.cc:65:    Tensor::MappingGuard input_guard(input);
mace/ops/argmax.cc:66:    Tensor::MappingGuard output_guard(output);
mace/ops/addn.cc:43:    Tensor *output = this->Output(0);
mace/ops/addn.cc:47:    Tensor::MappingGuard output_guard(output);
mace/ops/addn.cc:52:      Tensor::MappingGuard input_guard(input);
mace/ops/addn.cc:77:    Tensor *output_tensor = this->Output(0);
mace/ops/squeeze.cc:48:    const Tensor *input = this->Input(0);
mace/ops/squeeze.cc:49:    Tensor *output = this->Output(0);
mace/ops/squeeze.cc:59:    output->ReuseTensorBuffer(*input);
mace/ops/sum_group.cc:41:    const Tensor *input = this->Input(0);
mace/ops/sum_group.cc:45:    const Tensor *sizes = this->Input(1);
mace/ops/sum_group.cc:46:    Tensor *output = this->Output(0);
mace/ops/sum_group.cc:63:    Tensor::MappingGuard guard_input(input);
mace/ops/sum_group.cc:64:    Tensor::MappingGuard guard_sizes(sizes);
mace/ops/sum_group.cc:65:    Tensor::MappingGuard guard_output(output);
mace/ops/fill.cc:32:    const Tensor *shape = this->Input(SHAPE);
mace/ops/fill.cc:33:    const Tensor *value = this->Input(VALUE);
mace/ops/fill.cc:34:    Tensor *output = this->Output(OUTPUT);
mace/ops/fill.cc:37:    Tensor::MappingGuard shape_guard(shape);
mace/ops/fill.cc:47:    Tensor::MappingGuard value_guard(value);
mace/ops/fill.cc:51:    Tensor::MappingGuard output_guard(output);
mace/ops/gather.cc:31:    const Tensor *params = this->Input(PARAMS);
mace/ops/gather.cc:32:    const Tensor *indices = this->Input(INDICES);
mace/ops/gather.cc:33:    Tensor *output = this->Output(OUTPUT);
mace/ops/gather.cc:49:    Tensor::MappingGuard indices_guard(indices);
mace/ops/gather.cc:50:    Tensor::MappingGuard params_guard(params);
mace/ops/gather.cc:51:    Tensor::MappingGuard output_guard(output);
mace/ops/softmax.cc:51:    const Tensor *input = this->Input(INPUT);
mace/ops/softmax.cc:52:    Tensor *output = this->Output(OUTPUT);
mace/ops/softmax.cc:54:    Tensor::MappingGuard input_guard(input);
mace/ops/softmax.cc:55:    Tensor::MappingGuard output_guard(output);
mace/ops/softmax.cc:72:    const Tensor *input = this->Input(INPUT);
mace/ops/softmax.cc:74:    Tensor *output = this->Output(OUTPUT);
mace/ops/softmax.cc:178:    const Tensor *input = this->Input(INPUT);
mace/ops/softmax.cc:179:    Tensor *output = this->Output(OUTPUT);
mace/ops/softmax.cc:237:  inline bool isNCHW(const Tensor *input) {
mace/ops/softmax.cc:258:    const Tensor *input = this->Input(INPUT);
mace/ops/softmax.cc:259:    Tensor *output = this->Output(OUTPUT);
mace/ops/softmax.cc:286:    Tensor::MappingGuard input_guard(input);
mace/ops/softmax.cc:287:    Tensor::MappingGuard output_guard(output);
mace/ops/softmax.cc:508:    const Tensor *input = this->Input(INPUT);
mace/ops/softmax.cc:509:    Tensor *output = this->Output(OUTPUT);
mace/ops/space_to_batch.cc:44:  void CalculateSpaceToBatchOutputShape(const Tensor *input_tensor,
mace/ops/space_to_batch.cc:100:    const Tensor *space_tensor = this->Input(0);
mace/ops/space_to_batch.cc:101:    Tensor *batch_tensor = this->Output(0);
mace/ops/space_to_batch.cc:109:    Tensor::MappingGuard input_guard(space_tensor);
mace/ops/space_to_batch.cc:110:    Tensor::MappingGuard output_guard(batch_tensor);
mace/ops/space_to_batch.cc:209:    const Tensor *space_tensor = this->Input(0);
mace/ops/space_to_batch.cc:210:    Tensor *batch_tensor = this->Output(0);
mace/ops/space_to_batch.cc:219:    Tensor::MappingGuard input_guard(space_tensor);
mace/ops/space_to_batch.cc:220:    Tensor::MappingGuard output_guard(batch_tensor);
mace/ops/space_to_batch.cc:317:    const Tensor *space_tensor = this->Input(0);
mace/ops/space_to_batch.cc:318:    Tensor *batch_tensor = this->Output(0);
mace/ops/lstm_nonlinear.cc:38:    const Tensor *input = this->Input(INPUT);
mace/ops/lstm_nonlinear.cc:41:    const Tensor *params = this->Input(PARAMS);
mace/ops/lstm_nonlinear.cc:42:    Tensor *output = this->Output(OUTPUT);
mace/ops/lstm_nonlinear.cc:69:    Tensor::MappingGuard input_guard(input);
mace/ops/lstm_nonlinear.cc:70:    Tensor::MappingGuard params_guard(params);
mace/ops/lstm_nonlinear.cc:71:    Tensor::MappingGuard output_guard(output);
mace/ops/ref/bias_add.cc:22:                            const Tensor *input,
mace/ops/ref/bias_add.cc:23:                            const Tensor *bias,
mace/ops/ref/bias_add.cc:24:                            Tensor *output) {
mace/ops/ref/bias_add.cc:25:  Tensor::MappingGuard input_guard(input);
mace/ops/ref/bias_add.cc:26:  Tensor::MappingGuard bias_guard(bias);
mace/ops/ref/bias_add.cc:32:      Tensor::MappingGuard output_guard(output);
mace/ops/ref/bias_add.cc:45:                      const Tensor *input,
mace/ops/ref/bias_add.cc:46:                      const Tensor *bias,
mace/ops/ref/bias_add.cc:47:                      mace::Tensor *output) {
mace/ops/ref/conv_2d.cc:25:                                  const Tensor *input,
mace/ops/ref/conv_2d.cc:26:                                  const Tensor *filter,
mace/ops/ref/conv_2d.cc:27:                                  Tensor *output) {
mace/ops/ref/conv_2d.cc:62:  Tensor::MappingGuard input_guard(input);
mace/ops/ref/conv_2d.cc:63:  Tensor::MappingGuard filter_guard(filter);
mace/ops/ref/conv_2d.cc:64:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/gemm.cc:23:                                const Tensor *lhs,
mace/ops/ref/gemm.cc:24:                                const Tensor *rhs,
mace/ops/ref/gemm.cc:34:                                Tensor *output) {
mace/ops/ref/gemm.cc:37:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/ref/gemm.cc:38:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/ref/gemm.cc:39:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/gemm.cc:76:                                const Tensor *lhs,
mace/ops/ref/gemm.cc:77:                                const Tensor *rhs,
mace/ops/ref/gemm.cc:88:                                Tensor *output) {
mace/ops/ref/depthwise_conv_2d.cc:25:                                           const Tensor *input,
mace/ops/ref/depthwise_conv_2d.cc:26:                                           const Tensor *filter,
mace/ops/ref/depthwise_conv_2d.cc:27:                                           Tensor *output) {
mace/ops/ref/depthwise_conv_2d.cc:65:  Tensor::MappingGuard input_guard(input);
mace/ops/ref/depthwise_conv_2d.cc:66:  Tensor::MappingGuard filter_guard(filter);
mace/ops/ref/depthwise_conv_2d.cc:67:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/deconv_2d.cc:27:                                    const Tensor *input,
mace/ops/ref/deconv_2d.cc:28:                                    const Tensor *filter,
mace/ops/ref/deconv_2d.cc:29:                                    const Tensor *output_shape,
mace/ops/ref/deconv_2d.cc:30:                                    Tensor *output) {
mace/ops/ref/deconv_2d.cc:35:    Tensor::MappingGuard out_shape_guard(output_shape);
mace/ops/ref/deconv_2d.cc:62:  std::unique_ptr<Tensor> padded_output(nullptr);
mace/ops/ref/deconv_2d.cc:74:    std::unique_ptr<Tensor>
mace/ops/ref/deconv_2d.cc:76:        (make_unique<Tensor>(scratch->Scratch(scratch_size), DT_FLOAT));
mace/ops/ref/deconv_2d.cc:80:  Tensor *out_tensor = output;
mace/ops/ref/deconv_2d.cc:87:  Tensor::MappingGuard input_mapper(input);
mace/ops/ref/deconv_2d.cc:88:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/ref/deconv_2d.cc:89:  Tensor::MappingGuard output_mapper(output);
mace/ops/ref/conv_2d.h:44:      const Tensor *input,
mace/ops/ref/conv_2d.h:45:      const Tensor *filter,
mace/ops/ref/conv_2d.h:46:      Tensor *output);
mace/ops/ref/conv_2d.h:70:      const Tensor *input,
mace/ops/ref/conv_2d.h:71:      const Tensor *filter,
mace/ops/ref/conv_2d.h:72:      Tensor *output);
mace/ops/ref/gemv.h:35:    const Tensor *lhs,
mace/ops/ref/gemv.h:36:    const Tensor *rhs,
mace/ops/ref/gemv.h:37:    const Tensor *bias,
mace/ops/ref/gemv.h:43:    Tensor *output);
mace/ops/ref/gemv.h:54:    const Tensor *lhs,
mace/ops/ref/gemv.h:55:    const Tensor *rhs,
mace/ops/ref/gemv.h:56:    const Tensor *bias,
mace/ops/ref/gemv.h:62:    Tensor *output);
mace/ops/ref/gemv.h:74:      const Tensor *lhs,
mace/ops/ref/gemv.h:75:      const Tensor *rhs,
mace/ops/ref/gemv.h:76:      const Tensor *bias,
mace/ops/ref/gemv.h:82:      Tensor *output);
mace/ops/ref/gemv.h:93:      const Tensor *lhs,
mace/ops/ref/gemv.h:94:      const Tensor *rhs,
mace/ops/ref/gemv.h:95:      const Tensor *bias,
mace/ops/ref/gemv.h:101:      Tensor *output);
mace/ops/ref/depthwise_deconv_2d.h:50:      const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.h:51:      const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.h:52:      const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.h:53:      Tensor *output);
mace/ops/ref/depthwise_deconv_2d.h:83:      const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.h:84:      const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.h:85:      const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.h:86:      Tensor *output);
mace/ops/ref/depthwise_deconv_2d.h:109:      const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.h:110:      const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.h:111:      const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.h:112:      Tensor *output);
mace/ops/ref/depthwise_deconv_2d.h:142:      const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.h:143:      const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.h:144:      const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.h:145:      Tensor *output);
mace/ops/ref/bias_add.h:31:      const Tensor *input,
mace/ops/ref/bias_add.h:32:      const Tensor *bias,
mace/ops/ref/bias_add.h:33:      Tensor *output);
mace/ops/ref/bias_add.h:37:               const Tensor *input,
mace/ops/ref/bias_add.h:38:               const Tensor *bias,
mace/ops/ref/bias_add.h:39:               Tensor *output);
mace/ops/ref/activation.cc:30:                               const Tensor *input,
mace/ops/ref/activation.cc:31:                               Tensor *output) {
mace/ops/ref/activation.cc:32:  Tensor::MappingGuard input_guard(input);
mace/ops/ref/activation.cc:35:    Tensor::MappingGuard output_guard(output);
mace/ops/ref/activation.cc:45:                              const Tensor *input,
mace/ops/ref/activation.cc:46:                              Tensor *output) {
mace/ops/ref/activation.h:34:      const Tensor *input,
mace/ops/ref/activation.h:35:      Tensor *output);
mace/ops/ref/activation.h:39:                    const Tensor *input,
mace/ops/ref/activation.h:40:                    Tensor *output);
mace/ops/ref/deconv_2d.h:48:      const Tensor *input,
mace/ops/ref/deconv_2d.h:49:      const Tensor *filter,
mace/ops/ref/deconv_2d.h:50:      const Tensor *output_shape,
mace/ops/ref/deconv_2d.h:51:      Tensor *output);
mace/ops/ref/deconv_2d.h:79:      const Tensor *input,
mace/ops/ref/deconv_2d.h:80:      const Tensor *filter,
mace/ops/ref/deconv_2d.h:81:      const Tensor *output_shape,
mace/ops/ref/deconv_2d.h:82:      Tensor *output);
mace/ops/ref/gemv.cc:27:                                const Tensor *lhs,
mace/ops/ref/gemv.cc:28:                                const Tensor *rhs,
mace/ops/ref/gemv.cc:29:                                const Tensor *bias,
mace/ops/ref/gemv.cc:35:                                Tensor *output) {
mace/ops/ref/gemv.cc:38:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/ref/gemv.cc:39:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/ref/gemv.cc:40:  Tensor::MappingGuard bias_guard(bias);
mace/ops/ref/gemv.cc:41:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/gemv.cc:70:                                  const Tensor *lhs,
mace/ops/ref/gemv.cc:71:                                  const Tensor *rhs,
mace/ops/ref/gemv.cc:72:                                  const Tensor *bias,
mace/ops/ref/gemv.cc:78:                                  Tensor *output) {
mace/ops/ref/gemv.cc:81:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/ref/gemv.cc:82:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/ref/gemv.cc:83:  Tensor::MappingGuard bias_guard(bias);
mace/ops/ref/gemv.cc:84:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/gemv.cc:119:                                  const Tensor *lhs,
mace/ops/ref/gemv.cc:120:                                  const Tensor *rhs,
mace/ops/ref/gemv.cc:121:                                  const Tensor *bias,
mace/ops/ref/gemv.cc:127:                                  Tensor *output) {
mace/ops/ref/gemv.cc:130:  Tensor::MappingGuard lhs_guard(lhs);
mace/ops/ref/gemv.cc:131:  Tensor::MappingGuard rhs_guard(rhs);
mace/ops/ref/gemv.cc:132:  Tensor::MappingGuard bias_guard(bias);
mace/ops/ref/gemv.cc:133:  Tensor::MappingGuard output_guard(output);
mace/ops/ref/depthwise_conv_2d.h:44:      const Tensor *input,
mace/ops/ref/depthwise_conv_2d.h:45:      const Tensor *filter,
mace/ops/ref/depthwise_conv_2d.h:46:      Tensor *output);
mace/ops/ref/depthwise_conv_2d.h:70:      const Tensor *input,
mace/ops/ref/depthwise_conv_2d.h:71:      const Tensor *filter,
mace/ops/ref/depthwise_conv_2d.h:72:      Tensor *output);
mace/ops/ref/depthwise_deconv_2d.cc:26:                                             const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.cc:27:                                             const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.cc:28:                                             const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.cc:29:                                             Tensor *output) {
mace/ops/ref/depthwise_deconv_2d.cc:34:    Tensor::MappingGuard out_shape_guard(output_shape);
mace/ops/ref/depthwise_deconv_2d.cc:61:  std::unique_ptr<Tensor> padded_output(nullptr);
mace/ops/ref/depthwise_deconv_2d.cc:73:    std::unique_ptr<Tensor>
mace/ops/ref/depthwise_deconv_2d.cc:75:        (make_unique<Tensor>(scratch->Scratch(scratch_size), DT_FLOAT));
mace/ops/ref/depthwise_deconv_2d.cc:79:  Tensor *out_tensor = output;
mace/ops/ref/depthwise_deconv_2d.cc:86:  Tensor::MappingGuard input_mapper(input);
mace/ops/ref/depthwise_deconv_2d.cc:87:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/ref/depthwise_deconv_2d.cc:88:  Tensor::MappingGuard output_mapper(output);
mace/ops/ref/depthwise_deconv_2d.cc:161:                                         const Tensor *input,
mace/ops/ref/depthwise_deconv_2d.cc:162:                                         const Tensor *filter,
mace/ops/ref/depthwise_deconv_2d.cc:163:                                         const Tensor *output_shape,
mace/ops/ref/depthwise_deconv_2d.cc:164:                                         Tensor *output) {
mace/ops/ref/depthwise_deconv_2d.cc:169:    Tensor::MappingGuard out_shape_guard(output_shape);
mace/ops/ref/depthwise_deconv_2d.cc:196:  std::unique_ptr<Tensor> padded_output(nullptr);
mace/ops/ref/depthwise_deconv_2d.cc:208:    std::unique_ptr<Tensor>
mace/ops/ref/depthwise_deconv_2d.cc:210:        (make_unique<Tensor>(scratch->Scratch(scratch_size), DT_FLOAT));
mace/ops/ref/depthwise_deconv_2d.cc:214:  Tensor *out_tensor = output;
mace/ops/ref/depthwise_deconv_2d.cc:221:  Tensor::MappingGuard input_mapper(input);
mace/ops/ref/depthwise_deconv_2d.cc:222:  Tensor::MappingGuard filter_mapper(filter);
mace/ops/ref/depthwise_deconv_2d.cc:223:  Tensor::MappingGuard output_mapper(output);
mace/ops/ref/gemm.h:34:                     const Tensor *lhs,
mace/ops/ref/gemm.h:35:                     const Tensor *rhs,
mace/ops/ref/gemm.h:45:                     Tensor *output);
mace/ops/ref/gemm.h:54:                     const Tensor *lhs,
mace/ops/ref/gemm.h:55:                     const Tensor *rhs,
mace/ops/ref/gemm.h:65:                     Tensor *output);
mace/ops/ref/gemm.h:69:      const Tensor *lhs,
mace/ops/ref/gemm.h:70:      const Tensor *rhs,
mace/ops/ref/gemm.h:81:      Tensor *output);
mace/ops/dynamic_lstm.cc:112:    const Tensor *input = this->Input(INPUT);
mace/ops/dynamic_lstm.cc:113:    const Tensor *weights_a = this->Input(WEIGHTS_A);
mace/ops/dynamic_lstm.cc:114:    const Tensor *lstm_params = this->Input(PARAMS);
mace/ops/dynamic_lstm.cc:115:    const Tensor *weights_b = this->Input(WEIGHTS_B);
mace/ops/dynamic_lstm.cc:121:    const Tensor *bias_a = has_bias_a_ ?
mace/ops/dynamic_lstm.cc:129:    const Tensor *bias_b = has_bias_b_ ?
mace/ops/dynamic_lstm.cc:190:    Tensor prev_out(scratch->Scratch(out_buf_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:194:    Tensor prev_cell(scratch->Scratch(cell_buf_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:198:    Tensor affine_a_in(scratch->Scratch(affine_a_in_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:202:    Tensor affine_a_out(scratch->Scratch(affine_a_out_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:206:    Tensor affine_b_in(scratch->Scratch(affine_b_in_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:210:    Tensor affine_b_out(scratch->Scratch(affine_b_out_size), DT_FLOAT);
mace/ops/dynamic_lstm.cc:214:    Tensor *output = this->Output(OUTPUT);
mace/ops/dynamic_lstm.cc:221:    Tensor::MappingGuard input_guard(input);
mace/ops/dynamic_lstm.cc:222:    Tensor::MappingGuard lstm_params_guard(lstm_params);
mace/ops/dynamic_lstm.cc:223:    Tensor::MappingGuard output_guard(output);
mace/ops/resize_nearest_neighbor.cc:85:    const Tensor *input = this->Input(0);
mace/ops/resize_nearest_neighbor.cc:86:    const Tensor *size = this->Input(1);
mace/ops/resize_nearest_neighbor.cc:87:    Tensor::MappingGuard size_mapper(size);
mace/ops/resize_nearest_neighbor.cc:88:    Tensor *output = this->Output(0);
mace/ops/resize_nearest_neighbor.cc:104:    Tensor::MappingGuard input_mapper(input);
mace/ops/resize_nearest_neighbor.cc:105:    Tensor::MappingGuard output_mapper(output);
mace/ops/resize_nearest_neighbor.cc:159:    const Tensor *input = this->Input(0);
mace/ops/resize_nearest_neighbor.cc:160:    const Tensor *size = this->Input(1);
mace/ops/resize_nearest_neighbor.cc:161:    Tensor *output = this->Output(0);
mace/ops/extract_pooling.cc:63:    const Tensor *input = this->Input(0);
mace/ops/extract_pooling.cc:64:    Tensor *output = this->Output(0);
mace/ops/extract_pooling.cc:106:    Tensor extract_out(scratch->Scratch(extract_out_size), DT_FLOAT);
mace/ops/extract_pooling.cc:111:    Tensor::MappingGuard guard_input(input);
mace/ops/extract_pooling.cc:112:    Tensor::MappingGuard guard_output(output);
mace/ops/pooling.cc:70:    const Tensor *input_tensor = this->Input(0);
mace/ops/pooling.cc:71:    Tensor *output_tensor = this->Output(0);
mace/ops/pooling.cc:93:    Tensor::MappingGuard input_guard(input_tensor);
mace/ops/pooling.cc:94:    Tensor::MappingGuard output_guard(output_tensor);
mace/ops/pooling.cc:257:    const Tensor *input_tensor = this->Input(0);
mace/ops/pooling.cc:258:    Tensor *output_tensor = this->Output(0);
mace/ops/pooling.cc:298:    Tensor::MappingGuard input_guard(input_tensor);
mace/ops/pooling.cc:299:    Tensor::MappingGuard output_guard(output_tensor);
mace/ops/pooling.cc:500:    const Tensor *input = this->Input(0);
mace/ops/pooling.cc:501:    Tensor *output = this->Output(0);
mace/ops/prior_box.cc:40:    const Tensor *input = this->Input(INPUT);
mace/ops/prior_box.cc:41:    const Tensor *data = this->Input(DATA);
mace/ops/prior_box.cc:42:    Tensor *output = this->Output(OUTPUT);
mace/ops/prior_box.cc:73:    Tensor::MappingGuard output_guard(output);
mace/ops/reshape.cc:32:    const Tensor *input = this->Input(INPUT);
mace/ops/reshape.cc:33:    const Tensor *shape = this->Input(SHAPE);
mace/ops/reshape.cc:35:    Tensor::MappingGuard shape_guard(shape);
mace/ops/reshape.cc:71:    Tensor *output = this->Output(OUTPUT);
mace/ops/reshape.cc:82:    output->ReuseTensorBuffer(*input);
mace/ops/eltwise.cc:67:inline void TensorGeneralBroadcastEltwise(
mace/ops/eltwise.cc:219:inline void TensorBroadcastEltwise(const OpContext *context,
mace/ops/eltwise.cc:395:inline void TensorEltwise(const OpContext *context,
mace/ops/eltwise.cc:521:inline void TensorScalarEltwise(const OpContext *context,
mace/ops/eltwise.cc:646:inline void TensorEltwisePerChannel(const OpContext *context,
mace/ops/eltwise.cc:896:    const Tensor *input0 = this->Input(0);
mace/ops/eltwise.cc:897:    const Tensor *input1 = this->InputSize() == 2 ? this->Input(1) : nullptr;
mace/ops/eltwise.cc:898:    Tensor *output = this->Output(0);
mace/ops/eltwise.cc:901:      Tensor::MappingGuard guard(&scalar_tensor_);
mace/ops/eltwise.cc:923:                       const Tensor *input0,
mace/ops/eltwise.cc:924:                       const Tensor *input1,
mace/ops/eltwise.cc:925:                       Tensor *output) {
mace/ops/eltwise.cc:959:    Tensor::MappingGuard input0_guard(input0);
mace/ops/eltwise.cc:960:    Tensor::MappingGuard input1_guard(input1);
mace/ops/eltwise.cc:967:      Tensor::MappingGuard output_guard(output);
mace/ops/eltwise.cc:970:        TensorEltwisePerChannel(context,
mace/ops/eltwise.cc:982:        TensorEltwise(context,
mace/ops/eltwise.cc:997:      Tensor::MappingGuard output_guard(output);
mace/ops/eltwise.cc:1010:        TensorScalarEltwise(context,
mace/ops/eltwise.cc:1014:        TensorEltwise(context,
mace/ops/eltwise.cc:1018:        TensorGeneralBroadcastEltwise(context,
mace/ops/eltwise.cc:1025:        TensorBroadcastEltwise(context,
mace/ops/eltwise.cc:1040:  Tensor scalar_tensor_;
mace/ops/eltwise.cc:1063:    const Tensor *input0 = this->Input(0);
mace/ops/eltwise.cc:1066:    const Tensor *input1 = this->Input(1);
mace/ops/eltwise.cc:1067:    Tensor *output = this->Output(0);
mace/ops/eltwise.cc:1101:    Tensor::MappingGuard input0_guard(input0);
mace/ops/eltwise.cc:1102:    Tensor::MappingGuard input1_guard(input1);
mace/ops/eltwise.cc:1103:    Tensor::MappingGuard output_guard(output);
mace/ops/eltwise.cc:1153:  Tensor scalar_tensor_;
mace/ops/eltwise.cc:1190:      if (ws->HasTensor(operator_def_->input(i)) &&
mace/ops/eltwise.cc:1191:          ws->GetTensor(operator_def_->input(i))->is_weight()) {
mace/ops/eltwise.cc:1192:        if (ws->GetTensor(operator_def_->input(i))->dim_size() == 1) {
mace/ops/eltwise.cc:1199:        } else if (ws->GetTensor(operator_def_->input(i))->dim_size() == 4) {
mace/ops/eltwise.cc:1216:    const Tensor *input0 = this->Input(0);
mace/ops/eltwise.cc:1217:    const Tensor *input1 = this->InputSize() == 2 ? this->Input(1) : nullptr;
mace/ops/eltwise.cc:1218:    Tensor *output = this->Output(0);
mace/ops/concat.cc:68:    const std::vector<const Tensor *> &inputs = this->Inputs();
mace/ops/concat.cc:69:    Tensor *output = this->Output(0);
mace/ops/concat.cc:70:    const Tensor *input0 = inputs.front();
mace/ops/concat.cc:81:      const Tensor *input = inputs[i];
mace/ops/concat.cc:97:    Tensor::MappingGuard output_guard(output);
mace/ops/concat.cc:98:    std::vector<Tensor::MappingGuard> mappers;
mace/ops/concat.cc:101:      mappers.emplace_back(Tensor::MappingGuard(inputs[i]));
mace/ops/concat.cc:140:    const std::vector<const Tensor *> &inputs = this->Inputs();
mace/ops/concat.cc:141:    Tensor *output = this->Output(0);
mace/ops/concat.cc:143:    const Tensor *input0 = inputs.front();
mace/ops/concat.cc:154:      const Tensor *input = inputs[i];
mace/ops/concat.cc:215:    Tensor *output = this->Output(0);
examples/android/macelibrary/src/main/cpp/image_classify.cc:207:  std::map<std::string, mace::MaceTensor> inputs;
examples/android/macelibrary/src/main/cpp/image_classify.cc:208:  std::map<std::string, mace::MaceTensor> outputs;
examples/android/macelibrary/src/main/cpp/image_classify.cc:214:  inputs[input_name] = mace::MaceTensor(input_shape, buffer_in);
examples/android/macelibrary/src/main/cpp/image_classify.cc:219:  outputs[output_name] = mace::MaceTensor(output_shape, buffer_out);
tools/validate.py:304:                                               onnx.TensorProto.FLOAT,
tools/validate.py:383:        "--platform", type=str, default="", help="TensorFlow or Caffe.")
tools/validate.py:388:        help="TensorFlow or Caffe \'GraphDef\' file to load.")
匹配到二进制文件 tools/validate.pyc
tools/python/transform/onnx_converter.py:39:from onnx import mapping, numpy_helper, TensorProto
tools/python/transform/onnx_converter.py:235:        onnx_dtype = TensorProto.DataType.Value(dtype)
tools/python/transform/onnx_converter.py:266:class OnnxTensor(object):
tools/python/transform/onnx_converter.py:664:            if dtype == TensorProto.FLOAT:
tools/python/transform/onnx_converter.py:666:            elif dtype == TensorProto.INT:
tools/python/transform/tensorflow_converter.py:143:class TensorflowConverter(base_converter.ConverterInterface):
tools/python/transform/tensorflow_converter.py:359:                        tensor_shape_pb2.TensorShapeProto.Dim(size=i) for i in
tools/python/transform/transformer.py:1257:            # work for TensorFlow
tools/python/convert.py:244:        converter = tensorflow_converter.TensorflowConverter(
tools/python/convert.py:303:            raise Exception('Tensor data type %s not supported' %
tools/python/quantize/quantize_stat.py:35:                if line.find("Tensor range @@") != -1:
tools/python/template/model.jinja2:29:extern void CreateTensor{{ i }}(mace::ConstTensor *tensor);
tools/python/template/model.jinja2:124:void CreateTensors(NetDef *net_def) {
tools/python/template/model.jinja2:129:  mace::{{tag}}::CreateTensor{{ i }}(net_def->add_tensors());
tools/python/template/model.jinja2:142:  CreateTensors(net_def.get());
tools/python/template/tensor_source.jinja2:25:void CreateTensor{{tensor_id}}(mace::ConstTensor *const_tensor) {
匹配到二进制文件 tools/python/convert.pyc
tools/python/visualize/index.html:31:<h2>Tensors</h2>
test/ccunit/mace/libmace/mace_api_test.h:33:                           std::map<std::string, mace::MaceTensor> *inputs) {
test/ccunit/mace/libmace/mace_api_test.h:46:    (*inputs)[input_names[i]] = mace::MaceTensor(input_shape, buffer_in);
test/ccunit/mace/libmace/mace_api_test.h:52:                            std::map<std::string, mace::MaceTensor> *outputs) {
test/ccunit/mace/libmace/mace_api_test.h:60:    (*outputs)[output_names[i]] = mace::MaceTensor(output_shape, buffer_out);
test/ccunit/mace/libmace/mace_api_test.h:109:void AddTensor(const std::string &name,
test/ccunit/mace/libmace/mace_api_test.h:114:  ConstTensor *tensor_ptr = net_def->add_tensors();
test/ccunit/mace/libmace/mace_api_test.h:127:                  const std::map<std::string, mace::MaceTensor> &inputs,
test/ccunit/mace/libmace/mace_api_test.h:128:                  const std::map<std::string, mace::MaceTensor> &outputs,
test/ccunit/mace/libmace/mace_api_test.h:164:    std::unique_ptr<Tensor> tmp_tensor(
test/ccunit/mace/libmace/mace_api_test.h:165:        new Tensor(allocator.get(),
test/ccunit/mace/libmace/mace_api_test.h:183:    ops::test::ExpectTensorNear<float>(*tmp_tensor,
test/ccunit/mace/libmace/mace_api_test.cc:44:  AddTensor<T>(filter_tensor_name, filter_shape, 0, data.size(), net_def.get());
test/ccunit/mace/libmace/mace_api_test.cc:71:  std::map<std::string, mace::MaceTensor> inputs;
test/ccunit/mace/libmace/mace_api_test.cc:72:  std::map<std::string, mace::MaceTensor> outputs;
test/ccunit/mace/libmace/mace_api_mt_test.cc:46:  AddTensor<half>(
test/ccunit/mace/libmace/mace_api_mt_test.cc:75:  std::map<std::string, mace::MaceTensor> inputs;
test/ccunit/mace/libmace/mace_api_mt_test.cc:76:  std::map<std::string, mace::MaceTensor> outputs;
test/ccunit/mace/ops/argmax_test.cc:49:  auto expected = net.CreateTensor<int32_t>(output_shape, output);
test/ccunit/mace/ops/argmax_test.cc:50:  ExpectTensorNear<int32_t>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/lstmcell_test.cc:68:  Tensor expected_cell, expected_output;
test/ccunit/mace/ops/lstmcell_test.cc:73:    ExpectTensorNear<float>(expected_cell, *net.GetOutput("Cell"), 1e-3);
test/ccunit/mace/ops/lstmcell_test.cc:74:    ExpectTensorNear<float>(expected_output, *net.GetOutput("Output"), 1e-3);
test/ccunit/mace/ops/lstmcell_test.cc:76:    ExpectTensorNear<float>(expected_cell, *net.GetOutput("Cell"), 1e-5);
test/ccunit/mace/ops/lstmcell_test.cc:77:    ExpectTensorNear<float>(expected_output, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/depthwise_deconv2d_test.cc:77:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/depthwise_deconv2d_test.cc:78:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 0.0001);
test/ccunit/mace/ops/depthwise_deconv2d_test.cc:219:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/depthwise_deconv2d_test.cc:239:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/depthwise_deconv2d_test.cc:241:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2);
test/ccunit/mace/ops/conv_2d_test.cc:84:  auto expected = net.CreateTensor<float>(output_shape, {18.1f});
test/ccunit/mace/ops/conv_2d_test.cc:86:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/conv_2d_test.cc:88:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-3, 1e-3);
test/ccunit/mace/ops/conv_2d_test.cc:142:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/conv_2d_test.cc:147:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/conv_2d_test.cc:149:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-3, 1e-3);
test/ccunit/mace/ops/conv_2d_test.cc:225:  auto expected = net.CreateTensor<float>({1, 1, 1, 1}, {18.0f});
test/ccunit/mace/ops/conv_2d_test.cc:227:  ExpectTensorNear<float, T>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/conv_2d_test.cc:293:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/conv_2d_test.cc:296:  ExpectTensorNear<float, T>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/conv_2d_test.cc:361:  auto expected = net.CreateTensor<float>(output_shape, {0.0f});
test/ccunit/mace/ops/conv_2d_test.cc:362:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/conv_2d_test.cc:416:  auto expected = net.CreateTensor<float>(output_shape, {0.0f});
test/ccunit/mace/ops/conv_2d_test.cc:418:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/conv_2d_test.cc:494:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/conv_2d_test.cc:503:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/conv_2d_test.cc:559:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/conv_2d_test.cc:579:    ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-4,
test/ccunit/mace/ops/conv_2d_test.cc:674:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/conv_2d_test.cc:692:    ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-2,
test/ccunit/mace/ops/conv_2d_test.cc:835:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/conv_2d_test.cc:851:    ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-4,
test/ccunit/mace/ops/conv_2d_test.cc:922:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/conv_2d_test.cc:939:    ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-2,
test/ccunit/mace/ops/conv_2d_test.cc:1001:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/conv_2d_test.cc:1019:      ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-1,
test/ccunit/mace/ops/conv_2d_test.cc:1022:      ExpectTensorNear<float>(*expected, *net.GetOutput("OPENCLOutput"), 1e-4,
test/ccunit/mace/ops/conv_2d_test.cc:1096:  Tensor *output = net.GetTensor("Output");
test/ccunit/mace/ops/conv_2d_test.cc:1102:  auto expected = net.CreateTensor<uint8_t>({1, 1, 1, 1}, {230});
test/ccunit/mace/ops/conv_2d_test.cc:1103:  ExpectTensorNear<uint8_t>(*expected, *output);
test/ccunit/mace/ops/conv_2d_test.cc:1169:  Tensor *q_filter = net.GetTensor("QuantizedFilter");
test/ccunit/mace/ops/conv_2d_test.cc:1170:  Tensor *q_input = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/conv_2d_test.cc:1171:  Tensor *bias = net.GetTensor("Bias");
test/ccunit/mace/ops/conv_2d_test.cc:1193:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/conv_2d_test.cc:1194:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/conv_2d_test.cc:1208:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/conv_2d_test.cc:1209:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/quantize_test.cc:39:    Tensor *quantized_output = net.GetTensor("QuantizeOutput");
test/ccunit/mace/ops/quantize_test.cc:40:    Tensor::MappingGuard guard(quantized_output);
test/ccunit/mace/ops/quantize_test.cc:56:  ExpectTensorNear<float>(*net.GetTensor("Input"),
test/ccunit/mace/ops/quantize_test.cc:57:                          *net.GetTensor("Output"),
test/ccunit/mace/ops/one_hot_test.cc:53:  auto actual = net.GetTensor(output.c_str());
test/ccunit/mace/ops/one_hot_test.cc:54:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/one_hot_test.cc:56:  ExpectTensorNear<float>(*expected, *actual, 1e-5);
test/ccunit/mace/ops/infer_conv2d_shape_test.cc:53:  ExpectTensorNear<int32_t>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/pooling_test.cc:58:      net.CreateTensor<float>({1, 2, 2, 2}, {5, 21, 7, 23, 13, 29, 15, 31});
test/ccunit/mace/ops/pooling_test.cc:60:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:91:  auto expected = net.CreateTensor<float>({1, 2, 2, 1}, {4, 5, 7, 8});
test/ccunit/mace/ops/pooling_test.cc:93:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:125:  auto expected = net.CreateTensor<float>({1, 2, 2, 1}, {10, 11, 14, 15});
test/ccunit/mace/ops/pooling_test.cc:127:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:159:  auto expected = net.CreateTensor<float>({1, 1, 5, 1}, {10, 12, 14, 16, 17});
test/ccunit/mace/ops/pooling_test.cc:161:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:206:  auto expected = net.CreateTensor<float>({1, 1, 4, 1}, {20, 22, 24, 26});
test/ccunit/mace/ops/pooling_test.cc:208:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:246:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/pooling_test.cc:262:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-3,
test/ccunit/mace/ops/pooling_test.cc:265:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:327:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/pooling_test.cc:330:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:356:  auto expected = net.CreateTensor<float>({1, 1, 4, 1}, {4.5, 6.5, 8.5, 10.5});
test/ccunit/mace/ops/pooling_test.cc:358:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:395:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/pooling_test.cc:411:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-3,
test/ccunit/mace/ops/pooling_test.cc:414:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:487:      net.CreateTensor<uint8_t>({1, 2, 2, 2}, {5, 21, 7, 23, 13, 29, 15, 31});
test/ccunit/mace/ops/pooling_test.cc:489:  ExpectTensorNear<uint8_t>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:515:  auto expected = net.CreateTensor<uint8_t>({1, 2, 2, 1}, {4, 5, 7, 8});
test/ccunit/mace/ops/pooling_test.cc:517:  ExpectTensorNear<uint8_t>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:545:  auto expected = net.CreateTensor<uint8_t>(
test/ccunit/mace/ops/pooling_test.cc:548:  ExpectTensorNear<uint8_t>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/pooling_test.cc:616:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/pooling_test.cc:617:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/local_response_norm_test.cc:50:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/local_response_norm_test.cc:54:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 0, 1e-2);
test/ccunit/mace/ops/bias_add_test.cc:59:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/bias_add_test.cc:63:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/bias_add_test.cc:104:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/bias_add_test.cc:117:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/bias_add_test.cc:152:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/bias_add_test.cc:165:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:54:  auto expected = net.CreateTensor<DstType>({}, {output});
test/ccunit/mace/ops/eltwise_test.cc:56:  ExpectTensorNear<DstType>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:60:void SimpleTensorScalar(const ops::EltwiseType type,
test/ccunit/mace/ops/eltwise_test.cc:99:  auto expected = net.CreateTensor<DstType>(shape, output);
test/ccunit/mace/ops/eltwise_test.cc:101:  ExpectTensorNear<DstType>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:105:void SimpleTensorEltwise(const ops::EltwiseType type,
test/ccunit/mace/ops/eltwise_test.cc:167:  auto expected = net.CreateTensor<DstType>(output_shape, output);
test/ccunit/mace/ops/eltwise_test.cc:169:  ExpectTensorNear<DstType>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:173:void TensorGeneralBroadcastEltwise(const ops::EltwiseType type,
test/ccunit/mace/ops/eltwise_test.cc:220:  auto expected = net.CreateTensor<DstType>(output_shape, output);
test/ccunit/mace/ops/eltwise_test.cc:221:  ExpectTensorNear<DstType>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:252:TEST_F(EltwiseOpTest, CPUSimpleTensorScalar) {
test/ccunit/mace/ops/eltwise_test.cc:253:  SimpleTensorScalar<DeviceType::CPU, float, float>(ops::EltwiseType::SUM,
test/ccunit/mace/ops/eltwise_test.cc:255:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:258:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:261:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:264:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:267:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:270:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:273:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:276:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:279:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:282:  SimpleTensorScalar<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:285:  SimpleTensorScalar<DeviceType::CPU, int32_t, int32_t>(
test/ccunit/mace/ops/eltwise_test.cc:290:TEST_F(EltwiseOpTest, GPUSimpleTensorScalar) {
test/ccunit/mace/ops/eltwise_test.cc:291:  SimpleTensorScalar<DeviceType::GPU, float, float>(ops::EltwiseType::SUM,
test/ccunit/mace/ops/eltwise_test.cc:293:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:296:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:299:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:302:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:305:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:308:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:311:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:314:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:317:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:320:  SimpleTensorScalar<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:325:TEST_F(EltwiseOpTest, CPUSimpleTensorVector) {
test/ccunit/mace/ops/eltwise_test.cc:326:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:329:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:332:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:335:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:338:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:341:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:344:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:348:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:353:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:356:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:360:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:363:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:366:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:370:  SimpleTensorEltwise<DeviceType::CPU, int32_t, int32_t>(
test/ccunit/mace/ops/eltwise_test.cc:374:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:377:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:380:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:383:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:386:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:389:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:392:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:396:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:400:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:403:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:407:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:410:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:413:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:416:  SimpleTensorEltwise<DeviceType::CPU, int32_t, int32_t>(
test/ccunit/mace/ops/eltwise_test.cc:421:TEST_F(EltwiseOpTest, GPUSimpleTensorVector) {
test/ccunit/mace/ops/eltwise_test.cc:422:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:425:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:428:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:431:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:434:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:437:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:440:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:444:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:449:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:452:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:456:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:459:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:462:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:468:TEST_F(EltwiseOpTest, CPUSimpleTensorTensor) {
test/ccunit/mace/ops/eltwise_test.cc:469:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:472:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:475:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:478:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:481:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:484:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:487:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:490:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:494:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:498:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:502:  SimpleTensorEltwise<DeviceType::CPU, int32_t, int32_t>(
test/ccunit/mace/ops/eltwise_test.cc:505:  SimpleTensorEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:510:TEST_F(EltwiseOpTest, GPUSimpleTensorTensor) {
test/ccunit/mace/ops/eltwise_test.cc:511:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:514:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:517:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:520:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:523:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:526:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:529:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:532:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:536:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:540:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:544:  SimpleTensorEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:594:  auto expected = net.CreateTensor<T>(output_shape, output);
test/ccunit/mace/ops/eltwise_test.cc:595:  ExpectTensorNear<T>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:647:void RandomTensorScalar(const ops::EltwiseType type,
test/ccunit/mace/ops/eltwise_test.cc:668:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/eltwise_test.cc:683:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:685:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2, 1e-2);
test/ccunit/mace/ops/eltwise_test.cc:690:void RandomTensorEltwise(const ops::EltwiseType type,
test/ccunit/mace/ops/eltwise_test.cc:726:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/eltwise_test.cc:742:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/eltwise_test.cc:744:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2, 1e-2);
test/ccunit/mace/ops/eltwise_test.cc:818:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/eltwise_test.cc:819:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/eltwise_test.cc:833:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/eltwise_test.cc:834:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/eltwise_test.cc:838:TEST_F(EltwiseOpTest, RandomTensorScalarFloat) {
test/ccunit/mace/ops/eltwise_test.cc:839:  RandomTensorScalar<float>(ops::EltwiseType::SUM, {1, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:840:  RandomTensorScalar<float>(ops::EltwiseType::SUB, {3, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:841:  RandomTensorScalar<float>(ops::EltwiseType::PROD, {1, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:842:  RandomTensorScalar<float>(ops::EltwiseType::DIV, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:843:  RandomTensorScalar<float>(ops::EltwiseType::MIN, {1, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:844:  RandomTensorScalar<float>(ops::EltwiseType::MAX, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:845:  RandomTensorScalar<float>(ops::EltwiseType::NEG, {1, 32, 32, 32});
test/ccunit/mace/ops/eltwise_test.cc:846:  RandomTensorScalar<float>(ops::EltwiseType::ABS, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:847:  RandomTensorScalar<float>(ops::EltwiseType::SQR_DIFF, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:850:TEST_F(EltwiseOpTest, RandomTensorScalarHalf) {
test/ccunit/mace/ops/eltwise_test.cc:851:  RandomTensorScalar<half>(ops::EltwiseType::SUM, {1, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:852:  RandomTensorScalar<half>(ops::EltwiseType::SUB, {3, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:853:  RandomTensorScalar<half>(ops::EltwiseType::PROD, {1, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:854:  RandomTensorScalar<half>(ops::EltwiseType::DIV, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:855:  RandomTensorScalar<half>(ops::EltwiseType::MIN, {1, 32, 32, 16});
test/ccunit/mace/ops/eltwise_test.cc:856:  RandomTensorScalar<half>(ops::EltwiseType::MAX, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:857:  RandomTensorScalar<half>(ops::EltwiseType::NEG, {1, 32, 32, 32});
test/ccunit/mace/ops/eltwise_test.cc:858:  RandomTensorScalar<half>(ops::EltwiseType::ABS, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:859:  RandomTensorScalar<half>(ops::EltwiseType::SQR_DIFF, {3, 31, 37, 17});
test/ccunit/mace/ops/eltwise_test.cc:862:TEST_F(EltwiseOpTest, RandomTensorVecFloat) {
test/ccunit/mace/ops/eltwise_test.cc:863:  RandomTensorEltwise<float>(ops::EltwiseType::SUM, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:865:  RandomTensorEltwise<float>(ops::EltwiseType::SUB, {5, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:867:  RandomTensorEltwise<float>(ops::EltwiseType::SUB, {5, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:869:  RandomTensorEltwise<float>(ops::EltwiseType::SUB, {5, 1, 1, 16},
test/ccunit/mace/ops/eltwise_test.cc:871:  RandomTensorEltwise<float>(ops::EltwiseType::PROD, {1, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:873:  RandomTensorEltwise<float>(ops::EltwiseType::PROD, {1, 1, 1, 17},
test/ccunit/mace/ops/eltwise_test.cc:875:  RandomTensorEltwise<float>(ops::EltwiseType::DIV, {3, 1, 1, 17},
test/ccunit/mace/ops/eltwise_test.cc:877:  RandomTensorEltwise<float>(ops::EltwiseType::MIN, {1, 1, 1, 16},
test/ccunit/mace/ops/eltwise_test.cc:879:  RandomTensorEltwise<float>(ops::EltwiseType::MAX, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:881:  RandomTensorEltwise<float>(ops::EltwiseType::SQR_DIFF, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:885:TEST_F(EltwiseOpTest, RandomTensorVecHalf) {
test/ccunit/mace/ops/eltwise_test.cc:886:  RandomTensorEltwise<half>(ops::EltwiseType::SUM, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:888:  RandomTensorEltwise<half>(ops::EltwiseType::SUB, {3, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:890:  RandomTensorEltwise<half>(ops::EltwiseType::SUB, {3, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:892:  RandomTensorEltwise<half>(ops::EltwiseType::SUB, {3, 1, 1, 16},
test/ccunit/mace/ops/eltwise_test.cc:894:  RandomTensorEltwise<half>(ops::EltwiseType::PROD, {1, 1, 1, 17},
test/ccunit/mace/ops/eltwise_test.cc:896:  RandomTensorEltwise<half>(ops::EltwiseType::DIV, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:898:  RandomTensorEltwise<half>(ops::EltwiseType::DIV, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:900:  RandomTensorEltwise<half>(ops::EltwiseType::DIV, {5, 1, 1, 17},
test/ccunit/mace/ops/eltwise_test.cc:902:  RandomTensorEltwise<half>(ops::EltwiseType::MIN, {1, 1, 1, 16},
test/ccunit/mace/ops/eltwise_test.cc:904:  RandomTensorEltwise<half>(ops::EltwiseType::MAX, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:906:  RandomTensorEltwise<half>(ops::EltwiseType::SQR_DIFF, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:910:TEST_F(EltwiseOpTest, RandomTensorTensorFloat) {
test/ccunit/mace/ops/eltwise_test.cc:911:  RandomTensorEltwise<float>(ops::EltwiseType::SUM, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:913:  RandomTensorEltwise<float>(ops::EltwiseType::SUB, {3, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:915:  RandomTensorEltwise<float>(ops::EltwiseType::PROD, {1, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:917:  RandomTensorEltwise<float>(ops::EltwiseType::DIV, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:919:  RandomTensorEltwise<float>(ops::EltwiseType::MIN, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:921:  RandomTensorEltwise<float>(ops::EltwiseType::MAX, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:923:  RandomTensorEltwise<float>(ops::EltwiseType::SQR_DIFF, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:925:  RandomTensorEltwise<float>(ops::EltwiseType::CLIP, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:929:TEST_F(EltwiseOpTest, RandomTensorTensorHalf) {
test/ccunit/mace/ops/eltwise_test.cc:930:  RandomTensorEltwise<half>(ops::EltwiseType::SUM, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:932:  RandomTensorEltwise<half>(ops::EltwiseType::SUB, {3, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:934:  RandomTensorEltwise<half>(ops::EltwiseType::PROD, {1, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:936:  RandomTensorEltwise<half>(ops::EltwiseType::DIV, {5, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:938:  RandomTensorEltwise<half>(ops::EltwiseType::MIN, {1, 32, 32, 16},
test/ccunit/mace/ops/eltwise_test.cc:940:  RandomTensorEltwise<half>(ops::EltwiseType::MAX, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:942:  RandomTensorEltwise<half>(ops::EltwiseType::SQR_DIFF, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:944:  RandomTensorEltwise<half>(ops::EltwiseType::CLIP, {3, 31, 37, 17},
test/ccunit/mace/ops/eltwise_test.cc:948:TEST_F(EltwiseOpTest, TensorGeneralBroadcastCPU) {
test/ccunit/mace/ops/eltwise_test.cc:949:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:952:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:955:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:958:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:961:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:964:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:967:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:970:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:973:  TensorGeneralBroadcastEltwise<DeviceType::CPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:976:  TensorGeneralBroadcastEltwise<DeviceType::CPU, int32_t, int32_t>(
test/ccunit/mace/ops/eltwise_test.cc:981:TEST_F(EltwiseOpTest, TensorGeneralBroadcastGPU) {
test/ccunit/mace/ops/eltwise_test.cc:982:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:985:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:988:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:991:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:994:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:997:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1000:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1003:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1006:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1010:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1013:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1016:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1019:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1022:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1025:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/eltwise_test.cc:1028:  TensorGeneralBroadcastEltwise<DeviceType::GPU, float, float>(
test/ccunit/mace/ops/reverse_test.cc:44:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/expand_dims_test.cc:43:  auto input = net.GetTensor("Input");
test/ccunit/mace/ops/expand_dims_test.cc:44:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/identity_test.cc:39:  auto input = net.GetTensor("Input");
test/ccunit/mace/ops/identity_test.cc:40:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/transpose_test.cc:42:  ExpectTensorNear<float>(*net.GetOutput("InputNCHW"),
test/ccunit/mace/ops/transpose_test.cc:64:  ExpectTensorNear<float>(*net.GetOutput("InputNHWC"),
test/ccunit/mace/ops/transpose_test.cc:100:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/transpose_test.cc:129:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/reduce_test.cc:67:  auto expected = net.CreateTensor<float>(output_shape, output);
test/ccunit/mace/ops/reduce_test.cc:68:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5, 1e-3);
test/ccunit/mace/ops/reduce_test.cc:94:  auto expected = net.CreateTensor<float>(output_shape, output);
test/ccunit/mace/ops/reduce_test.cc:95:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5, 1e-3);
test/ccunit/mace/ops/reduce_test.cc:319:      ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/reduce_test.cc:322:      ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/reduce_test.cc:405:    ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/reduce_test.cc:406:                               *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:37:  Tensor lhs(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:38:  Tensor rhs(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:39:  Tensor output(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:44:    Tensor::MappingGuard lhs_guard(&lhs);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:45:    Tensor::MappingGuard rhs_guard(&rhs);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:72:  Tensor expected_output(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemm_test.cc:89:  ExpectTensorNear<float>(expected_output, output);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:33:  Tensor lhs(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:34:  Tensor rhs(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:35:  Tensor bias(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:36:  Tensor output(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:42:    Tensor::MappingGuard lhs_guard(&lhs);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:43:    Tensor::MappingGuard rhs_guard(&rhs);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:44:    Tensor::MappingGuard bias_guard(&bias);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:68:  Tensor expected_output(GetCPUAllocator(), DataType::DT_FLOAT);
test/ccunit/mace/ops/arm/fp32/gemv_test.cc:82:  ExpectTensorNear<float>(expected_output, output);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:33:  Tensor lhs(GetCPUAllocator(), DataType::DT_UINT8);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:34:  Tensor rhs(GetCPUAllocator(), DataType::DT_UINT8);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:35:  Tensor bias(GetCPUAllocator(), DataType::DT_INT32);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:36:  Tensor output(GetCPUAllocator(), DataType::DT_INT32);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:46:    Tensor::MappingGuard lhs_guard(&lhs);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:47:    Tensor::MappingGuard rhs_guard(&rhs);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:48:    Tensor::MappingGuard bias_guard(&bias);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:73:  Tensor expected_output(GetCPUAllocator(), DataType::DT_INT32);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:87:  Tensor::MappingGuard output_guard(&output);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:88:  Tensor::MappingGuard expected_guard(&expected_output);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:102:  Tensor lhs(GetCPUAllocator(), DataType::DT_UINT8);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:103:  Tensor rhs(GetCPUAllocator(), DataType::DT_UINT8);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:104:  Tensor bias(GetCPUAllocator(), DataType::DT_INT32);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:105:  Tensor output(GetCPUAllocator(), DataType::DT_UINT8);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:117:    Tensor::MappingGuard lhs_guard(&lhs);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:118:    Tensor::MappingGuard rhs_guard(&rhs);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:119:    Tensor::MappingGuard bias_guard(&bias);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:145:  Tensor expected_output(GetCPUAllocator(), DataType::DT_INT32);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:161:  Tensor::MappingGuard output_guard(&output);
test/ccunit/mace/ops/arm/q8/gemv_test.cc:162:  Tensor::MappingGuard expected_guard(&expected_output);
test/ccunit/mace/ops/channel_shuffle_test.cc:47:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/channel_shuffle_test.cc:50:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/channel_shuffle_test.cc:72:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/channel_shuffle_test.cc:77:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/slice_test.cc:47:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/split_test.cc:82:    Tensor::MappingGuard output_mapper(output);
test/ccunit/mace/ops/folded_batch_norm_test.cc:76:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/folded_batch_norm_test.cc:80:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4);
test/ccunit/mace/ops/folded_batch_norm_test.cc:122:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/folded_batch_norm_test.cc:135:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/folded_batch_norm_test.cc:173:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/folded_batch_norm_test.cc:189:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/folded_batch_norm_test.cc:227:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/folded_batch_norm_test.cc:241:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/folded_batch_norm_test.cc:279:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/folded_batch_norm_test.cc:294:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/target_rms_norm_test.cc:43:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/resize_bicubic_test.cc:49:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 6, 7, 8});
test/ccunit/mace/ops/resize_bicubic_test.cc:51:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2);
test/ccunit/mace/ops/resize_bicubic_test.cc:78:  auto expected = net.CreateTensor<float>({1, 2, 3, 3},
test/ccunit/mace/ops/resize_bicubic_test.cc:83:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2);
test/ccunit/mace/ops/resize_bicubic_test.cc:111:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 9, 10, 11});
test/ccunit/mace/ops/resize_bicubic_test.cc:113:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2);
test/ccunit/mace/ops/resize_bicubic_test.cc:150:    Tensor expected;
test/ccunit/mace/ops/resize_bicubic_test.cc:164:    ExpectTensorNear<float>(expected, *net.GetOutput("Output"), 1e-2,
test/ccunit/mace/ops/depth_to_space_test.cc:57:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/depth_to_space_test.cc:58:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/depth_to_space_test.cc:212:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/depth_to_space_test.cc:215:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/depth_to_space_test.cc:310:  Tensor *eq_output = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/depth_to_space_test.cc:311:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/depth_to_space_test.cc:323:  ExpectTensorSimilar<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/depth_to_space_test.cc:324:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/batch_norm_test.cc:68:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/batch_norm_test.cc:72:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4);
test/ccunit/mace/ops/batch_norm_test.cc:121:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/batch_norm_test.cc:145:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/batch_norm_test.cc:188:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/batch_norm_test.cc:212:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/batch_norm_test.cc:255:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/batch_norm_test.cc:278:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/batch_norm_test.cc:321:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/batch_norm_test.cc:345:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"),
test/ccunit/mace/ops/cast_test.cc:43:  auto input_tensor = net.GetTensor("Input");
test/ccunit/mace/ops/cast_test.cc:44:  auto output_tensor = net.GetTensor("Output");
test/ccunit/mace/ops/prior_box_test.cc:45:  auto expected_tensor = net.CreateTensor<float>({1, 2, 24},
test/ccunit/mace/ops/prior_box_test.cc:59:  ExpectTensorNear<float>(*expected_tensor, *net.GetTensor("OUTPUT"));
test/ccunit/mace/ops/space_to_batch_test.cc:30:                     const Tensor *expected) {
test/ccunit/mace/ops/space_to_batch_test.cc:60:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/space_to_batch_test.cc:68:                     const Tensor *expected) {
test/ccunit/mace/ops/space_to_batch_test.cc:99:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/space_to_batch_test.cc:110:  auto space_tensor = net.CreateTensor<T, GPU>();
test/ccunit/mace/ops/space_to_batch_test.cc:113:    Tensor::MappingGuard space_mapper(space_tensor.get());
test/ccunit/mace/ops/space_to_batch_test.cc:121:  auto batch_tensor = net.CreateTensor<T, GPU>();
test/ccunit/mace/ops/space_to_batch_test.cc:124:    Tensor::MappingGuard batch_mapper(batch_tensor.get());
test/ccunit/mace/ops/space_to_batch_test.cc:171:  ExpectTensorNear<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/space_to_batch_test.cc:204:  ExpectTensorNear<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/space_to_batch_test.cc:252:  Tensor *eq_output = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/space_to_batch_test.cc:253:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/space_to_batch_test.cc:265:  ExpectTensorSimilar<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/space_to_batch_test.cc:266:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/space_to_batch_test.cc:313:  Tensor *eq_output = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/space_to_batch_test.cc:314:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/space_to_batch_test.cc:326:  ExpectTensorSimilar<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/space_to_batch_test.cc:327:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/sqrdiff_mean_test.cc:69:  auto expected = net.CreateTensor<float>(output_shape, output);
test/ccunit/mace/ops/sqrdiff_mean_test.cc:70:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5, 1e-3);
test/ccunit/mace/ops/sqrdiff_mean_test.cc:131:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/sqrdiff_mean_test.cc:134:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/stack_test.cc:48:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/reshape_test.cc:46:  auto input = net.GetTensor("Input");
test/ccunit/mace/ops/reshape_test.cc:47:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/gather_test.cc:49:  auto expected = net.CreateTensor<T>(output_shape, output);
test/ccunit/mace/ops/gather_test.cc:51:  ExpectTensorNear<T>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/sum_group_test.cc:48:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/crop_test.cc:69:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/crop_test.cc:70:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/fully_connected_test.cc:67:  auto expected = net.CreateTensor<float>(output_shape, output_value);
test/ccunit/mace/ops/fully_connected_test.cc:69:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/fully_connected_test.cc:151:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/fully_connected_test.cc:169:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-1,
test/ccunit/mace/ops/fully_connected_test.cc:172:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2,
test/ccunit/mace/ops/fully_connected_test.cc:263:  Tensor *q_weight = net.GetTensor("QuantizedWeight");
test/ccunit/mace/ops/fully_connected_test.cc:264:  Tensor *q_input = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/fully_connected_test.cc:265:  Tensor *bias = net.GetTensor("Bias");
test/ccunit/mace/ops/fully_connected_test.cc:285:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/fully_connected_test.cc:286:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/fully_connected_test.cc:300:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/fully_connected_test.cc:301:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/concat_test.cc:240:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/concat_test.cc:241:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/concat_test.cc:255:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/concat_test.cc:256:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/concat_test.cc:302:  Tensor::MappingGuard output_mapper(output);
test/ccunit/mace/ops/strided_slice_test.cc:63:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/strided_slice_test.cc:111:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/strided_slice_test.cc:139:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/strided_slice_test.cc:174:  ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/addn_test.cc:41:  auto expected = net.CreateTensor<float>({1, 2, 3, 1}, {2, 4, 6, 8, 10, 12});
test/ccunit/mace/ops/addn_test.cc:43:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/addn_test.cc:76:      net.CreateTensor<float>({1, 2, 3, 1}, {-0.000713, 8, 12, 16, 20, 24});
test/ccunit/mace/ops/addn_test.cc:78:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4, 1e-3);
test/ccunit/mace/ops/addn_test.cc:114:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/addn_test.cc:120:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2,
test/ccunit/mace/ops/resize_bilinear_test.cc:49:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 6, 7, 8});
test/ccunit/mace/ops/resize_bilinear_test.cc:51:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/resize_bilinear_test.cc:79:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 9, 10, 11});
test/ccunit/mace/ops/resize_bilinear_test.cc:81:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/resize_bilinear_test.cc:117:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/resize_bilinear_test.cc:131:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5,
test/ccunit/mace/ops/resize_bilinear_test.cc:191:    Tensor *eq_output = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/resize_bilinear_test.cc:192:    Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/resize_bilinear_test.cc:204:    ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/resize_bilinear_test.cc:205:                               *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/fill_test.cc:45:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/matmul_test.cc:49:  auto expected = net.CreateTensor<float>(C_shape, C_value);
test/ccunit/mace/ops/matmul_test.cc:51:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/matmul_test.cc:115:  Tensor expected_output_tensor;
test/ccunit/mace/ops/matmul_test.cc:124:               net.GetTensor("A"),
test/ccunit/mace/ops/matmul_test.cc:125:               net.GetTensor("B"),
test/ccunit/mace/ops/matmul_test.cc:138:  ExpectTensorNear<float>(expected_output_tensor, *net.GetTensor("Output"),
test/ccunit/mace/ops/matmul_test.cc:233:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/matmul_test.cc:234:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/matmul_test.cc:248:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/matmul_test.cc:249:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/matmul_test.cc:328:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/matmul_test.cc:329:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/matmul_test.cc:390:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/matmul_test.cc:391:                             *net.GetTensor("Float16Output"), 0.01);
test/ccunit/mace/ops/pnorm_test.cc:46:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/kaldi_batch_norm_test.cc:59:  auto expected = net.CreateTensor<float>(output_shape, output_value);
test/ccunit/mace/ops/kaldi_batch_norm_test.cc:61:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4);
test/ccunit/mace/ops/kaldi_batch_norm_test.cc:90:  auto expected = net.CreateTensor<float>(output_shape, output_value);
test/ccunit/mace/ops/kaldi_batch_norm_test.cc:92:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4);
test/ccunit/mace/ops/unstack_test.cc:47:    ExpectTensorNear<float>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/softmax_test.cc:48:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/softmax_test.cc:67:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/softmax_test.cc:81:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/softmax_test.cc:92:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/softmax_test.cc:138:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/softmax_test.cc:150:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/softmax_test.cc:219:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/softmax_test.cc:232:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/softmax_test.cc:233:                             *net.GetTensor("DequantizedOutput"), 0.1);
test/ccunit/mace/ops/buffer_to_image_test.cc:35:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:39:      .Transform(&context, net.ws()->GetTensor("Input"),
test/ccunit/mace/ops/buffer_to_image_test.cc:43:  Tensor *i2b_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:50:  ExpectTensorNear<T>(*net.GetOutput("Input"), *net.GetOutput("I2BOutput"),
test/ccunit/mace/ops/buffer_to_image_test.cc:176:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:180:      .Transform(&context, net.ws()->GetTensor("Input"),
test/ccunit/mace/ops/buffer_to_image_test.cc:184:  Tensor *i2b_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:191:  ExpectTensorNear<float>(*net.GetOutput("Input"), *net.GetOutput("I2BOutput"),
test/ccunit/mace/ops/buffer_to_image_test.cc:215:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:220:      .Transform(&context, net.ws()->GetTensor("Input"),
test/ccunit/mace/ops/buffer_to_image_test.cc:224:  Tensor *i2b_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_to_image_test.cc:231:  ExpectTensorNear<half>(*net.GetOutput("Input"), *net.GetOutput("I2BOutput"),
test/ccunit/mace/ops/cumsum_test.cc:55:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/opencl/out_of_range_check_test.cc:32:                               Tensor *buffer,
test/ccunit/mace/ops/opencl/out_of_range_check_test.cc:33:                               Tensor *image,
test/ccunit/mace/ops/opencl/out_of_range_check_test.cc:141:  Tensor *buffer =
test/ccunit/mace/ops/opencl/out_of_range_check_test.cc:142:      ws.CreateTensor("Buffer", device->allocator(),
test/ccunit/mace/ops/opencl/out_of_range_check_test.cc:147:  Tensor *image = ws.CreateTensor("Image", device->allocator(),
test/ccunit/mace/ops/space_to_depth_test.cc:57:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/space_to_depth_test.cc:58:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/space_to_depth_test.cc:203:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/space_to_depth_test.cc:206:    ExpectTensorNear<float>(*net.GetTensor("Output"),
test/ccunit/mace/ops/space_to_depth_test.cc:301:  Tensor *eq_output = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/space_to_depth_test.cc:302:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/space_to_depth_test.cc:314:  ExpectTensorSimilar<float>(*net.GetOutput("OutputCPU"),
test/ccunit/mace/ops/space_to_depth_test.cc:315:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:75:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/depthwise_conv2d_test.cc:80:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-3, 1e-3);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:82:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:199:      net.CreateTensor<float>({1, out_height, out_width, out_channels}, expect);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:202:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:204:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2);
test/ccunit/mace/ops/depthwise_conv2d_test.cc:274:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/depthwise_conv2d_test.cc:293:      ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5,
test/ccunit/mace/ops/depthwise_conv2d_test.cc:296:      ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-2,
test/ccunit/mace/ops/depthwise_conv2d_test.cc:363:  Tensor *output = net.GetTensor("Output");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:370:  auto expected = net.CreateTensor<uint8_t>({1, 1, 1, 2}, {255, 21});
test/ccunit/mace/ops/depthwise_conv2d_test.cc:372:  ExpectTensorNear<uint8_t>(*expected, *net.GetOutput("Output"));
test/ccunit/mace/ops/depthwise_conv2d_test.cc:437:  Tensor *q_filter = net.GetTensor("QuantizedFilter");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:438:  Tensor *q_input = net.GetTensor("QuantizedInput");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:439:  Tensor *bias = net.GetTensor("Bias");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:461:  Tensor *eq_output = net.GetTensor("ExpectedQuantizedOutput");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:462:  Tensor *q_output = net.GetTensor("QuantizedOutput");
test/ccunit/mace/ops/depthwise_conv2d_test.cc:476:  ExpectTensorSimilar<float>(*net.GetOutput("Output"),
test/ccunit/mace/ops/depthwise_conv2d_test.cc:477:                             *net.GetTensor("DequantizedOutput"), 0.01);
test/ccunit/mace/ops/pad_context_test.cc:45:  auto expected = net.CreateTensor<T>(output_shape, output);
test/ccunit/mace/ops/pad_context_test.cc:46:  ExpectTensorNear<T>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/shape_test.cc:48:  ExpectTensorNear<int32_t>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/scalar_math_test.cc:51:  auto expected = net.CreateTensor<DstType>({}, {output});
test/ccunit/mace/ops/scalar_math_test.cc:53:  ExpectTensorNear<DstType>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/deconv_2d_test.cc:117:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/deconv_2d_test.cc:118:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 0.0001);
test/ccunit/mace/ops/deconv_2d_test.cc:448:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/deconv_2d_test.cc:481:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-4,
test/ccunit/mace/ops/extract_pooling_test.cc:58:  auto expected = net.CreateTensor<float>(output_shape, output_value);
test/ccunit/mace/ops/extract_pooling_test.cc:59:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/squeeze_test.cc:43:  auto input = net.GetTensor("Input");
test/ccunit/mace/ops/squeeze_test.cc:44:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/buffer_transform_test.cc:44:  Tensor *bt_output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_transform_test.cc:50:      .Transform(&context, net.ws()->GetTensor("Input"),
test/ccunit/mace/ops/buffer_transform_test.cc:54:  Tensor *output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_transform_test.cc:67:    ExpectTensorNear<OrgType>(*net.GetOutput("Input"),
test/ccunit/mace/ops/buffer_transform_test.cc:90:  Tensor *output = net.ws()->CreateTensor(
test/ccunit/mace/ops/buffer_transform_test.cc:95:      .Transform(&context, net.ws()->GetTensor("Input"),
test/ccunit/mace/ops/buffer_transform_test.cc:103:  ExpectTensorNear<T>(*net.GetTensor("Input"), *output,
test/ccunit/mace/ops/activation_test.cc:42:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:45:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:75:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:79:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:108:  auto expected = net.CreateTensor<float>({1, 3, 2, 1}, {0, 7, 0, 6, 0, 5});
test/ccunit/mace/ops/activation_test.cc:110:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:142:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:145:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:173:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:176:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:225:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:228:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:257:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:263:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/activation_test.cc:292:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/activation_test.cc:299:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/splice_test.cc:46:  ExpectTensorNear<T>(*net.GetOutput("ExpectedOutput"),
test/ccunit/mace/ops/pad_test.cc:65:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/pad_test.cc:67:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/pad_test.cc:73:  ExpectTensorNear<float>(*expected, *output, 1e-5);
test/ccunit/mace/ops/pad_test.cc:116:  auto actual = net.GetTensor(output.c_str());
test/ccunit/mace/ops/pad_test.cc:117:  auto expected = net.CreateTensor<float>(expected_shape, expected_data);
test/ccunit/mace/ops/pad_test.cc:119:  ExpectTensorNear<float>(*expected, *actual, 1e-5);
test/ccunit/mace/ops/pad_test.cc:192:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/pad_test.cc:194:  auto expected = net.CreateTensor<float>(
test/ccunit/mace/ops/pad_test.cc:201:  ExpectTensorNear<float>(*expected, *output, 1e-5);
test/ccunit/mace/ops/pad_test.cc:230:  auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/pad_test.cc:245:  auto output = net.GetTensor("Output");
test/ccunit/mace/ops/pad_test.cc:248:    ExpectTensorNear<float>(*expected, *output, 1e-2, 1e-2);
test/ccunit/mace/ops/pad_test.cc:250:    ExpectTensorNear<float>(*expected, *output, 1e-5);
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:52:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 6, 7, 8});
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:54:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:85:  auto expected = net.CreateTensor<float>({1, 1, 2, 3}, {0, 1, 2, 9, 10, 11});
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:87:  ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5);
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:122:    auto expected = net.CreateTensor<float>();
test/ccunit/mace/ops/resize_nearest_neighbor_test.cc:136:    ExpectTensorNear<float>(*expected, *net.GetOutput("Output"), 1e-5,
test/ccbenchmark/mace/ops/matmul_benchmark.cc:277:  net.GetTensor("A")->SetIsWeight(true);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:278:  net.GetTensor("B")->SetIsWeight(true);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:280:    net.GetTensor("A")->SetScale(0.1);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:281:    net.GetTensor("B")->SetScale(0.1);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:293:    net.GetTensor("Output")->SetScale(0.1);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:328:  net.GetTensor("A")->SetIsWeight(true);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:329:  net.GetTensor("B")->SetIsWeight(true);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:331:    net.GetTensor("A")->SetScale(0.1);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:332:    net.GetTensor("B")->SetScale(0.1);
test/ccbenchmark/mace/ops/matmul_benchmark.cc:349:    net.GetTensor("Output")->SetScale(0.1);
test/ccbenchmark/mace/ops/depthwise_conv2d_benchmark.cc:50:      net.GetTensor("Input")->SetScale(0.1);
test/ccbenchmark/mace/ops/depthwise_conv2d_benchmark.cc:66:    net.GetTensor("Filter")->SetScale(0.1);
test/ccbenchmark/mace/ops/depthwise_conv2d_benchmark.cc:85:    net.GetTensor("Output")->SetScale(0.1);
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:38:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:43:        .Transform(&context, net.ws()->GetTensor("Input"),
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:103:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:108:        .Transform(&context, net.ws()->GetTensor("Input"),
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:155:  Tensor *b2i_output = net.ws()->CreateTensor(
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:160:        .Transform(&context, net.ws()->GetTensor("Input"),
test/ccbenchmark/mace/ops/buffer_to_image_benchmark.cc:166:  Tensor *i2b_output = net.ws()->CreateTensor(
test/ccbenchmark/mace/ops/crop_benchmark.cc:71:      (net.GetTensor("Input0")->size());
test/ccbenchmark/mace/ops/concat_benchmark.cc:42:    net.GetTensor("Input0")->SetScale(0.1);
test/ccbenchmark/mace/ops/concat_benchmark.cc:43:    net.GetTensor("Input1")->SetScale(0.2);
test/ccbenchmark/mace/ops/concat_benchmark.cc:44:    net.GetTensor("Output")->SetScale(0.3);
test/ccbenchmark/mace/ops/concat_benchmark.cc:112:      (net.GetTensor("Input0")->size() + net.GetTensor("Input1")->size());
test/ccbenchmark/mace/ops/conv_2d_benchmark.cc:105:  net.GetTensor("Input")->SetScale(0.1);
test/ccbenchmark/mace/ops/conv_2d_benchmark.cc:108:  net.GetTensor("Filter")->SetScale(0.1);
test/ccbenchmark/mace/ops/conv_2d_benchmark.cc:123:  net.GetTensor("Output")->SetScale(0.1);
test/ccbenchmark/mace/ops/eltwise_benchmark.cc:54:    net.GetTensor("Output")->SetScale(0.1);
test/ccbenchmark/mace/ops/softmax_benchmark.cc:83:  Tensor *output = net.GetTensor("Output");
test/ccbenchmark/mace/ops/softmax_benchmark.cc:87:  Tensor *input = net.GetTensor("Input");
test/ccbenchmark/mace/ops/fully_connected_benchmark.cc:79:  net.GetTensor("Input")->SetScale(0.1);
test/ccbenchmark/mace/ops/fully_connected_benchmark.cc:82:  net.GetTensor("Weight")->SetScale(0.1);
test/ccbenchmark/mace/ops/fully_connected_benchmark.cc:94:  net.GetTensor("Output")->SetScale(0.1);
test/ccutils/mace/ops/ops_test_util.cc:188:      if (ws_.GetTensor(input) != nullptr &&
test/ccutils/mace/ops/ops_test_util.cc:189:          !ws_.GetTensor(input)->is_weight()) {
test/ccutils/mace/ops/ops_test_util.cc:201:        auto &shape = ws_.GetTensor(input)->shape();
test/ccutils/mace/ops/ops_test_util.cc:215:      ws_.RemoveTensor(op_def.output(i));
test/ccutils/mace/ops/ops_test_util.cc:238:  MaceStatus status = (ws_.PreallocateOutputTensor(
test/ccutils/mace/ops/ops_test_util.cc:294:  MACE_RETURN_IF_ERROR(ws_.PreallocateOutputTensor(
test/ccutils/mace/ops/ops_test_util.h:121:    Tensor *input =
test/ccutils/mace/ops/ops_test_util.h:122:        ws_.CreateTensor(name, OpTestContext::Get()->GetDevice(D)->allocator(),
test/ccutils/mace/ops/ops_test_util.h:125:    Tensor::MappingGuard input_mapper(input);
test/ccutils/mace/ops/ops_test_util.h:138:    Tensor *input =
test/ccutils/mace/ops/ops_test_util.h:139:        ws_.CreateTensor(name, OpTestContext::Get()->GetDevice(D)->allocator(),
test/ccutils/mace/ops/ops_test_util.h:142:    Tensor::MappingGuard input_mapper(input);
test/ccutils/mace/ops/ops_test_util.h:155:    Tensor *input =
test/ccutils/mace/ops/ops_test_util.h:156:        ws_.CreateTensor(name, OpTestContext::Get()->GetDevice(D)->allocator(),
test/ccutils/mace/ops/ops_test_util.h:159:    Tensor::MappingGuard input_mapper(input);
test/ccutils/mace/ops/ops_test_util.h:199:    Tensor *input = ws_.GetTensor(src_name);
test/ccutils/mace/ops/ops_test_util.h:200:    Tensor *output = ws_.CreateTensor(
test/ccutils/mace/ops/ops_test_util.h:209:    Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:218:    Tensor *input = ws_.GetTensor(src_name);
test/ccutils/mace/ops/ops_test_util.h:219:    Tensor *output = ws_.CreateTensor(
test/ccutils/mace/ops/ops_test_util.h:233:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:234:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:255:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:256:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:280:    Tensor *input = ws_.GetTensor(src_name);
test/ccutils/mace/ops/ops_test_util.h:281:    Tensor *output = ws_.CreateTensor(
test/ccutils/mace/ops/ops_test_util.h:296:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:297:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:315:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:316:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:333:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:334:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:353:      Tensor::MappingGuard input_guard(input);
test/ccutils/mace/ops/ops_test_util.h:354:      Tensor::MappingGuard output_guard(output);
test/ccutils/mace/ops/ops_test_util.h:374:  std::unique_ptr<Tensor> CreateTensor(
test/ccutils/mace/ops/ops_test_util.h:377:    std::unique_ptr<Tensor> res = make_unique<Tensor>(
test/ccutils/mace/ops/ops_test_util.h:417:  inline Tensor *GetOutput(const char *output_name) {
test/ccutils/mace/ops/ops_test_util.h:418:    return ws_.GetTensor(output_name);
test/ccutils/mace/ops/ops_test_util.h:421:  inline Tensor *GetTensor(const char *tensor_name) {
test/ccutils/mace/ops/ops_test_util.h:422:    return ws_.GetTensor(tensor_name);
test/ccutils/mace/ops/testing/test_utils.h:132:inline bool IsSameSize(const Tensor &x, const Tensor &y) {
test/ccutils/mace/ops/testing/test_utils.h:140:inline std::string ShapeToString(const Tensor &x) {
test/ccutils/mace/ops/testing/test_utils.h:178:inline void AssertSameDims(const Tensor &x, const Tensor &y) {
test/ccutils/mace/ops/testing/test_utils.h:193:  static void Equal(const Tensor &x, const Tensor &y) {
test/ccutils/mace/ops/testing/test_utils.h:197:    Tensor::MappingGuard x_mapper(&x);
test/ccutils/mace/ops/testing/test_utils.h:198:    Tensor::MappingGuard y_mapper(&y);
test/ccutils/mace/ops/testing/test_utils.h:206:  static void Near(const Tensor &x,
test/ccutils/mace/ops/testing/test_utils.h:207:                   const Tensor &y,
test/ccutils/mace/ops/testing/test_utils.h:213:    Tensor::MappingGuard x_mapper(&x);
test/ccutils/mace/ops/testing/test_utils.h:214:    Tensor::MappingGuard y_mapper(&y);
test/ccutils/mace/ops/testing/test_utils.h:245:  static void Equal(const Tensor &x, const Tensor &y) {
test/ccutils/mace/ops/testing/test_utils.h:249:    Tensor::MappingGuard x_mapper(&x);
test/ccutils/mace/ops/testing/test_utils.h:250:    Tensor::MappingGuard y_mapper(&y);
test/ccutils/mace/ops/testing/test_utils.h:258:  static void Near(const Tensor &x,
test/ccutils/mace/ops/testing/test_utils.h:259:                   const Tensor &y,
test/ccutils/mace/ops/testing/test_utils.h:269:void ExpectTensorNear(const Tensor &x,
test/ccutils/mace/ops/testing/test_utils.h:270:                      const Tensor &y,
test/ccutils/mace/ops/testing/test_utils.h:277:void ExpectTensorNear(const Tensor &x,
test/ccutils/mace/ops/testing/test_utils.h:278:                      const Tensor &y,
test/ccutils/mace/ops/testing/test_utils.h:285:void ExpectTensorSimilar(const Tensor &x,
test/ccutils/mace/ops/testing/test_utils.h:286:                         const Tensor &y,
test/ccutils/mace/ops/testing/test_utils.h:289:  Tensor::MappingGuard x_mapper(&x);
test/ccutils/mace/ops/testing/test_utils.h:290:  Tensor::MappingGuard y_mapper(&y);
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/optimized/depthwiseconv_float.h:1:/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/optimized/depthwiseconv_uint8_3x3_filter.h:1:/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/optimized/depthwiseconv_uint8.h:1:/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/types.h:1:/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/compatibility.h:1:/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
build/third_party/tflite/src/tflite/tensorflow/contrib/lite/kernels/internal/common.h:1:/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
build/third_party/eigen3/src/eigen3/CMakeLists.txt:362:option(EIGEN_TEST_CXX11 "Enable testing with C++11 and C++11 features (e.g. Tensor module)." OFF)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:18:template <typename Tensor, int Rank>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:19:struct TensorPrinter {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:20:  static void run (std::ostream& os, const Tensor& tensor) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:21:    typedef typename internal::remove_const<typename Tensor::Scalar>::type Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:22:    typedef typename Tensor::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:26:      static const int layout = Tensor::Layout;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:35:template <typename Tensor>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:36:struct TensorPrinter<Tensor, 1> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:37:  static void run (std::ostream& os, const Tensor& tensor) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:38:    typedef typename internal::remove_const<typename Tensor::Scalar>::type Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:39:    typedef typename Tensor::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:50:template <typename Tensor>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:51:struct TensorPrinter<Tensor, 0> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:52:  static void run (std::ostream& os, const Tensor& tensor) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:59:std::ostream& operator << (std::ostream& os, const TensorBase<T, ReadOnlyAccessors>& expr) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:60:  typedef TensorEvaluator<const TensorForcedEvalOp<const T>, DefaultDevice> Evaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:64:  TensorForcedEvalOp<const T> eval = expr.eval();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIO.h:70:  internal::TensorPrinter<Evaluator, rank>::run(os, tensor);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:27:template <typename Tensor, bool HasRawAccess, template <class> class MakePointer_ = MakePointer> struct CoeffLoader;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:28:template<typename Scalar, typename Index, int side, typename Tensor, typename nocontract_t, typename contract_t,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:30:         template <class> class MakePointer_ = MakePointer> class BaseTensorContractionMapper;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:32:template <typename Tensor, bool HasRawAccess, template <class> class MakePointer_> struct CoeffLoader {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:37:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffLoader(const Tensor& tensor) : m_tensor(tensor) { }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:39:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:43:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE typename Tensor::Scalar coeff(typename Tensor::Index index) const { return m_tensor.coeff(index); }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:46: typename Tensor::PacketReturnType packet(typename Tensor::Index index) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:53:  const Tensor m_tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:56:template <typename Tensor, template <class> class MakePointer_> struct CoeffLoader<Tensor, true, MakePointer_> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:61:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffLoader(const Tensor& tensor) : m_data(tensor.data()) {}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:63:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index offset) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:67:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE typename Tensor::Scalar coeff(typename Tensor::Index index) const { return loadConstant(m_data+index); }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:70: typename Tensor::PacketReturnType packet(typename Tensor::Index index) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:72:    return internal::ploadt_ro<typename Tensor::PacketReturnType, LoadMode>(m_data + index);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:75:  typedef typename Tensor::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:81:         typename Tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:84:class SimpleTensorContractionMapper {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:87:  SimpleTensorContractionMapper(const Tensor& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:99:    DirectOffsets = CoeffLoader<Tensor, Tensor::RawAccess, MakePointer_>::DirectOffsets
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:102:  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index offset) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:130:    if (array_size<typename Tensor::Dimensions>::value > array_size<contract_t>::value) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:163:    if (array_size<typename Tensor::Dimensions>::value > array_size<contract_t>::value) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:216:  CoeffLoader<Tensor, Tensor::RawAccess, MakePointer_> m_tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:224:         typename Tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:228:class BaseTensorContractionMapper : public SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, Alignment, MakePointer_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:231:  typedef SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, Alignment, MakePointer_> ParentMapper;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:234:  BaseTensorContractionMapper(const Tensor& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:241:  typedef typename Tensor::PacketReturnType Packet;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:253:    if (Tensor::PacketAccess && inner_dim_contiguous && !inner_dim_reordered) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:267:    if (Tensor::PacketAccess &&
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:313:         typename Tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:317:class BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> : public SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, Alignment, MakePointer_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:320:  typedef SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, Alignment, MakePointer_> ParentMapper;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:323:  BaseTensorContractionMapper(const Tensor& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:330:  typedef typename Tensor::PacketReturnType Packet;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:335:    return pload<typename Tensor::PacketReturnType>(data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:351:         typename Tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:355:class TensorContractionSubMapper {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:357:  typedef typename Tensor::PacketReturnType Packet;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:360:  typedef BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> ParentMapper;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:361:  typedef TensorContractionSubMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:370:  EIGEN_DEVICE_FUNC TensorContractionSubMapper(const ParentMapper& base_mapper, Index vert_offset, Index horiz_offset)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:458:         typename Tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:462:class TensorContractionInputMapper
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:463:  : public BaseTensorContractionMapper<Scalar_, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:467:  typedef BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:468:  typedef TensorContractionSubMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment, MakePointer_> SubMapper;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h:471:  EIGEN_DEVICE_FUNC TensorContractionInputMapper(const Tensor& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:14: * TensorSyclExtractAccessor.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:36:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:62:///  TensorCwiseNullaryOp,  TensorCwiseUnaryOp and  TensorBroadcastingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:65:struct ExtractAccessor<TensorEvaluator<CVQual UnaryCategory<OP, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:66:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual UnaryCategory<OP, RHSExpr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:75:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorCwiseBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:78:struct ExtractAccessor<TensorEvaluator<CVQual BinaryCategory<OP, LHSExpr, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:79:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual BinaryCategory<OP, LHSExpr, RHSExpr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:88:/// const TensorCwiseTernaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:91:struct ExtractAccessor<TensorEvaluator<CVQual TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:92:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:102:/// TensorCwiseSelectOp. This is a special case where there is no OP
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:105:struct ExtractAccessor<TensorEvaluator<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:106:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:114:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorAssignOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:117:struct ExtractAccessor<TensorEvaluator<CVQual TensorAssignOp<LHSExpr, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:118:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorAssignOp<LHSExpr, RHSExpr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:126:/// specialisation of the \ref ExtractAccessor struct when the node type is const TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:129:struct ExtractAccessor<TensorEvaluator<CVQual TensorMap<PlainObjectType, Options_>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:130:  static inline auto getTuple(cl::sycl::handler& cgh,const TensorEvaluator<CVQual TensorMap<PlainObjectType, Options_>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:138:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:141:struct ExtractAccessor<TensorEvaluator<CVQual TensorForcedEvalOp<Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:142:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorForcedEvalOp<Expr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:150://TensorCustomUnaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:153:struct ExtractAccessor<TensorEvaluator<CVQual TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:154:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:163://TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:166:struct ExtractAccessor<TensorEvaluator<CVQual TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:167:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:175:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorEvalToOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:178:struct ExtractAccessor<TensorEvaluator<CVQual TensorEvalToOp<Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:179:  static inline auto getTuple(cl::sycl::handler& cgh,const TensorEvaluator<CVQual TensorEvalToOp<Expr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:187:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:190:struct ExtractAccessor<TensorEvaluator<CVQual ExprNode<OP, Dim, Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:191:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual ExprNode<OP, Dim, Expr>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:194:// TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:195:SYCLREDUCTIONEXTACC(const,TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:196:SYCLREDUCTIONEXTACC(,TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:198:// TensorTupleReducerOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:199:SYCLREDUCTIONEXTACC(const,TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:200:SYCLREDUCTIONEXTACC(,TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:203:/// specialisation of the \ref ExtractAccessor struct when the node type is TensorContractionOp and TensorConvolutionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:206: struct ExtractAccessor<TensorEvaluator<CVQual ExprNode<Indices, LhsXprType, RhsXprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:207:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual ExprNode<Indices, LhsXprType, RhsXprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:210://TensorContractionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:211:SYCLCONTRACTIONCONVOLUTIONEXTACC(const,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:212:SYCLCONTRACTIONCONVOLUTIONEXTACC(,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:213://TensorConvolutionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:214:SYCLCONTRACTIONCONVOLUTIONEXTACC(const,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:215:SYCLCONTRACTIONCONVOLUTIONEXTACC(,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:219:/// const TensorSlicingOp.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:222:struct ExtractAccessor<TensorEvaluator<CVQual TensorSlicingOp<StartIndices, Sizes, XprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:223:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorSlicingOp<StartIndices, Sizes, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:231:///  TensorStridingSlicingOp.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:234:struct ExtractAccessor<TensorEvaluator<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:235:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:244:/// TensorChippingOp.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:247:struct ExtractAccessor<TensorEvaluator<CVQual TensorChippingOp<DimId, XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:248:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorChippingOp<DimId, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:257:/// TensorImagePatchOp.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:260:struct ExtractAccessor<TensorEvaluator<CVQual TensorImagePatchOp<Rows, Cols, XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:261:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorImagePatchOp<Rows, Cols, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:270:/// TensorVolumePatchOp.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:273:struct ExtractAccessor<TensorEvaluator<CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:274:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:283:/// TensorLayoutSwapOp, TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:286:struct ExtractAccessor<TensorEvaluator<CVQual ExprNode<XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:287:  static inline auto getTuple(cl::sycl::handler& cgh, const TensorEvaluator<CVQual ExprNode<XprType>, Dev>& eval)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:291:// TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:292:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXTACC(const,TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:293:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXTACC(,TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:294://TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:295:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXTACC(const,TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:296:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXTACC(,TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h:307:} /// namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:15:/** \class TensorImagePatch
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:31:struct traits<TensorImagePatchOp<Rows, Cols, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:44:struct eval<TensorImagePatchOp<Rows, Cols, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:46:  typedef const TensorImagePatchOp<Rows, Cols, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:50:struct nested<TensorImagePatchOp<Rows, Cols, XprType>, 1, typename eval<TensorImagePatchOp<Rows, Cols, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:52:  typedef TensorImagePatchOp<Rows, Cols, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:58:class TensorImagePatchOp : public TensorBase<TensorImagePatchOp<Rows, Cols, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:61:  typedef typename Eigen::internal::traits<TensorImagePatchOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:64:  typedef typename Eigen::internal::nested<TensorImagePatchOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:65:  typedef typename Eigen::internal::traits<TensorImagePatchOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:66:  typedef typename Eigen::internal::traits<TensorImagePatchOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:68:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorImagePatchOp(const XprType& expr, DenseIndex patch_rows, DenseIndex patch_cols,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:80:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorImagePatchOp(const XprType& expr, DenseIndex patch_rows, DenseIndex patch_cols,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:151:struct TensorEvaluator<const TensorImagePatchOp<Rows, Cols, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:153:  typedef TensorImagePatchOp<Rows, Cols, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:155:  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:159:  typedef TensorEvaluator<const TensorImagePatchOp<Rows, Cols, ArgType>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:161:  typedef TensorEvaluator<ArgType, Device> Impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:168:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:169:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:174:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:184:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:302:    m_fastOtherStride = internal::TensorIntDivisor<Index>(m_otherStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:303:    m_fastPatchStride = internal::TensorIntDivisor<Index>(m_patchStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:304:    m_fastColStride = internal::TensorIntDivisor<Index>(m_colStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:305:    m_fastInflateRowStride = internal::TensorIntDivisor<Index>(m_row_inflate_strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:306:    m_fastInflateColStride = internal::TensorIntDivisor<Index>(m_col_inflate_strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:307:    m_fastInputColsEff = internal::TensorIntDivisor<Index>(m_input_cols_eff);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:310:    m_fastOutputRows = internal::TensorIntDivisor<Index>(m_outputRows);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:312:      m_fastOutputDepth = internal::TensorIntDivisor<Index>(m_dimensions[0]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:314:      m_fastOutputDepth = internal::TensorIntDivisor<Index>(m_dimensions[NumDims-1]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:428:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:445:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:449:    // TensorEvaluator<ArgType, Device>::CoordAccess is false.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:450:    const double compute_cost = 3 * TensorOpCost::DivCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:451:                                6 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:452:                                8 * TensorOpCost::MulCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:454:           TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:486:  internal::TensorIntDivisor<Index> m_fastOtherStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:487:  internal::TensorIntDivisor<Index> m_fastPatchStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:488:  internal::TensorIntDivisor<Index> m_fastColStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:489:  internal::TensorIntDivisor<Index> m_fastInflateRowStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:490:  internal::TensorIntDivisor<Index> m_fastInflateColStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:491:  internal::TensorIntDivisor<Index> m_fastInputColsEff;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:507:  internal::TensorIntDivisor<Index> m_fastOutputRows;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:508:  internal::TensorIntDivisor<Index> m_fastOutputDepth;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h:512:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:15:/** \class TensorStriding
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:18:  * \brief Tensor striding class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:24:struct traits<TensorStridingOp<Strides, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:37:struct eval<TensorStridingOp<Strides, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:39:  typedef const TensorStridingOp<Strides, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:43:struct nested<TensorStridingOp<Strides, XprType>, 1, typename eval<TensorStridingOp<Strides, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:45:  typedef TensorStridingOp<Strides, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:53:class TensorStridingOp : public TensorBase<TensorStridingOp<Strides, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:56:  typedef typename Eigen::internal::traits<TensorStridingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:59:  typedef typename Eigen::internal::nested<TensorStridingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:60:  typedef typename Eigen::internal::traits<TensorStridingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:61:  typedef typename Eigen::internal::traits<TensorStridingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorStridingOp(const XprType& expr, const Strides& dims)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:74:    EIGEN_STRONG_INLINE TensorStridingOp& operator = (const TensorStridingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:76:      typedef TensorAssignOp<TensorStridingOp, const TensorStridingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:78:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:84:    EIGEN_STRONG_INLINE TensorStridingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:86:      typedef TensorAssignOp<TensorStridingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:88:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:100:struct TensorEvaluator<const TensorStridingOp<Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:102:  typedef TensorStridingOp<Strides, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:104:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:112:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:113:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:114:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:119:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:127:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:211:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:212:    double compute_cost = (NumDims - 1) * (TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:213:                                           TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:214:                                           TensorOpCost::DivCost<Index>()) +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:215:        TensorOpCost::MulCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:222:        TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:228:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:257:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:263:struct TensorEvaluator<TensorStridingOp<Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:264:    : public TensorEvaluator<const TensorStridingOp<Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:266:  typedef TensorStridingOp<Strides, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:267:  typedef TensorEvaluator<const XprType, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:269:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:273:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:274:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:275:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:280:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h:295:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return this->m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:37:template<typename PlainObjectType, int Options_ = Unaligned, template <class> class MakePointer_ = MakePointer> class TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:38:template<typename Scalar_, int NumIndices_, int Options_ = 0, typename IndexType = DenseIndex> class Tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:39:template<typename Scalar_, typename Dimensions, int Options_ = 0, typename IndexType = DenseIndex> class TensorFixedSize;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:40:template<typename PlainObjectType> class TensorRef;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:41:template<typename Derived, int AccessLevel> class TensorBase;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:43:template<typename NullaryOp, typename PlainObjectType> class TensorCwiseNullaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:44:template<typename UnaryOp, typename XprType> class TensorCwiseUnaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:45:template<typename BinaryOp, typename LeftXprType, typename RightXprType> class TensorCwiseBinaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:46:template<typename TernaryOp, typename Arg1XprType, typename Arg2XprType, typename Arg3XprType> class TensorCwiseTernaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:47:template<typename IfXprType, typename ThenXprType, typename ElseXprType> class TensorSelectOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:48:template<typename Op, typename Dims, typename XprType, template <class> class MakePointer_ = MakePointer > class TensorReductionOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:49:template<typename XprType> class TensorIndexTupleOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:50:template<typename ReduceOp, typename Dims, typename XprType> class TensorTupleReducerOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:51:template<typename Axis, typename LeftXprType, typename RightXprType> class TensorConcatenationOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:52:template<typename Dimensions, typename LeftXprType, typename RightXprType> class TensorContractionOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:53:template<typename TargetType, typename XprType> class TensorConversionOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:54:template<typename Dimensions, typename InputXprType, typename KernelXprType> class TensorConvolutionOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:55:template<typename FFT, typename XprType, int FFTDataType, int FFTDirection> class TensorFFTOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:56:template<typename PatchDim, typename XprType> class TensorPatchOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:57:template<DenseIndex Rows, DenseIndex Cols, typename XprType> class TensorImagePatchOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:58:template<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, typename XprType> class TensorVolumePatchOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:59:template<typename Broadcast, typename XprType> class TensorBroadcastingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:60:template<DenseIndex DimId, typename XprType> class TensorChippingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:61:template<typename NewDimensions, typename XprType> class TensorReshapingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:62:template<typename XprType> class TensorLayoutSwapOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:63:template<typename StartIndices, typename Sizes, typename XprType> class TensorSlicingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:64:template<typename ReverseDimensions, typename XprType> class TensorReverseOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:65:template<typename PaddingDimensions, typename XprType> class TensorPaddingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:66:template<typename Shuffle, typename XprType> class TensorShufflingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:67:template<typename Strides, typename XprType> class TensorStridingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:68:template<typename StartIndices, typename StopIndices, typename Strides, typename XprType> class TensorStridingSlicingOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:69:template<typename Strides, typename XprType> class TensorInflationOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:70:template<typename Generator, typename XprType> class TensorGeneratorOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:71:template<typename LeftXprType, typename RightXprType> class TensorAssignOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:72:template<typename Op, typename XprType> class TensorScanOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:74:template<typename CustomUnaryFunc, typename XprType> class TensorCustomUnaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:75:template<typename CustomBinaryFunc, typename LhsXprType, typename RhsXprType> class TensorCustomBinaryOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:77:template<typename XprType, template <class> class MakePointer_ = MakePointer> class TensorEvalToOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:78:template<typename XprType> class TensorForcedEvalOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:80:template<typename ExpressionType, typename DeviceType> class TensorDevice;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:81:template<typename Derived, typename Device> struct TensorEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:104:  static const bool value = TensorEvaluator<Expression, Device>::PacketAccess;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:109:  static const bool value = TensorEvaluator<Expression, GpuDevice>::PacketAccess &&
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:110:                            TensorEvaluator<Expression, GpuDevice>::IsAligned;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h:115:class TensorExecutor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:14: * TensorSyclPlaceHolderExpr.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:30:/// \brief PlaceHolder is used to replace the \ref TensorMap in the expression
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:41:/// expression is a copy of expression type in which the TensorMap of the has
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:87:/// TensorCwiseNullaryOp, TensorCwiseUnaryOp, TensorBroadcastingOp, TensorCwiseBinaryOp,  TensorCwiseTernaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:99:/// TensorCwiseSelectOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:102:struct PlaceHolderExpression<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:103:  typedef CVQual typename CategoryHelper<TensorSelectOp, NoOP, typename CalculateIndex<N, IfExpr, ThenExpr, ElseExpr>::ArgsTuple>::Type Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:111:/// TensorAssignOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:114:struct PlaceHolderExpression<CVQual TensorAssignOp<LHSExpr, RHSExpr>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:115:  typedef CVQual typename CategoryHelper<TensorAssignOp, NoOP, typename CalculateIndex<N, LHSExpr, RHSExpr>::ArgsTuple>::Type Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:123:/// TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:126:struct PlaceHolderExpression< CVQual TensorMap< T, Options_, MakePointer_>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:127:  typedef CVQual PlaceHolder<CVQual TensorMap<T, Options_, MakePointer_>, N> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:135:/// TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:138:struct PlaceHolderExpression<CVQual TensorForcedEvalOp<Expr>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:139:  typedef CVQual PlaceHolder<CVQual TensorForcedEvalOp<Expr>, N> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:148:/// TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:151:struct PlaceHolderExpression<CVQual TensorCustomUnaryOp<CustomUnaryFunc, XprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:152:  typedef CVQual PlaceHolder<CVQual TensorCustomUnaryOp<CustomUnaryFunc, XprType>, N> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:161:/// TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:164:struct PlaceHolderExpression<CVQual TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:165:  typedef CVQual PlaceHolder<CVQual TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, N> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:174:/// TensoroOp, TensorLayoutSwapOp, and TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:181:// TensorEvalToOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:182:EVALTOLAYOUTSWAPINDEXTUPLE(const, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:183:EVALTOLAYOUTSWAPINDEXTUPLE(, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:184://TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:185:EVALTOLAYOUTSWAPINDEXTUPLE(const, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:186:EVALTOLAYOUTSWAPINDEXTUPLE(, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:187://TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:188:EVALTOLAYOUTSWAPINDEXTUPLE(const, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:189:EVALTOLAYOUTSWAPINDEXTUPLE(, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:195:/// TensorChippingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:198:struct PlaceHolderExpression<CVQual TensorChippingOp<DimId, Expr>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:199:  typedef CVQual TensorChippingOp< DimId, typename CalculateIndex <N, Expr>::ArgType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:207:/// TensorReductionOp and TensorTupleReducerOp (Argmax)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:215:SYCLREDUCTION(const, TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:216:SYCLREDUCTION(, TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:218:// tensor Argmax -TensorTupleReducerOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:219:SYCLREDUCTION(const, TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:220:SYCLREDUCTION(, TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:226:/// TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:232:SYCLCONTRACTIONCONVOLUTIONPLH(const, TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:233:SYCLCONTRACTIONCONVOLUTIONPLH(,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:234:SYCLCONTRACTIONCONVOLUTIONPLH(const, TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:235:SYCLCONTRACTIONCONVOLUTIONPLH(,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:240:/// TensorCwiseSelectOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:243:struct PlaceHolderExpression<CVQual TensorSlicingOp<StartIndices, Sizes, XprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:244:  typedef CVQual TensorSlicingOp<StartIndices, Sizes, typename CalculateIndex<N, XprType>::ArgType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:254:struct PlaceHolderExpression<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:255:  typedef CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, typename CalculateIndex<N, XprType>::ArgType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:265:/// TensorImagePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:268:struct PlaceHolderExpression<CVQual TensorImagePatchOp<Rows, Cols, XprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:269:  typedef CVQual TensorImagePatchOp<Rows, Cols, typename CalculateIndex <N, XprType>::ArgType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:279:/// TensorVolumePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:282:struct PlaceHolderExpression<CVQual TensorVolumePatchOp<Planes,Rows, Cols, XprType>, N> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:283:  typedef CVQual TensorVolumePatchOp<Planes,Rows, Cols, typename CalculateIndex <N, XprType>::ArgType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h:299:}  // TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:15:/** \class TensorShuffling
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:18:  * \brief Tensor shuffling class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:24:struct traits<TensorShufflingOp<Shuffle, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:37:struct eval<TensorShufflingOp<Shuffle, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:39:  typedef const TensorShufflingOp<Shuffle, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:43:struct nested<TensorShufflingOp<Shuffle, XprType>, 1, typename eval<TensorShufflingOp<Shuffle, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:45:  typedef TensorShufflingOp<Shuffle, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:53:class TensorShufflingOp : public TensorBase<TensorShufflingOp<Shuffle, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:56:  typedef typename Eigen::internal::traits<TensorShufflingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:59:  typedef typename Eigen::internal::nested<TensorShufflingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:60:  typedef typename Eigen::internal::traits<TensorShufflingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:61:  typedef typename Eigen::internal::traits<TensorShufflingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorShufflingOp(const XprType& expr, const Shuffle& shuffle)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:74:    EIGEN_STRONG_INLINE TensorShufflingOp& operator = (const TensorShufflingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:76:      typedef TensorAssignOp<TensorShufflingOp, const TensorShufflingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:78:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:84:    EIGEN_STRONG_INLINE TensorShufflingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:86:      typedef TensorAssignOp<TensorShufflingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:88:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:100:struct TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:102:  typedef TensorShufflingOp<Shuffle, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:104:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:114:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:119:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:122:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:180:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:181:    const double compute_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:182:                                           2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:183:                                           TensorOpCost::DivCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:185:           TensorOpCost(0, 0, compute_cost, false /* vectorized */, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:193:  EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const {return m_impl;}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:217:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:225:struct TensorEvaluator<TensorShufflingOp<Shuffle, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:226:    : public TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:228:  typedef TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:230:  typedef TensorShufflingOp<Shuffle, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:232:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h:245:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:60:struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, ThreadPoolDevice> :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:61:    public TensorContractionEvaluatorBase<TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, ThreadPoolDevice> > {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:65:  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:66:  typedef TensorContractionEvaluatorBase<Self> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:68:  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:75:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:88:      internal::array_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:90:      internal::array_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:109:  typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:110:  typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:112:  TensorEvaluator(const XprType& op, const Device& device) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:128:      internal::TensorXsmmContractionBlocking<LhsScalar, RhsScalar, Index>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:148:    typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:149:    typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:150:    typedef internal::TensorContractionInputMapper<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:155:    typedef internal::TensorContractionInputMapper<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:203:      internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:210:      internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:222:    const TensorOpCost cost =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:224:    int num_threads = TensorCostModel<ThreadPoolDevice>::numThreads(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:247:      internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:254:      internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:722:    const TensorOpCost cost =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:724:    double taskSize = TensorCostModel<ThreadPoolDevice>::taskSize(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:779:    typedef internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:785:    typedef internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:816:    internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index, internal::ShardByCol> blocking(k, m, n, num_threads);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1027:  TensorOpCost contractionCost(Index m, Index n, Index bm, Index bn, Index bk,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1046:    TensorOpCost cost = TensorOpCost(0, 0, kd * computeBandwidth, true, packed_size);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1048:    cost += TensorOpCost(0, sizeof(CoeffReturnType), 0, true, output_packet_size);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1056:    TensorOpCost lhsCost = this->m_leftImpl.costPerCoeff(true) * (kd / n);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1057:    TensorOpCost rhsCost = this->m_rightImpl.costPerCoeff(true) * (kd / m);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h:1072:                const internal::TensorXsmmContractionBlocking<LhsScalar,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:15:/** \class TensorForcedEval
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:18:  * \brief Tensor reshaping class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:24:struct traits<TensorEvalToOp<XprType, MakePointer_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:51:struct eval<TensorEvalToOp<XprType, MakePointer_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:53:  typedef const TensorEvalToOp<XprType, MakePointer_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:57:struct nested<TensorEvalToOp<XprType, MakePointer_>, 1, typename eval<TensorEvalToOp<XprType, MakePointer_> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:59:  typedef TensorEvalToOp<XprType, MakePointer_> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:68:class TensorEvalToOp : public TensorBase<TensorEvalToOp<XprType, MakePointer_>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:71:  typedef typename Eigen::internal::traits<TensorEvalToOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:75:  typedef typename Eigen::internal::nested<TensorEvalToOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:76:  typedef typename Eigen::internal::traits<TensorEvalToOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:77:  typedef typename Eigen::internal::traits<TensorEvalToOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:79:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvalToOp(PointerType buffer, const XprType& expr)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:96:struct TensorEvaluator<const TensorEvalToOp<ArgType, MakePointer_>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:98:  typedef TensorEvalToOp<ArgType, MakePointer_> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:100:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:107:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:108:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:109:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:114:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:119:  // Used for accessor extraction in SYCL Managed TensorMap:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:124:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~TensorEvaluator() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:127:  typedef typename internal::traits<const TensorEvalToOp<ArgType, MakePointer_> >::template MakePointer<CoeffReturnType>::Type DevicePointer;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:140:    internal::pstoret<CoeffReturnType, PacketReturnType, Aligned>(m_buffer + i, m_impl.template packet<TensorEvaluator<ArgType, Device>::IsAligned ? Aligned : Unaligned>(i));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:158:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:162:        TensorOpCost(0, sizeof(CoeffReturnType), 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:169:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h:174:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:15:/** \class TensorFixedSize
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:21:  * Eigen::Tensor<float, 3> t(3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:23:  * Eigen::TensorFixedSize<float, Sizes<3,5,7>> t;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:27:class TensorFixedSize : public TensorBase<TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:30:    typedef TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:31:    typedef TensorBase<TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> > Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:52:  TensorStorage<Scalar, Dimensions, Options> m_storage;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:301:    EIGEN_STRONG_INLINE TensorFixedSize()
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:307:    EIGEN_STRONG_INLINE TensorFixedSize(const Self& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:313:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorFixedSize(Self&& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:321:    EIGEN_STRONG_INLINE TensorFixedSize(const TensorBase<OtherDerived, ReadOnlyAccessors>& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:323:      typedef TensorAssignOp<TensorFixedSize, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:325:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:329:    EIGEN_STRONG_INLINE TensorFixedSize(const TensorBase<OtherDerived, WriteAccessors>& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:331:      typedef TensorAssignOp<TensorFixedSize, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:333:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:337:    EIGEN_STRONG_INLINE TensorFixedSize& operator=(const TensorFixedSize& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:341:      typedef TensorAssignOp<Self, const TensorFixedSize> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:343:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:348:    EIGEN_STRONG_INLINE TensorFixedSize& operator=(const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:352:      typedef TensorAssignOp<Self, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h:354:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:13:// General include header of SYCL target for Tensor Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:35:  template<typename StrideDims, typename XprType> class TensorTupleReducerDeviceOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:36:  template<typename StrideDims, typename ArgType> struct TensorEvaluator<const TensorTupleReducerDeviceOp<StrideDims, ArgType>, SyclKernelDevice>;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:37:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:65:#include "TensorSyclTuple.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:68:#include "TensorSyclLeafCount.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:74:#include "TensorSyclPlaceHolderExpr.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:77:#include "TensorSyclExtractAccessor.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:80:#include "TensorSyclConvertToDeviceExpression.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:83:#include "TensorSyclExtractFunctors.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:87:#include "TensorSyclExprConstructor.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:90:#include "TensorReductionSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:92:// TensorArgMaxSycl.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:93:#include "TensorArgMaxSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:96:#include "TensorConvolutionSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:99:#include "TensorSyclRun.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:101:#include "TensorSyclFunctors.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h:103:#include "TensorContractionSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:17:/** \class TensorIndexTuple
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:18:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:20:  * \brief Tensor + Index Tuple class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:25:struct traits<TensorIndexTupleOp<XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:38:struct eval<TensorIndexTupleOp<XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:40:  typedef const TensorIndexTupleOp<XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:44:struct nested<TensorIndexTupleOp<XprType>, 1,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:45:              typename eval<TensorIndexTupleOp<XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:47:  typedef TensorIndexTupleOp<XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:53:class TensorIndexTupleOp : public TensorBase<TensorIndexTupleOp<XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:56:  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:58:  typedef typename Eigen::internal::nested<TensorIndexTupleOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:59:  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:60:  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIndexTupleOp(const XprType& expr)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:76:struct TensorEvaluator<const TensorIndexTupleOp<ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:78:  typedef TensorIndexTupleOp<ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:83:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:87:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/ false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:88:    PacketAccess = /*TensorEvaluator<ArgType, Device>::PacketAccess*/ false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:90:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:95:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:115:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:117:    return m_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, 1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:123:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:129:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:134:/** \class TensorTupleIndex
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:135:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:137:  * \brief Converts to Tensor<Tuple<Index, Scalar> > and reduces to Tensor<Index>.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:141:struct traits<TensorTupleReducerOp<ReduceOp, Dims, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:154:struct eval<TensorTupleReducerOp<ReduceOp, Dims, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:156:  typedef const TensorTupleReducerOp<ReduceOp, Dims, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:160:struct nested<TensorTupleReducerOp<ReduceOp, Dims, XprType>, 1,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:161:              typename eval<TensorTupleReducerOp<ReduceOp, Dims, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:163:  typedef TensorTupleReducerOp<ReduceOp, Dims, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:169:class TensorTupleReducerOp : public TensorBase<TensorTupleReducerOp<ReduceOp, Dims, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:172:  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:174:  typedef typename Eigen::internal::nested<TensorTupleReducerOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:175:  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:176:  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:179:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorTupleReducerOp(const XprType& expr,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:207:struct TensorEvaluator<const TensorTupleReducerOp<ReduceOp, Dims, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:209:  typedef TensorTupleReducerOp<ReduceOp, Dims, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:213:  typedef typename TensorIndexTupleOp<ArgType>::CoeffReturnType TupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:214:  typedef typename TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:215:  typedef typename TensorEvaluator<const TensorIndexTupleOp<ArgType> , Device>::Dimensions InputDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:220:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/ false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:221:    PacketAccess = /*TensorEvaluator<ArgType, Device>::PacketAccess*/ false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:223:    Layout = TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:228:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:276:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:279:        (m_return_dim < 0 ? 0.0 : (TensorOpCost::ModCost<Index>() + TensorOpCost::DivCost<Index>()));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:281:           m_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, compute_cost);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:308:  TensorEvaluator<const TensorIndexTupleOp<ArgType>, Device> m_orig_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h:309:  TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:48:struct traits<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:68:struct traits<TensorFixedSize<Scalar_, Dimensions, Options_, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:88:struct traits<TensorMap<PlainObjectType, Options_, MakePointer_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:111:struct traits<TensorRef<PlainObjectType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:128:struct eval<Tensor<_Scalar, NumIndices_, Options, IndexType_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:130:  typedef const Tensor<_Scalar, NumIndices_, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:134:struct eval<const Tensor<_Scalar, NumIndices_, Options, IndexType_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:136:  typedef const Tensor<_Scalar, NumIndices_, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:140:struct eval<TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:142:  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:146:struct eval<const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:148:  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:152:struct eval<TensorMap<PlainObjectType, Options, MakePointer>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:154:  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:158:struct eval<const TensorMap<PlainObjectType, Options, MakePointer>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:160:  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:164:struct eval<TensorRef<PlainObjectType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:166:  typedef const TensorRef<PlainObjectType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:170:struct eval<const TensorRef<PlainObjectType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:172:  typedef const TensorRef<PlainObjectType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:182:struct nested<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:184:  typedef const Tensor<Scalar_, NumIndices_, Options_, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:188:struct nested<const Tensor<Scalar_, NumIndices_, Options_, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:190:  typedef const Tensor<Scalar_, NumIndices_, Options_, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:194:struct nested<TensorFixedSize<Scalar_, Dimensions, Options, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:196:  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:200:struct nested<const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:202:  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:207:struct nested<TensorMap<PlainObjectType, Options, MakePointer> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:209:  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:213:struct nested<const TensorMap<PlainObjectType, Options, MakePointer> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:215:  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:219:struct nested<TensorRef<PlainObjectType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:221:  typedef const TensorRef<PlainObjectType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:225:struct nested<const TensorRef<PlainObjectType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h:227:  typedef const TensorRef<PlainObjectType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:33:struct TensorUInt128
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:40:  TensorUInt128(const TensorUInt128<OTHER_HIGH, OTHER_LOW>& other) : high(other.high), low(other.low) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:47:  TensorUInt128& operator = (const TensorUInt128<OTHER_HIGH, OTHER_LOW>& other) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:57:  explicit TensorUInt128(const T& x) : high(0), low(x) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:63:  TensorUInt128(HIGH y, LOW x) : high(y), low(x) { }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:79:bool operator == (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:86:bool operator != (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:93:bool operator >= (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:103:bool operator < (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:113:TensorUInt128<uint64_t, uint64_t> operator + (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:115:  TensorUInt128<uint64_t, uint64_t> result(lhs.high + rhs.high, lhs.low + rhs.low);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:124:TensorUInt128<uint64_t, uint64_t> operator - (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:126:  TensorUInt128<uint64_t, uint64_t> result(lhs.high - rhs.high, lhs.low - rhs.low);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:136:TensorUInt128<uint64_t, uint64_t> operator * (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:206:  return TensorUInt128<uint64_t, uint64_t>(high, low);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:211:TensorUInt128<uint64_t, uint64_t> operator / (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:213:  if (rhs == TensorUInt128<static_val<0>, static_val<1> >(1)) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:214:    return TensorUInt128<uint64_t, uint64_t>(lhs.high, lhs.low);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:216:    return TensorUInt128<uint64_t, uint64_t>(0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:219:    TensorUInt128<uint64_t, uint64_t> power2(1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:220:    TensorUInt128<uint64_t, uint64_t> d(rhs);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:221:    TensorUInt128<uint64_t, uint64_t> tmp(lhs - d);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:228:    tmp = TensorUInt128<uint64_t, uint64_t>(lhs.high, lhs.low);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:229:    TensorUInt128<uint64_t, uint64_t> result(0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:230:    while (power2 != TensorUInt128<static_val<0>, static_val<0> >(0)) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:236:      power2 = TensorUInt128<uint64_t, uint64_t>(power2.high >> 1, (power2.low >> 1) | (power2.high << 63));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h:237:      d = TensorUInt128<uint64_t, uint64_t>(d.high >> 1, (d.low >> 1) | (d.high << 63));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:9:/** \class TensorVolumePatch
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:10:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:26:struct traits<TensorVolumePatchOp<Planes, Rows, Cols, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:39:struct eval<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:41:  typedef const TensorVolumePatchOp<Planes, Rows, Cols, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:45:struct nested<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, 1, typename eval<TensorVolumePatchOp<Planes, Rows, Cols, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:47:  typedef TensorVolumePatchOp<Planes, Rows, Cols, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:53:class TensorVolumePatchOp : public TensorBase<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:56:  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:59:  typedef typename Eigen::internal::nested<TensorVolumePatchOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:60:  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:61:  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorVolumePatchOp(const XprType& expr, DenseIndex patch_planes, DenseIndex patch_rows, DenseIndex patch_cols,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:75:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorVolumePatchOp(const XprType& expr, DenseIndex patch_planes, DenseIndex patch_rows, DenseIndex patch_cols,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:166:struct TensorEvaluator<const TensorVolumePatchOp<Planes, Rows, Cols, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:168:  typedef TensorVolumePatchOp<Planes, Rows, Cols, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:170:  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:180:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:182:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:187:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator( const XprType op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:189:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator( const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:201:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:331:    m_fastOtherStride = internal::TensorIntDivisor<Index>(m_otherStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:333:    m_fastPatchStride = internal::TensorIntDivisor<Index>(m_patchStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:334:    m_fastColStride = internal::TensorIntDivisor<Index>(m_colStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:335:    m_fastRowStride = internal::TensorIntDivisor<Index>(m_rowStride);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:336:    m_fastInputRowStride = internal::TensorIntDivisor<Index>(m_row_inflate_strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:337:    m_fastInputColStride = internal::TensorIntDivisor<Index>(m_col_inflate_strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:338:    m_fastInputPlaneStride = internal::TensorIntDivisor<Index>(m_plane_inflate_strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:339:    m_fastInputColsEff = internal::TensorIntDivisor<Index>(m_input_cols_eff);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:340:    m_fastOutputPlanes = internal::TensorIntDivisor<Index>(m_outputPlanes);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:341:    m_fastOutputPlanesRows = internal::TensorIntDivisor<Index>(m_outputPlanesRows);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:344:      m_fastOutputDepth = internal::TensorIntDivisor<Index>(m_dimensions[0]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:346:      m_fastOutputDepth = internal::TensorIntDivisor<Index>(m_dimensions[NumDims-1]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:504:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:507:        10 * TensorOpCost::DivCost<Index>() + 21 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:508:        8 * TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:509:    return TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:514:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:599:  internal::TensorIntDivisor<Index> m_fastOtherStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:600:  internal::TensorIntDivisor<Index> m_fastPatchStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:601:  internal::TensorIntDivisor<Index> m_fastColStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:602:  internal::TensorIntDivisor<Index> m_fastRowStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:603:  internal::TensorIntDivisor<Index> m_fastInputPlaneStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:604:  internal::TensorIntDivisor<Index> m_fastInputRowStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:605:  internal::TensorIntDivisor<Index> m_fastInputColStride;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:606:  internal::TensorIntDivisor<Index> m_fastInputColsEff;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:607:  internal::TensorIntDivisor<Index> m_fastOutputPlanesRows;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:608:  internal::TensorIntDivisor<Index> m_fastOutputPlanes;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:609:  internal::TensorIntDivisor<Index> m_fastOutputDepth;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h:613:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:15:/** \class TensorConcatenationOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:18:  * \brief Tensor concatenation class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:24:struct traits<TensorConcatenationOp<Axis, LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:43:struct eval<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:45:  typedef const TensorConcatenationOp<Axis, LhsXprType, RhsXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:49:struct nested<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, 1, typename eval<TensorConcatenationOp<Axis, LhsXprType, RhsXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:51:  typedef TensorConcatenationOp<Axis, LhsXprType, RhsXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:58:class TensorConcatenationOp : public TensorBase<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, WriteAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:61:    typedef typename internal::traits<TensorConcatenationOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:62:    typedef typename internal::traits<TensorConcatenationOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:63:    typedef typename internal::traits<TensorConcatenationOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:64:    typedef typename internal::nested<TensorConcatenationOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:69:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConcatenationOp(const LhsXprType& lhs, const RhsXprType& rhs, Axis axis)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:83:    EIGEN_STRONG_INLINE TensorConcatenationOp& operator = (const TensorConcatenationOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:85:      typedef TensorAssignOp<TensorConcatenationOp, const TensorConcatenationOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:87:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:93:    EIGEN_STRONG_INLINE TensorConcatenationOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:95:      typedef TensorAssignOp<TensorConcatenationOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:97:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:110:struct TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:112:  typedef TensorConcatenationOp<Axis, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:114:  static const int NumDims = internal::array_size<typename TensorEvaluator<LeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:115:  static const int RightNumDims = internal::array_size<typename TensorEvaluator<RightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:122:    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:123:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:127:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:130:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<LeftArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<RightArgType, Device>::Layout) || NumDims == 1), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:263:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:265:    const double compute_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:266:                                           2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:267:                                           TensorOpCost::DivCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:268:                                           TensorOpCost::ModCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:275:           TensorOpCost(0, 0, compute_cost);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:280:  const TensorEvaluator<LeftArgType, Device>& left_impl() const { return m_leftImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:282:  const TensorEvaluator<RightArgType, Device>& right_impl() const { return m_rightImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:291:    TensorEvaluator<LeftArgType, Device> m_leftImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:292:    TensorEvaluator<RightArgType, Device> m_rightImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:298:  struct TensorEvaluator<TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:299:  : public TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:301:  typedef TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:302:  typedef TensorConcatenationOp<Axis, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:306:    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:307:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h:311:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:16:/** \class Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:17:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:21:  * The %Tensor class is the work-horse for all \em dense tensors within Eigen.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:23:  * The %Tensor class encompasses only dynamic-size objects so far.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:40:  * Eigen::Tensor<double, 4> t(10, 10, 10, 10);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:53:  * by providing .asMatrix() and .asVector() (or similar) methods for rank 2 and 1 tensors. However, currently, the %Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:63:class Tensor : public TensorBase<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:66:    typedef Tensor<Scalar_, NumIndices_, Options_, IndexType_> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:67:    typedef TensorBase<Tensor<Scalar_, NumIndices_, Options_, IndexType_> > Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:87:    TensorStorage<Scalar, Dimensions, Options> m_storage;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:328:    EIGEN_STRONG_INLINE Tensor()
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:334:    EIGEN_STRONG_INLINE Tensor(const Self& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:341:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index firstDimension, IndexTypes... otherDimensions)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:348:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit Tensor(Index dim1)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:353:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:358:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:363:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:368:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4, Index dim5)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:376:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit Tensor(const array<Index, NumIndices>& dimensions)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:384:    EIGEN_STRONG_INLINE Tensor(const TensorBase<OtherDerived, ReadOnlyAccessors>& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:386:      typedef TensorAssignOp<Tensor, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:388:      resize(TensorEvaluator<const Assign, DefaultDevice>(assign, DefaultDevice()).dimensions());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:389:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:393:    EIGEN_STRONG_INLINE Tensor(const TensorBase<OtherDerived, WriteAccessors>& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:395:      typedef TensorAssignOp<Tensor, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:397:      resize(TensorEvaluator<const Assign, DefaultDevice>(assign, DefaultDevice()).dimensions());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:398:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:402:    EIGEN_STRONG_INLINE Tensor& operator=(const Tensor& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:404:      typedef TensorAssignOp<Tensor, const Tensor> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:406:      resize(TensorEvaluator<const Assign, DefaultDevice>(assign, DefaultDevice()).dimensions());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:407:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:412:    EIGEN_STRONG_INLINE Tensor& operator=(const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:414:      typedef TensorAssignOp<Tensor, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:416:      resize(TensorEvaluator<const Assign, DefaultDevice>(assign, DefaultDevice()).dimensions());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/Tensor.h:417:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:20:/** \class TensorConvolution
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:21:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:23:  * \brief Tensor convolution class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:30:typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:46:    typedef typename TensorSycl::internal::ConvertToDeviceExpression<HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:47:    auto device_expr =TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors, tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:48:    auto device_evaluator = Eigen::TensorEvaluator<DevExpr, Eigen::SyclKernelDevice>(device_expr.expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:56:    const size_t plane_tensor_offset =indexMapper.mapCudaInputPlaneToTensorInputOffset(itemID.get_global(1));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:60:      const size_t tensor_index  =  plane_tensor_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i + first_input_start);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:77:      const size_t tensor_index = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(itemID.get_global(1))
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:78:      +indexMapper.mapCudaOutputKernelToTensorOutputOffset(itemID.get_local(0) + first_output_start);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:88:typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:104:    typedef typename TensorSycl::internal::ConvertToDeviceExpression<HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:105:    auto device_expr =TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors, tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:106:    auto device_evaluator = Eigen::TensorEvaluator<DevExpr, Eigen::SyclKernelDevice>(device_expr.expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:112:    const size_t plane_input_offset = indexMapper.mapCudaInputPlaneToTensorInputOffset(itemID.get_global(2));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:122:        const size_t tensor_index  = plane_input_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i + first_x_input_start, j+ first_y_input_start );
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:144:      const size_t tensor_index = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(itemID.get_global(2))
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:145:      +indexMapper.mapCudaOutputKernelToTensorOutputOffset(itemID.get_local(0) + fitst_x_output_start, itemID.get_local(1) + fitst_y_output_start);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:156:typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:174:    typedef typename TensorSycl::internal::ConvertToDeviceExpression<HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:175:    auto device_expr =TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors, tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:176:    auto device_evaluator = Eigen::TensorEvaluator<DevExpr, Eigen::SyclKernelDevice>(device_expr.expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:188:      const size_t plane_input_offset = indexMapper.mapCudaInputPlaneToTensorInputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:193:            const size_t tensor_index  = plane_input_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i + first_x_input_start, j+ first_y_input_start , k+ first_z_input_start );
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:219:        const size_t tensor_index = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(p)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:220:        +indexMapper.mapCudaOutputKernelToTensorOutputOffset(itemID.get_local(0) + fitst_x_output_start, itemID.get_local(1) + fitst_y_output_start, itemID.get_local(2) + fitst_z_output_start );
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:231:struct TensorEvaluator<const TensorConvolutionOp<Indices, InputArgType, KernelArgType>, const Eigen::SyclDevice>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:233:  typedef TensorConvolutionOp<Indices, InputArgType, KernelArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:235:  static const int NumDims =  internal::array_size<typename TensorEvaluator<InputArgType, const Eigen::SyclDevice>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:239:  typedef typename TensorEvaluator<KernelArgType, const Eigen::SyclDevice>::Dimensions KernelDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:243:    IsAligned = TensorEvaluator<InputArgType, const Eigen::SyclDevice>::IsAligned & TensorEvaluator<KernelArgType, const Eigen::SyclDevice>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:245:    Layout = TensorEvaluator<InputArgType, const Eigen::SyclDevice>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:250:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Eigen::SyclDevice& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:253:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<InputArgType, const Eigen::SyclDevice>::Layout) == static_cast<int>(TensorEvaluator<KernelArgType, const Eigen::SyclDevice>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:255:    const typename TensorEvaluator<InputArgType, const Eigen::SyclDevice>::Dimensions& input_dims = m_inputImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:256:    const typename TensorEvaluator<KernelArgType, const Eigen::SyclDevice>::Dimensions& kernel_dims = m_kernelImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:315:      typedef TensorEvalToOp<const KernelArgType> EvalTo;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:318:      internal::TensorExecutor<const EvalTo, const Eigen::SyclDevice, PacketAccess>::run(evalToTmp, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:325:    typedef TensorEvaluator<InputArgType, const Eigen::SyclDevice> InputEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:328:    typedef Eigen::TensorSycl::internal::FunctorExtractor<InputEvaluator> InputFunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:330:    InputFunctorExpr input_functors = Eigen::TensorSycl::internal::extractFunctors(m_inputImpl);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:338:      typedef decltype(Eigen::TensorSycl::internal::createTupleOfAccessors<InputEvaluator>(cgh, m_inputImpl)) InputTupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:340:      InputTupleType tuple_of_accessors = Eigen::TensorSycl::internal::createTupleOfAccessors<InputEvaluator>(cgh, m_inputImpl);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:446:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:453:        TensorOpCost::AddCost<Scalar>() + TensorOpCost::MulCost<Scalar>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:456:        (2 * TensorOpCost::AddCost<Index>() + 2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:457:         TensorOpCost::DivCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:458:    return TensorOpCost(0, 0, firstIndex_compute_cost, vectorized, PacketSize) +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:461:                          TensorOpCost(0, 0, convolve_compute_cost, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:467:  TensorEvaluator& operator = (const TensorEvaluator&);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:468:  TensorEvaluator<InputArgType, const Eigen::SyclDevice> m_inputImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolutionSycl.h:470:  TensorEvaluator<KernelArgType, const Eigen::SyclDevice> m_kernelImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:14: * TensorTensorContractionsycl.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:17: *  TensorContractionsycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:27:struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, const Eigen::SyclDevice> :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:28:    public TensorContractionEvaluatorBase<TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, const Eigen::SyclDevice> > {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:32:  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:33:  typedef TensorContractionEvaluatorBase<Self> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:34:  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:41:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:54:      internal::array_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:56:      internal::array_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:74:  typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:75:  typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:80:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:154:  const TensorEvaluator<LeftArgType, Device>& left_impl() const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:158:  const TensorEvaluator<RightArgType, Device>& right_impl() const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:169:  typedef typename Eigen::TensorSycl::internal::createPlaceHolderExpression<LHSHostExpr>::Type LHSPlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:170:  typedef typename Eigen::TensorSycl::internal::createPlaceHolderExpression<RHSHostExpr>::Type RHSPlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:199:      typedef typename Eigen::TensorSycl::internal::ConvertToDeviceExpression<HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:200:      typedef typename Eigen::TensorSycl::internal::ConvertToDeviceExpression<LHSHostExpr>::Type LHSDevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:201:      typedef typename Eigen::TensorSycl::internal::ConvertToDeviceExpression<RHSHostExpr>::Type RHSDevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:202:      auto lhs_dev_expr = Eigen::TensorSycl::internal::createDeviceExpression<LHSDevExpr, LHSPlaceHolderExpr>(lhs_functors, left_tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:203:      auto rhs_dev_expr = Eigen::TensorSycl::internal::createDeviceExpression<RHSDevExpr, RHSPlaceHolderExpr>(rhs_functors, right_tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:208:      typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:209:      typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:210:      typedef internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:216:      typedef internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:354:    typedef TensorEvaluator<LHSHostExpr, const Eigen::SyclDevice> OrigLHSExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:355:    typedef TensorEvaluator<RHSHostExpr, const Eigen::SyclDevice> OrigRHSExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:356:    typedef Eigen::TensorSycl::internal::FunctorExtractor<OrigLHSExpr> LHSFunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:357:    typedef Eigen::TensorSycl::internal::FunctorExtractor<OrigRHSExpr> RHSFunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:359:    LHSFunctorExpr lhs_functors = Eigen::TensorSycl::internal::extractFunctors(self.left_impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:361:    RHSFunctorExpr rhs_functors = Eigen::TensorSycl::internal::extractFunctors(self.right_impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:369:      typedef decltype(Eigen::TensorSycl::internal::createTupleOfAccessors<OrigLHSExpr>(cgh, self.left_impl())) LHSTupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:371:      typedef decltype(Eigen::TensorSycl::internal::createTupleOfAccessors<OrigRHSExpr>(cgh, self.right_impl())) RHSTupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:373:      LHSTupleType left_tuple_of_accessors = Eigen::TensorSycl::internal::createTupleOfAccessors<OrigLHSExpr>(cgh, self.left_impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionSycl.h:375:      RHSTupleType right_tuple_of_accessors = Eigen::TensorSycl::internal::createTupleOfAccessors<OrigRHSExpr>(cgh, self.right_impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:15:/** \class TensorCustomUnaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:18:  * \brief Tensor custom class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:24:struct traits<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:36:struct eval<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:38:  typedef const TensorCustomUnaryOp<CustomUnaryFunc, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:42:struct nested<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:44:  typedef TensorCustomUnaryOp<CustomUnaryFunc, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:52:class TensorCustomUnaryOp : public TensorBase<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:55:  typedef typename internal::traits<TensorCustomUnaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:58:  typedef typename internal::nested<TensorCustomUnaryOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:59:  typedef typename internal::traits<TensorCustomUnaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:60:  typedef typename internal::traits<TensorCustomUnaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:62:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCustomUnaryOp(const XprType& expr, const CustomUnaryFunc& func)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:80:struct TensorEvaluator<const TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:82:  typedef TensorCustomUnaryOp<CustomUnaryFunc, XprType> ArgType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:95:    Layout = TensorEvaluator<XprType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:100:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const ArgType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:136:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:138:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:149:    TensorMap<Tensor<CoeffReturnType, NumDims, Layout, Index> > result(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:162:/** \class TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:163:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:165:  * \brief Tensor custom class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:171:struct traits<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:190:struct eval<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:192:  typedef const TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:196:struct nested<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:198:  typedef TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:206:class TensorCustomBinaryOp : public TensorBase<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:209:  typedef typename internal::traits<TensorCustomBinaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:211:  typedef typename internal::traits<TensorCustomBinaryOp>::CoeffReturnType CoeffReturnType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:212:  typedef typename internal::nested<TensorCustomBinaryOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:213:  typedef typename internal::traits<TensorCustomBinaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:214:  typedef typename internal::traits<TensorCustomBinaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:216:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCustomBinaryOp(const LhsXprType& lhs, const RhsXprType& rhs, const CustomBinaryFunc& func)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:240:struct TensorEvaluator<const TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:242:  typedef TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:255:    Layout = TensorEvaluator<LhsXprType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:260:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:295:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:297:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h:308:    TensorMap<Tensor<Scalar, NumDims, Layout> > result(data, m_dimensions);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:24:  * \class TensorStorage
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:25:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:32:  * \sa Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:34:template<typename T, typename Dimensions, int Options> class TensorStorage;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:39:class TensorStorage
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:52:  EIGEN_STRONG_INLINE TensorStorage() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:70:class TensorStorage<T, DSizes<IndexType, NumIndices_>, Options_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:75:    typedef TensorStorage<T, DSizes<IndexType, NumIndices_>, Options_> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:77:    EIGEN_DEVICE_FUNC TensorStorage() : m_data(0), m_dimensions() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:82:    EIGEN_DEVICE_FUNC TensorStorage(internal::constructor_without_unaligned_array_assert)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:84:    EIGEN_DEVICE_FUNC TensorStorage(Index size, const array<Index, NumIndices_>& dimensions)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:90:    EIGEN_DEVICE_FUNC TensorStorage(DenseIndex... indices) : m_dimensions(indices...) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:95:    EIGEN_DEVICE_FUNC TensorStorage(const Self& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h:110:    EIGEN_DEVICE_FUNC  ~TensorStorage() { internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, internal::array_prod(m_dimensions)); }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h:17:  * \class TensorDimensionList
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h:18:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h:22:  * \sa Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:15:/** \class TensorBroadcasting
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:18:  * \brief Tensor broadcasting class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:24:struct traits<TensorBroadcastingOp<Broadcast, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:37:struct eval<TensorBroadcastingOp<Broadcast, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:39:  typedef const TensorBroadcastingOp<Broadcast, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:43:struct nested<TensorBroadcastingOp<Broadcast, XprType>, 1, typename eval<TensorBroadcastingOp<Broadcast, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:45:  typedef TensorBroadcastingOp<Broadcast, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:68:class TensorBroadcastingOp : public TensorBase<TensorBroadcastingOp<Broadcast, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:71:  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:74:  typedef typename Eigen::internal::nested<TensorBroadcastingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:75:  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:76:  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:78:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorBroadcastingOp(const XprType& expr, const Broadcast& broadcast)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:96:struct TensorEvaluator<const TensorBroadcastingOp<Broadcast, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:98:  typedef TensorBroadcastingOp<Broadcast, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:100:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:103:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:110:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:111:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:115:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:351:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:353:    double compute_cost = TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:356:        compute_cost += TensorOpCost::DivCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:359:              TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:362:            compute_cost += TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:363:                            TensorOpCost::ModCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:364:                            TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:368:            TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:372:           TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:377:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h:386:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:15:/** \class TensorLayoutSwap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:26:  * Tensor<float, 2, ColMajor> input(2, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:27:  * Tensor<float, 2, RowMajor> output = input.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:39:struct traits<TensorLayoutSwapOp<XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:52:struct eval<TensorLayoutSwapOp<XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:54:  typedef const TensorLayoutSwapOp<XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:58:struct nested<TensorLayoutSwapOp<XprType>, 1, typename eval<TensorLayoutSwapOp<XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:60:  typedef TensorLayoutSwapOp<XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:68:class TensorLayoutSwapOp : public TensorBase<TensorLayoutSwapOp<XprType>, WriteAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:71:  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:74:  typedef typename Eigen::internal::nested<TensorLayoutSwapOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:75:  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:76:  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:78:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorLayoutSwapOp(const XprType& expr)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:86:    EIGEN_STRONG_INLINE TensorLayoutSwapOp& operator = (const TensorLayoutSwapOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:88:      typedef TensorAssignOp<TensorLayoutSwapOp, const TensorLayoutSwapOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:90:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:96:    EIGEN_STRONG_INLINE TensorLayoutSwapOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:98:      typedef TensorAssignOp<TensorLayoutSwapOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:100:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:111:struct TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:113:  typedef TensorLayoutSwapOp<ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:115:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:119:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:120:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:121:    Layout = (static_cast<int>(TensorEvaluator<ArgType, Device>::Layout) == static_cast<int>(ColMajor)) ? RowMajor : ColMajor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:123:    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:126:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:158:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:164:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:167:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:174:  struct TensorEvaluator<TensorLayoutSwapOp<ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:175:  : public TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:177:  typedef TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:178:  typedef TensorLayoutSwapOp<ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:181:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:182:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:183:    Layout = (static_cast<int>(TensorEvaluator<ArgType, Device>::Layout) == static_cast<int>(ColMajor)) ? RowMajor : ColMajor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h:187:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:14: * TensorSyclLeafCount.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:46:/// specialisation of the \ref LeafCount struct when the node type is const TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:49:struct LeafCount<CVQual TensorMap<PlainObjectType, Options_, MakePointer_> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:57://  TensorCwiseUnaryOp,  TensorCwiseNullaryOp,  TensorCwiseBinaryOp,  TensorCwiseTernaryOp, and  TensorBroadcastingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:66:/// specialisation of the \ref LeafCount struct when the node type is const TensorSelectOp is an exception
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:69:struct LeafCount<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr> > : CategoryCount<IfExpr, ThenExpr, ElseExpr> {};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:76:/// specialisation of the \ref LeafCount struct when the node type is TensorAssignOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:79:struct LeafCount<CVQual TensorAssignOp<LHSExpr, RHSExpr> >: CategoryCount<LHSExpr,RHSExpr> {};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:85:/// specialisation of the \ref LeafCount struct when the node type is const TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:88:struct LeafCount<CVQual TensorForcedEvalOp<Expr> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:98:struct LeafCount<CVQual TensorCustomUnaryOp<CustomUnaryFunc, XprType> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:109:struct LeafCount<CVQual TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:116:/// specialisation of the \ref LeafCount struct when the node type is TensorEvalToOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:123:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(const, TensorEvalToOp, 1)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:124:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(, TensorEvalToOp, 1)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:125:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(const, TensorLayoutSwapOp, 0)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:126:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(, TensorLayoutSwapOp, 0)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:128:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(const, TensorIndexTupleOp, 0)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:129:EVALTOLAYOUTSWAPINDEXTUPLELEAFCOUNT(, TensorIndexTupleOp, 0)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:133:/// specialisation of the \ref LeafCount struct when the node type is const TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:140:// TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:141:REDUCTIONLEAFCOUNT(const,TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:142:REDUCTIONLEAFCOUNT(,TensorReductionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:144:// tensor Argmax -TensorTupleReducerOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:145:REDUCTIONLEAFCOUNT(const, TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:146:REDUCTIONLEAFCOUNT(, TensorTupleReducerOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:150:/// specialisation of the \ref LeafCount struct when the node type is const TensorContractionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:157:CONTRACTIONCONVOLUTIONLEAFCOUNT(const,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:158:CONTRACTIONCONVOLUTIONLEAFCOUNT(,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:159:CONTRACTIONCONVOLUTIONLEAFCOUNT(const,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:160:CONTRACTIONCONVOLUTIONLEAFCOUNT(,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:163:/// specialisation of the \ref LeafCount struct when the node type is  TensorSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:166:struct LeafCount<CVQual TensorSlicingOp<StartIndices, Sizes, XprType> >:CategoryCount<XprType>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:172:/// specialisation of the \ref LeafCount struct when the node type is  TensorChippingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:175:struct LeafCount<CVQual TensorChippingOp<DimId, XprType> >:CategoryCount<XprType>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:181:///TensorStridingSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:184:struct LeafCount<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >:CategoryCount<XprType>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:190://TensorImagePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:193:struct LeafCount<CVQual TensorImagePatchOp<Rows, Cols, XprType> >:CategoryCount<XprType>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:200:// TensorVolumePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:203:struct LeafCount<CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType> >:CategoryCount<XprType>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h:209:} /// namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:13:// General include header of SYCL target for Tensor Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:18:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:74:  typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:85:    const auto device_self_expr= Eigen::TensorReductionOp<Op, Dims, decltype(device_expr.expr) ,MakeGlobalPointer>(device_expr.expr, dims, functor);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:88:    typedef Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice> DeviceSelf;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:89:    auto device_self_evaluator = Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice>(device_self_expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:113:  typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:126:    const auto device_self_expr= Eigen::TensorReductionOp<Op, Dims, decltype(device_expr.expr) ,MakeGlobalPointer>(device_expr.expr, dims, functor);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:129:    typedef Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice> DeviceSelf;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:130:    auto device_self_evaluator = Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice>(device_self_expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:155:  typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:168:    typedef typename TensorSycl::internal::ConvertToDeviceExpression<const HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:169:    auto device_expr = TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors, tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:173:    const auto device_self_expr= Eigen::TensorReductionOp<Op, Dims, decltype(device_expr.expr) ,MakeGlobalPointer>(device_expr.expr, dims, op);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:176:    auto device_self_evaluator = Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice>(device_self_expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:200:  typedef  typename TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:215:    typedef typename TensorSycl::internal::ConvertToDeviceExpression<const HostExpr>::Type DevExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:216:    auto device_expr = TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors, tuple_of_accessors);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:220:    const auto device_self_expr= Eigen::TensorReductionOp<Op, Dims, decltype(device_expr.expr) ,MakeGlobalPointer>(device_expr.expr, dims, op);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclFunctors.h:223:    auto device_self_evaluator = Eigen::TensorEvaluator<decltype(device_self_expr), Eigen::SyclKernelDevice>(device_self_expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:15:/** \class TensorExecutor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:27:class TensorExecutor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:34:    TensorEvaluator<Expression, Device> evaluator(expr, device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:49:class TensorExecutor<Expression, DefaultDevice, true>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:56:    TensorEvaluator<Expression, DefaultDevice> evaluator(expr, device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:61:      const int PacketSize = unpacket_traits<typename TensorEvaluator<Expression, DefaultDevice>::PacketReturnType>::size;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:142:class TensorExecutor<Expression, ThreadPoolDevice, Vectorizable> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:147:    typedef TensorEvaluator<Expression, ThreadPoolDevice> Evaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:162:        num_threads = TensorCostModel<ThreadPoolDevice>::numThreads(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:197:class TensorExecutor<Expression, GpuDevice, Vectorizable> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:248:inline void TensorExecutor<Expression, GpuDevice, Vectorizable>::run(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:250:  TensorEvaluator<Expression, GpuDevice> evaluator(expr, device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:261:        (EigenMetaKernel<TensorEvaluator<Expression, GpuDevice>, Index>),
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:274:class TensorExecutor<Expression, SyclDevice, Vectorizable> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:277:    // call TensorSYCL module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h:278:    TensorSycl::run(expr, device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:18:class TensorLazyBaseEvaluator {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:20:  TensorLazyBaseEvaluator() : m_refcount(0) { }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:21:  virtual ~TensorLazyBaseEvaluator() { }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:35:  TensorLazyBaseEvaluator(const TensorLazyBaseEvaluator& other);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:36:  TensorLazyBaseEvaluator& operator = (const TensorLazyBaseEvaluator& other);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:43:class TensorLazyEvaluatorReadOnly : public TensorLazyBaseEvaluator<Dimensions, typename TensorEvaluator<Expr, Device>::Scalar> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:45:  //  typedef typename TensorEvaluator<Expr, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:46:  typedef typename TensorEvaluator<Expr, Device>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:48:  TensorLazyEvaluatorReadOnly(const Expr& expr, const Device& device) : m_impl(expr, device), m_dummy(Scalar(0)) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:52:  virtual ~TensorLazyEvaluatorReadOnly() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:72:  TensorEvaluator<Expr, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:78:class TensorLazyEvaluatorWritable : public TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:80:  typedef TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:83:  TensorLazyEvaluatorWritable(const Expr& expr, const Device& device) : Base(expr, device) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:85:  virtual ~TensorLazyEvaluatorWritable() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:94:class TensorLazyEvaluator : public internal::conditional<bool(internal::is_lvalue<Expr>::value),
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:95:                            TensorLazyEvaluatorWritable<Dimensions, Expr, Device>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:96:                            TensorLazyEvaluatorReadOnly<Dimensions, const Expr, Device> >::type {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:99:                                         TensorLazyEvaluatorWritable<Dimensions, Expr, Device>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:100:                                         TensorLazyEvaluatorReadOnly<Dimensions, const Expr, Device> >::type Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:103:  TensorLazyEvaluator(const Expr& expr, const Device& device) : Base(expr, device) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:105:  virtual ~TensorLazyEvaluator() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:112:/** \class TensorRef
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:113:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:119:template<typename PlainObjectType> class TensorRef : public TensorBase<TensorRef<PlainObjectType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:122:    typedef TensorRef<PlainObjectType> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:144:    EIGEN_STRONG_INLINE TensorRef() : m_evaluator(NULL) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:148:    EIGEN_STRONG_INLINE TensorRef(const Expression& expr) : m_evaluator(new internal::TensorLazyEvaluator<Dimensions, Expression, DefaultDevice>(expr, DefaultDevice())) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:153:    EIGEN_STRONG_INLINE TensorRef& operator = (const Expression& expr) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:155:      m_evaluator = new internal::TensorLazyEvaluator<Dimensions, Expression, DefaultDevice>(expr, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:160:    ~TensorRef() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:164:    TensorRef(const TensorRef& other) : m_evaluator(other.m_evaluator) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:169:    TensorRef& operator = (const TensorRef& other) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:350:  internal::TensorLazyBaseEvaluator<Dimensions, Scalar>* m_evaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:356:struct TensorEvaluator<const TensorRef<Derived>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:367:    Layout = TensorRef<Derived>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:372:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const TensorRef<Derived>& m, const Device&)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:395:  TensorRef<Derived> m_ref;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:401:struct TensorEvaluator<TensorRef<Derived>, Device> : public TensorEvaluator<const TensorRef<Derived>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:409:  typedef TensorEvaluator<const TensorRef<Derived>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorRef.h:417:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(TensorRef<Derived>& m, const Device& d) : Base(m, d)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:14: * TensorSyclConvertToDeviceExpression.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:49:/// type is TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:52:struct ConvertToDeviceExpression<CVQual TensorMap<T, Options_, MakePointer_> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:53:  typedef CVQual TensorMap<T, Options_, MakeGlobalPointer> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:61:/// type is TensorCwiseNullaryOp, TensorCwiseUnaryOp, TensorCwiseBinaryOp, TensorCwiseTernaryOp, TensorBroadcastingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:73:/// type is  TensorCwiseSelectOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:76:struct ConvertToDeviceExpression<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr> >\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:77:: NonOpConversion<TensorSelectOp, Res, IfExpr, ThenExpr, ElseExpr> {};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:86:struct ConvertToDeviceExpression<CVQual TensorAssignOp<LHSExpr, RHSExpr> >\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:87:: NonOpConversion<TensorAssignOp, Res, LHSExpr, RHSExpr>{};
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:94:/// type is  TensorEvalToOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:101:KERNELBROKERCONVERT(const, true, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:102:KERNELBROKERCONVERT(, false, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:105:/// specialisation of the \ref ConvertToDeviceExpression struct when the node types are TensorForcedEvalOp and TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:113:// TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:114:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(const,TensorForcedEvalOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:115:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(,TensorForcedEvalOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:117:// TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:118:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(const,TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:119:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(,TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:121://TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:122:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(const,TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:123:KERNELBROKERCONVERTFORCEDEVALLAYOUTSWAPINDEXTUPLEOP(,TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:126:/// specialisation of the \ref ConvertToDeviceExpression struct when the node type is TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:129:struct ConvertToDeviceExpression<CVQual TensorReductionOp<OP, Dim, subExpr, MakePointer_> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:130:  typedef CVQual TensorReductionOp<OP, Dim, typename ConvertToDeviceExpression<subExpr>::Type, MakeGlobalPointer> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:137:/// specialisation of the \ref ConvertToDeviceExpression struct when the node type is TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:140:struct ConvertToDeviceExpression<CVQual TensorTupleReducerOp<OP, Dim, subExpr> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:141:  typedef CVQual TensorTupleReducerOp<OP, Dim, typename ConvertToDeviceExpression<subExpr>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:148://TensorSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:151:struct ConvertToDeviceExpression<CVQual TensorSlicingOp <StartIndices, Sizes, XprType> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:152:  typedef CVQual TensorSlicingOp<StartIndices, Sizes, typename ConvertToDeviceExpression<XprType>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:159://TensorStridingSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:162:struct ConvertToDeviceExpression<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:163:  typedef CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, typename ConvertToDeviceExpression<XprType>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:170:/// specialisation of the \ref ConvertToDeviceExpression struct when the node type is TensorChippingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:173:struct ConvertToDeviceExpression<CVQual TensorChippingOp<DimId, Expr> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:174:  typedef CVQual TensorChippingOp<DimId, typename ConvertToDeviceExpression<Expr>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:180:/// specialisation of the \ref ConvertToDeviceExpression struct when the node type is TensorImagePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:183:struct ConvertToDeviceExpression<CVQual TensorImagePatchOp<Rows, Cols, XprType> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:184:  typedef CVQual TensorImagePatchOp<Rows, Cols, typename ConvertToDeviceExpression<XprType>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:191:/// specialisation of the \ref ConvertToDeviceExpression struct when the node type is TensorVolumePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:194:struct ConvertToDeviceExpression<CVQual TensorVolumePatchOp<Plannes, Rows, Cols, XprType> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:195:  typedef CVQual TensorVolumePatchOp<Plannes, Rows, Cols, typename ConvertToDeviceExpression<XprType>::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h:202:}  // namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:15:/** \class TensorConversionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:18:  * \brief Tensor conversion class. This class makes it possible to vectorize
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:24:struct traits<TensorConversionOp<TargetType, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:38:struct eval<TensorConversionOp<TargetType, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:40:  typedef const TensorConversionOp<TargetType, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:44:struct nested<TensorConversionOp<TargetType, XprType>, 1, typename eval<TensorConversionOp<TargetType, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:46:  typedef TensorConversionOp<TargetType, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:52:template <typename TensorEvaluator, typename SrcPacket, typename TgtPacket, int SrcCoeffRatio, int TgtCoeffRatio>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:55:  PacketConverter(const TensorEvaluator& impl)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:64:  const TensorEvaluator& m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:68:template <typename TensorEvaluator, typename SrcPacket, typename TgtPacket>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:69:struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 2, 1> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:71:  PacketConverter(const TensorEvaluator& impl)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:85:  const TensorEvaluator& m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:88:template <typename TensorEvaluator, typename SrcPacket, typename TgtPacket>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:89:struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 4, 1> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:91:  PacketConverter(const TensorEvaluator& impl)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:107:  const TensorEvaluator& m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:110:template <typename TensorEvaluator, typename SrcPacket, typename TgtPacket>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:111:struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 1, 2> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:113:  PacketConverter(const TensorEvaluator& impl)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:140:  const TensorEvaluator& m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:141:  const typename TensorEvaluator::Index m_maxIndex;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:145:class TensorConversionOp : public TensorBase<TensorConversionOp<TargetType, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:148:    typedef typename internal::traits<TensorConversionOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:149:    typedef typename internal::traits<TensorConversionOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:150:    typedef typename internal::traits<TensorConversionOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:151:    typedef typename internal::nested<TensorConversionOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:155:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConversionOp(const XprType& xpr)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:182:struct TensorEvaluator<const TensorConversionOp<TargetType, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:184:  typedef TensorConversionOp<TargetType, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:186:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:197:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:201:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:210:    return ConversionSubExprEval<internal::is_same<TargetType, SrcType>::value, TensorEvaluator<ArgType, Device>, Scalar>::run(m_impl, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:227:    const bool Vectorizable = TensorEvaluator<ArgType, Device>::PacketAccess &
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:232:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:234:    const double cast_cost = TensorOpCost::CastCost<SrcType, TargetType>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:241:          TensorOpCost(0, 0, TgtCoeffRatio * (cast_cost / PacketSize));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:243:      return m_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, cast_cost);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:250:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:255:    static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType run(const TensorEvaluator<ArgType, Device>& impl, Index index) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:268:    static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType run(const TensorEvaluator<ArgType, Device>& impl, Index index) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:271:      PacketConverter<TensorEvaluator<ArgType, Device>, PacketSourceType, PacketReturnType,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h:277:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:15:/** \class TensorReverse
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:18:  * \brief Tensor reverse elements class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:23:struct traits<TensorReverseOp<ReverseDimensions,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:37:struct eval<TensorReverseOp<ReverseDimensions, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:39:  typedef const TensorReverseOp<ReverseDimensions, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:43:struct nested<TensorReverseOp<ReverseDimensions, XprType>, 1,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:44:            typename eval<TensorReverseOp<ReverseDimensions, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:46:  typedef TensorReverseOp<ReverseDimensions, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:52:class TensorReverseOp : public TensorBase<TensorReverseOp<ReverseDimensions,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:56:  typedef typename Eigen::internal::traits<TensorReverseOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:59:  typedef typename Eigen::internal::nested<TensorReverseOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:60:  typedef typename Eigen::internal::traits<TensorReverseOp>::StorageKind
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:62:  typedef typename Eigen::internal::traits<TensorReverseOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:64:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorReverseOp(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:76:    EIGEN_STRONG_INLINE TensorReverseOp& operator = (const TensorReverseOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:78:      typedef TensorAssignOp<TensorReverseOp, const TensorReverseOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:80:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:86:    EIGEN_STRONG_INLINE TensorReverseOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:88:      typedef TensorAssignOp<TensorReverseOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:90:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:101:struct TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:103:  typedef TensorReverseOp<ReverseDimensions, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:114:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:115:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:120:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:212:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:213:    double compute_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:214:                                     2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:215:                                     TensorOpCost::DivCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:218:        compute_cost += 2 * TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:222:           TensorOpCost(0, 0, compute_cost, false /* vectorized */, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:228:  const TensorEvaluator<ArgType, Device> & impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:235:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:242:struct TensorEvaluator<TensorReverseOp<ReverseDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:243:    : public TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:245:  typedef TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:247:  typedef TensorReverseOp<ReverseDimensions, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:254:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:255:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:259:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h:280:    // This code is pilfered from TensorMorphing.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:14: * TensorSyclPlaceHolderExpr.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:46:            h.parallel_for(r, TensorSycl::internal::GenericKernelReducer<CoeffReturnType, OP, OutputAccessor, InputAccessor, LocalAccessor>(op, aOut, out_offset, aI, scratch,  length, local));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:82:    typedef Eigen::TensorSycl::internal::FunctorExtractor<TensorEvaluator<HostExpr, const Eigen::SyclDevice> > FunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:83:    FunctorExpr functors = TensorSycl::internal::extractFunctors(self.impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:117:      typedef decltype(TensorSycl::internal::createTupleOfAccessors(cgh, self.impl())) TupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:119:      TupleType tuple_of_accessors =  TensorSycl::internal::createTupleOfAccessors(cgh, self.impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:123:        TensorSycl::internal::FullReductionKernelFunctor<CoeffReturnType, OutAccessor, HostExpr, FunctorExpr, Op, Dims, size_t, TupleType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:146:    typedef Eigen::TensorSycl::internal::FunctorExtractor<TensorEvaluator<HostExpr, const Eigen::SyclDevice> > FunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:147:    FunctorExpr functors = TensorSycl::internal::extractFunctors(self.impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:158:      typedef decltype(TensorSycl::internal::createTupleOfAccessors(cgh, self.impl())) Tuple_of_Acc;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:160:      Tuple_of_Acc tuple_of_accessors =  TensorSycl::internal::createTupleOfAccessors(cgh, self.impl());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h:165:      TensorSycl::internal::ReductionFunctor<HostExpr, FunctorExpr, Tuple_of_Acc, Dims, Op, typename Self::Index>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:19:/** \class TensorFFT
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:20:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:22:  * \brief Tensor FFT class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:62:struct traits<TensorFFTOp<FFT, XprType, FFTResultType, FFTDir> > : public traits<XprType> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:77:struct eval<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>, Eigen::Dense> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:78:  typedef const TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:82:struct nested<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>, 1, typename eval<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection> >::type> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:83:  typedef TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:89:class TensorFFTOp : public TensorBase<TensorFFTOp<FFT, XprType, FFTResultType, FFTDir>, ReadOnlyAccessors> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:91:  typedef typename Eigen::internal::traits<TensorFFTOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:96:  typedef typename Eigen::internal::nested<TensorFFTOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:97:  typedef typename Eigen::internal::traits<TensorFFTOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:98:  typedef typename Eigen::internal::traits<TensorFFTOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:100:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorFFTOp(const XprType& expr, const FFT& fft)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:118:struct TensorEvaluator<const TensorFFTOp<FFT, ArgType, FFTResultType, FFTDir>, Device> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:119:  typedef TensorFFTOp<FFT, ArgType, FFTResultType, FFTDir> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:121:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:126:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:138:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:143:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device) : m_fft(op.fft()), m_impl(op.expression(), device), m_data(NULL), m_device(device) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:144:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:198:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:200:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:568:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:15:/** \class TensorDevice
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:27:template <typename ExpressionType, typename DeviceType> class TensorDevice {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:29:    TensorDevice(const DeviceType& device, ExpressionType& expression) : m_device(device), m_expression(expression) {}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:32:    EIGEN_STRONG_INLINE TensorDevice& operator=(const OtherDerived& other) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:33:      typedef TensorAssignOp<ExpressionType, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:35:      internal::TensorExecutor<const Assign, DeviceType>::run(assign, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:40:    EIGEN_STRONG_INLINE TensorDevice& operator+=(const OtherDerived& other) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:42:      typedef TensorCwiseBinaryOp<internal::scalar_sum_op<Scalar>, const ExpressionType, const OtherDerived> Sum;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:44:      typedef TensorAssignOp<ExpressionType, const Sum> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:46:      internal::TensorExecutor<const Assign, DeviceType>::run(assign, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:51:    EIGEN_STRONG_INLINE TensorDevice& operator-=(const OtherDerived& other) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:53:      typedef TensorCwiseBinaryOp<internal::scalar_difference_op<Scalar>, const ExpressionType, const OtherDerived> Difference;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:55:      typedef TensorAssignOp<ExpressionType, const Difference> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h:57:      internal::TensorExecutor<const Assign, DeviceType>::run(assign, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:28:/** \class TensorReduction
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:29:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:31:  * \brief Tensor reduction class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:37:  struct traits<TensorReductionOp<Op, Dims, XprType, MakePointer_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:56:struct eval<TensorReductionOp<Op, Dims, XprType, MakePointer_>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:58:  typedef const TensorReductionOp<Op, Dims, XprType, MakePointer_>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:62:struct nested<TensorReductionOp<Op, Dims, XprType, MakePointer_>, 1, typename eval<TensorReductionOp<Op, Dims, XprType, MakePointer_> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:64:  typedef TensorReductionOp<Op, Dims, XprType, MakePointer_> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:100:template <typename ReducedDims, int NumTensorDims, int Layout>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:104:template <typename ReducedDims, int NumTensorDims, int Layout>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:110:template <typename ReducedDims, int NumTensorDims>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:111:struct are_inner_most_dims<ReducedDims, NumTensorDims, ColMajor>{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:117:template <typename ReducedDims, int NumTensorDims>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:118:struct are_inner_most_dims<ReducedDims, NumTensorDims, RowMajor>{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:120:  static const bool tmp2 = index_statically_eq<ReducedDims>(0, NumTensorDims - array_size<ReducedDims>::value);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:121:  static const bool tmp3 = index_statically_eq<ReducedDims>(array_size<ReducedDims>::value - 1, NumTensorDims - 1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:125:template <typename ReducedDims, int NumTensorDims>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:126:struct preserve_inner_most_dims<ReducedDims, NumTensorDims, ColMajor>{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:132:template <typename ReducedDims, int NumTensorDims>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:133:struct preserve_inner_most_dims<ReducedDims, NumTensorDims, RowMajor>{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:135:  static const bool tmp2 = index_statically_lt<ReducedDims>(array_size<ReducedDims>::value - 1, NumTensorDims - 1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:270:    const TensorOpCost cost =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:272:        TensorOpCost(0, 0, internal::functor_traits<Op>::Cost, Vectorizable,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:274:    const int num_threads = TensorCostModel<ThreadPoolDevice>::numThreads(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:362:class TensorReductionOp : public TensorBase<TensorReductionOp<Op, Dims, XprType, MakePointer_>, ReadOnlyAccessors> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:364:    typedef typename Eigen::internal::traits<TensorReductionOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:367:    typedef typename Eigen::internal::nested<TensorReductionOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:368:    typedef typename Eigen::internal::traits<TensorReductionOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:369:    typedef typename Eigen::internal::traits<TensorReductionOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:372:    TensorReductionOp(const XprType& expr, const Dims& dims) : m_expr(expr), m_dims(dims)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:375:    TensorReductionOp(const XprType& expr, const Dims& dims, const Op& reducer) : m_expr(expr), m_dims(dims), m_reducer(reducer)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:394:struct TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:396:  typedef TensorReductionOp<Op, Dims, ArgType, MakePointer_> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:399:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:405:  typedef TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:406:  static const bool InputPacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:414:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:423:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:443:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:669:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:671:      return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:676:          TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:683:  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:709: template < typename HostExpr_, typename FunctorExpr_, typename Tuple_of_Acc_, typename Dims_, typename Op_, typename Index_> friend class TensorSycl::internal::ReductionFunctor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:710: template<typename CoeffReturnType_ ,typename OutAccessor_, typename HostExpr_, typename FunctorExpr_, typename Op_, typename Dims_, typename Index_, typename TupleType_> friend class TensorSycl::internal::FullReductionKernelFunctor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h:777:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:15:/** \class TensorContraction
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:18:  * \brief Tensor contraction class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:89:struct traits<TensorContractionOp<Dimensions, LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:114:struct eval<TensorContractionOp<Dimensions, LhsXprType, RhsXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:116:  typedef const TensorContractionOp<Dimensions, LhsXprType, RhsXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:120:struct nested<TensorContractionOp<Dimensions, LhsXprType, RhsXprType>, 1, typename eval<TensorContractionOp<Dimensions, LhsXprType, RhsXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:122:  typedef TensorContractionOp<Dimensions, LhsXprType, RhsXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:126:struct traits<TensorEvaluator<const TensorContractionOp<Indices_, LeftArgType_, RightArgType_>, Device_> > {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:139:class TensorContractionOp : public TensorBase<TensorContractionOp<Indices, LhsXprType, RhsXprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:142:  typedef typename Eigen::internal::traits<TensorContractionOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:145:  typedef typename Eigen::internal::nested<TensorContractionOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:146:  typedef typename Eigen::internal::traits<TensorContractionOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:147:  typedef typename Eigen::internal::traits<TensorContractionOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:149:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorContractionOp(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:173:struct TensorContractionEvaluatorBase
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:180:  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:189:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:204:      internal::array_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:206:      internal::array_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:217:  TensorContractionEvaluatorBase(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:224:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<LeftArgType, Device>::Layout) ==
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:225:         static_cast<int>(TensorEvaluator<RightArgType, Device>::Layout)),
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:455:    typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:456:    typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:461:    typedef internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:467:    typedef internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:518:    typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:519:    typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:524:    typedef internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:530:    typedef internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:554:    internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index, internal::ShardByCol> blocking(k, m, n, 1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:603:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:604:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:707:    internal::TensorXsmmContractionBlocking<LhsScalar, RhsScalar, Index> blocking(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:823:  TensorContractionEvaluatorBase& operator = (const TensorContractionEvaluatorBase&);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:843:  TensorEvaluator<EvalLeftArgType, Device> m_leftImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:844:  TensorEvaluator<EvalRightArgType, Device> m_rightImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:853:struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:854:    public TensorContractionEvaluatorBase<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:855:      TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> > {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:856:  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:857:  typedef TensorContractionEvaluatorBase<Self> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:859:  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:866:    Layout = TensorEvaluator<LeftArgType, Device>::Layout
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:879:      internal::array_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:881:      internal::array_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h:893:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h:22:  * \class TensorIndexList
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h:23:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h:25:  * \brief Set of classes used to encode a set of Tensor dimensions/indices.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h:37:  * \sa Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h:531:// inside the kenrel. So we can have two types of eval for host and device. This is required for TensorArgMax operation
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1:# Eigen Tensors
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:3:Tensors are multidimensional arrays of elements. Elements are typically scalars,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:8:## Tensor Classes
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:14:### Class Tensor<data_type, rank>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:21:Tensors of this class are resizable.  For example, if you assign a tensor of a
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:22:different size to a Tensor, that tensor is resized to match its new value.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:24:#### Constructor Tensor<data_type, rank>(size0, size1, ...)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:26:Constructor for a Tensor.  The constructor must be passed ```rank``` integers
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:32:    Tensor<float, 3> t_3d(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:35:    t_3d = Tensor<float, 3>(3, 4, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:37:#### Constructor Tensor<data_type, rank>(size_array)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:45:    Tensor<string, 2> t_2d({5, 7});
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:48:### Class TensorFixedSize<data_type, Sizes<size0, size1, ...>>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:58:    TensorFixedSize<float, Sizes<4, 3>> t_4x3;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:60:### Class TensorMap<Tensor<data_type, rank>>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:64:memory as a Tensor.  Instances of this class do not own the memory where the
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:67:A TensorMap is not resizable because it does not own the memory where its data
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:70:#### Constructor TensorMap<Tensor<data_type, rank>>(data, size0, size1, ...)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:72:Constructor for a Tensor.  The constructor must be passed a pointer to the
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:78:    TensorMap<Tensor<int, 4>> t_4d(storage, 2, 4, 2, 8);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:82:    TensorMap<Tensor<int, 2>> t_2d(storage, 16, 8);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:86:    TensorFixedSize<float, Sizes<4, 5>> t_4x3;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:87:    TensorMap<Tensor<float, 1>> t_12(t_4x3.data(), 12);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:90:#### Class TensorRef
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:92:See Assigning to a TensorRef below.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:94:## Accessing Tensor Elements
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:104:    Tensor<float, 3> t_3d(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:122:## TensorLayout
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:132:    Tensor<float, 3, ColMajor> col_major;  // equivalent to Tensor<float, 3>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:133:    TensorMap<Tensor<float, 3, RowMajor> > row_major(data, ...);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:142:    Tensor<float, 2, ColMajor> col_major(2, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:143:    Tensor<float, 2, RowMajor> row_major(2, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:145:    Tensor<float, 2> col_major_result = col_major;  // ok, layouts match
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:146:    Tensor<float, 2> col_major_result = row_major;  // will not compile
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:160:## Tensor Operations
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:162:The Eigen Tensor library provides a vast library of operations on Tensors:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:165:of the Tensor classes, and in some cases as operator overloads.  For example
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:168:    Tensor<float, 3> t1(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:170:    Tensor<float, 3> t2(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:173:    Tensor<float, 3> t3 = t1 + t2;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:178:TensorCwiseBinaryOp<scalar_sum>, which has references to the tensors
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:182:this happens through the overloading of ```operator=()``` in the Tensor class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:190:    TensorCwiseBinaryOp<scalar_sum>(t1, TensorCwiseUnaryOp<scalar_mul>(t2, 0.3f))
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:193:### Tensor Operations and C++ "auto"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:195:Because Tensor operations create tensor operators, the C++ ```auto``` keyword
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:198:    Tensor<float, 3> t3 = t1 + t2;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:207:    Tensor<float, 3> t3 = t1 + t2;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:213:When you use ```auto``` you do not get a Tensor as a result but instead a
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:221:result to a Tensor that will be capable of holding onto them.  This can be
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:222:either a normal Tensor, a fixed size Tensor, or a TensorMap on an existing
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:227:    Tensor<float, 3> result = t4;  // Could also be: result(t4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:230:    TensorMap<float, 4> result(<a float* with enough space>, <size0>, ...) = t4;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:233:    TensorFixedSize<float, Sizes<size0, ...>> result = t4;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:244:    Tensor<float, 3> result = t5;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:247:    Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:253:*   Assignment to a Tensor, TensorFixedSize, or TensorMap.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:255:*   Assignment to a TensorRef.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:257:#### Assigning to a Tensor, TensorFixedSize, or TensorMap.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:259:The most common way to evaluate an expression is to assign it to a Tensor.  In
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:261:"Operations", not Tensors, and do not cause the expressions to be evaluated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:262:The assignment to the Tensor ```result``` causes the evaluation of all the
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:268:    Tensor<float, 3> result = t5;  // The operations are evaluated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:271:Operation to a TensorFixedSize instead of a Tensor, which is a bit more
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:275:    TensorFixedSize<float, Sizes<4, 4, 2>> result = t5;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:277:Simiarly, assigning an expression to a TensorMap causes its evaluation.  Like
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:278:tensors of type TensorFixedSize, TensorMaps cannot be resized so they have to
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:289:    Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:292:    Tensor<float, 3> result = ((t1 + t2).eval() * 0.2f).exp();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:295:the expression in a temporary Tensor of the right size.  The code above in
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:299:    TensorFixedSize<float, Sizes<4, 4, 2>> tmp = t1 + t2;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:300:    Tensor<float, 3> result = (tmp * 0.2f).exp();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:311:    // The value is evaluated when you assign the Operation to a Tensor, using
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:313:    Tensor<float, 3> result = t4;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:320:    Tensor<...> X ...;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:321:    Tensor<...> Y = ((X - X.maximum(depth_dim).reshape(dims2d).broadcast(bcast))
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:328:    Tensor<...> Y =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:337:     Tensor<...> Y ...;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:358:#### Assigning to a TensorRef.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:361:can avoid materializing the value in a full tensor by using a TensorRef.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:363:A TensorRef is a small wrapper class for any Eigen Operation.  It provides
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:365:the expression.  TensorRef is convenient, because the Operation themselves do
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:368:    // Create a TensorRef for the expression.  The expression is not
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:370:    TensorRef<Tensor<float, 3> > ref = ((t1 + t2) * 0.2f).exp();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:377:Only use TensorRef when you need a subset of the values of the expression.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:378:TensorRef only computes the values you access.  However note that if you are
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:380:results in a Tensor first.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:382:In some cases, if the full Tensor result would be very large, you may save
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:383:memory by accessing it as a TensorRef.  But not always.  So don't count on it.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:405:    Tensor<float, 2> a(30, 40);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:406:    Tensor<float, 2> b(30, 40);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:407:    Tensor<float, 2> c = a + b;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:411:that the Tensor for the result be declared on its own.  This means that you
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:414:    Eigen::Tensor<float, 2> c(30, 40);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:437:    Eigen::Tensor<float, 2> c(30, 50);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:455:#### <Tensor-Type>::Dimensions
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:461:#### <Tensor-Type>::Index
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:466:#### <Tensor-Type>::Scalar
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:469:```Tensor<float>```, ```Scalar``` is the type ```float```.  See
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:480:access the values through a TensorRef.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:483:## Built-in Tensor Methods
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:488:Tensor, TensorFixedSize, and TensorMap.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:494:Constant value indicating the number of dimensions of a Tensor.  This is also
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:497:      Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:504:The actual type of the dimensions() result is <Tensor-Type>::Dimensions.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:506:    Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:507:    const Eigen::Tensor<float, 2>::Dimensions& d = a.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:522:```dimension()``` result is ```<Tensor-Type>::Index```, but you can
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:525:      Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:534:```<Tensor-Type>::Index```, but you can always use it like an int.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:536:    Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:544:e.g. ```TensorReslicingOp```.  Most operations defer calculating dimensions
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:546:of a deferred operation, you can wrap it in a TensorRef (see Assigning to a
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:547:TensorRef above), which provides ```dimensions()``` and ```dimension()``` as
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:550:TensorRef can also wrap the plain Tensor types, so this is a useful idiom in
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:551:templated contexts where the underlying object could be either a raw Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:552:or some deferred operation (e.g. a slice of a Tensor).  In this case, the
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:553:template code can wrap the object in a TensorRef and reason about its
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:559:### Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:564:    Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:568:### TensorFixedSize
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:574:    Eigen::TensorFixedSize<float, Sizes<3, 4>> a;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:580:### TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:583:until the TensorMap is discarded, and the size of the data must be large enough
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:587:    Eigen::TensorMap<Tensor<float, 2>> a(data, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:596:When a new Tensor or a new TensorFixedSize are created, memory is allocated to
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:598:when a new TensorMap is created on top of non-initialized memory the memory its
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:605:### <Tensor-Type> setConstant(const Scalar& val)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:624:    Eigen::Tensor<string, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:633:### <Tensor-Type> setZero()
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:647:### <Tensor-Type> setValues({..initializer_list})
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:653:most deeply nested lists must contains P scalars of the Tensor type where P is
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:654:the size of the last dimension of the Tensor.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:656:For example, for a ```TensorFixedSize<float, 2, 3>``` the initializer list must
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:662:    Eigen::Tensor<float, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:674:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:683:### <Tensor-Type> setRandom()
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:702:functions, where Scalar and Index are the same as ```<Tensor-Type>::Scalar```
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:703:and ```<Tensor-Type>::Index```.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:705:See ```struct UniformRandomGenerator``` in TensorFunctors.h for an example.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:736:The Tensor, TensorFixedSize, and TensorRef classes provide the following
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:747:wrapped in a TensorRef.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:757:Eigen Tensor code with other libraries.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:761:    Eigen::Tensor<float, 2> a(3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:768:## Tensor Operations
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:771:These can be chained: you can apply another Tensor Operation to the value
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:786:    Eigen::Tensor<float, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:788:    Eigen::Tensor<float, 2> b = a + a.constant(2.0f);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:789:    Eigen::Tensor<float, 2> c = b * b.constant(0.2f);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:815:    Eigen::Tensor<float, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:817:    Eigen::Tensor<float, 2> b = a + a.random();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:841:    Eigen::Tensor<float, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:843:    Eigen::Tensor<float, 2> b = -a;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:901:cubic roots of an int Tensor:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:903:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:905:    Eigen::Tensor<double, 2> b = a.cast<double>().pow(1.0 / 3.0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:987:## Selection (select(const ThenDerived& thenTensor, const ElseDerived& elseTensor)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:992:    Tensor<bool, 3> if = ...;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:993:    Tensor<float, 3> then = ...;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:994:    Tensor<float, 3> else = ...;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:995:    Tensor<float, 3> result = if.select(then, else);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1009:Tensor *contractions* are a generalization of the matrix product to the
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1013:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1015:    Eigen::Tensor<int, 2> b(3, 2);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1020:    Eigen::Tensor<int, 2> AB = a.contract(b, product_dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1024:    Eigen::Tensor<int, 2> AtBt = a.contract(b, transposed_product_dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1034:The Eigen Tensor library provides a set of predefined reduction operators such
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1041:```<TensorType>::Dimensions``` which can always be specified as an array of
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1058:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1065:    Eigen::Tensor<int, 1> b = a.maximum(dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1079:    Eigen::Tensor<float, 3, Eigen::ColMajor> a(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1091:    Eigen::Tensor<float, 1, Eigen::ColMajor> b =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1107:    Eigen::Tensor<float, 3> a(2, 3, 4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1115:    Eigen::Tensor<float, 0> b = a.sum();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1168:in TensorFunctors.h for information on how to implement a reduction operator.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1184:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1187:    Eigen::Tensor<int, 2> b = a.cumsum(1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1223:    Tensor<float, 4, DataLayout> input(3, 3, 7, 11);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1224:    Tensor<float, 2, DataLayout> kernel(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1225:    Tensor<float, 4, DataLayout> output(3, 2, 6, 11);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1250:These operations return a Tensor with different dimensions than the original
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1251:Tensor.  They can be used to access slices of tensors, see them with different
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1265:    Tensor<float, 2> input(7, 11);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1267:    Tensor<float, 3> result = input.reshape(three_dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1271:    Tensor<float, 1> result = input.reshape(one_dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1274:contents of a reshaped Tensor depend on the data layout of the original Tensor.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1279:    Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1282:    Eigen::Tensor<float, 1, Eigen::ColMajor> b = a.reshape(one_dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1293:This is what happens when the 2D Tensor is RowMajor:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1295:    Eigen::Tensor<float, 2, Eigen::RowMajor> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1298:    Eigen::Tensor<float, 1, Eigen::RowMajor> b = a.reshape(one_dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1314:    Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1317:    Eigen::Tensor<float, 1, Eigen::ColMajor> b(6);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1343:    Tensor<float, 3> input(20, 30, 50);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1345:    Tensor<float, 3> output = input.shuffle({1, 2, 0})
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1368:    Tensor<float, 3> input(20, 30, 50);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1370:    Tensor<float, 3> output(30, 50, 20);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1383:    Eigen::Tensor<int, 2> a(4, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1386:    Eigen::Tensor<int, 2> b = a.stride(strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1394:    Tensor<float, 3> input(20, 30, 50);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1396:    Tensor<float, 3> output(40, 90, 200);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1406:    Eigen::Tensor<int, 2> a(4, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1411:    Eigen::Tensor<int, 1> slice = a.slice(offsets, extents);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1435:    Eigen::Tensor<int, 2> a(4, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1438:    Eigen::Tensor<int, 1> row_3 = a.chip(2, 0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1439:    Eigen::Tensor<int, 1> col_2 = a.chip(1, 1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1459:    Eigen::Tensor<int, 1> a(3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1461:    Eigen::Tensor<int, 2> b(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1488:    Eigen::Tensor<int, 2> a(4, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1492:    Eigen::Tensor<int, 2> b = a.reverse(reverse);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1514:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1517:    Eigen::Tensor<int, 2> b = a.broadcast(bcast);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1539:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1544:    Eigen::Tensor<int, 2> b = a.pad(paddings);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1571:  Eigen::Tensor<float, 2, DataLayout> tensor(3,4);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1585:  Eigen::Tensor<float, 3, DataLayout> patch;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1679:  Tensor<float, 4> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1680:  Tensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1685:  Tensor<float, 5> twod_patch;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1694:  Tensor<float, 5, RowMajor> twod_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1710:    Eigen::Tensor<float, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1711:    Eigen::Tensor<int, 2> b = a.cast<int>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1714:Tensors of integers.  This is not currently supported by the Tensor library
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1717:    Eigen::Tensor<int, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1719:    Eigen::Tensor<int, 2> b =
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/README.md:1741:Tensor<T, N>::maximum() currently returns a Tensor<T, 0>. Similarly, the inner
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:15:/** \class TensorReshaping
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:18:  * \brief Tensor reshaping class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:24:struct traits<TensorReshapingOp<NewDimensions, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:37:struct eval<TensorReshapingOp<NewDimensions, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:39:  typedef const TensorReshapingOp<NewDimensions, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:43:struct nested<TensorReshapingOp<NewDimensions, XprType>, 1, typename eval<TensorReshapingOp<NewDimensions, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:45:  typedef TensorReshapingOp<NewDimensions, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:53:class TensorReshapingOp : public TensorBase<TensorReshapingOp<NewDimensions, XprType>, WriteAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:56:  typedef typename Eigen::internal::traits<TensorReshapingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:58:  typedef typename Eigen::internal::nested<TensorReshapingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:59:  typedef typename Eigen::internal::traits<TensorReshapingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:60:  typedef typename Eigen::internal::traits<TensorReshapingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:62:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorReshapingOp(const XprType& expr, const NewDimensions& dims)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:73:    EIGEN_STRONG_INLINE TensorReshapingOp& operator = (const TensorReshapingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:75:      typedef TensorAssignOp<TensorReshapingOp, const TensorReshapingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:77:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:83:    EIGEN_STRONG_INLINE TensorReshapingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:85:      typedef TensorAssignOp<TensorReshapingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:87:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:99:struct TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:101:  typedef TensorReshapingOp<NewDimensions, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:105:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:106:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:107:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:109:    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:112:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:145:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:151:  EIGEN_DEVICE_FUNC const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:154:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:161:  struct TensorEvaluator<TensorReshapingOp<NewDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:162:  : public TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:165:  typedef TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:166:  typedef TensorReshapingOp<NewDimensions, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:170:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:171:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:172:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:174:    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:177:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:198:/** \class TensorSlicing
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:199:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:201:  * \brief Tensor slicing class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:207:struct traits<TensorSlicingOp<StartIndices, Sizes, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:220:struct eval<TensorSlicingOp<StartIndices, Sizes, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:222:  typedef const TensorSlicingOp<StartIndices, Sizes, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:226:struct nested<TensorSlicingOp<StartIndices, Sizes, XprType>, 1, typename eval<TensorSlicingOp<StartIndices, Sizes, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:228:  typedef TensorSlicingOp<StartIndices, Sizes, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:236:class TensorSlicingOp : public TensorBase<TensorSlicingOp<StartIndices, Sizes, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:239:  typedef typename Eigen::internal::traits<TensorSlicingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:241:  typedef typename Eigen::internal::nested<TensorSlicingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:242:  typedef typename Eigen::internal::traits<TensorSlicingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:243:  typedef typename Eigen::internal::traits<TensorSlicingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:245:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorSlicingOp(const XprType& expr, const StartIndices& indices, const Sizes& sizes)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:259:    EIGEN_STRONG_INLINE TensorSlicingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:261:      typedef TensorAssignOp<TensorSlicingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:263:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:268:    EIGEN_STRONG_INLINE TensorSlicingOp& operator = (const TensorSlicingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:270:      typedef TensorAssignOp<TensorSlicingOp, const TensorSlicingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:272:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:316:struct TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:318:  typedef TensorSlicingOp<StartIndices, Sizes, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:324:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:325:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:326:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:331:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:338:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:350:        m_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(m_outputStrides[i]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:362:        m_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(m_outputStrides[i]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:466:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:467:    return m_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, NumDims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:507:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:537:  array<internal::TensorIntDivisor<Index>, NumDims> m_fastOutputStrides;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:539:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:548:struct TensorEvaluator<TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:549:  : public TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:551:  typedef TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:552:  typedef TensorSlicingOp<StartIndices, Sizes, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:556:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:557:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:558:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:563:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:626:struct traits<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:639:struct eval<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:641:  typedef const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:645:struct nested<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, 1, typename eval<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:647:  typedef TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:654:class TensorStridingSlicingOp : public TensorBase<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:657:  typedef typename internal::traits<TensorStridingSlicingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:659:  typedef typename internal::nested<TensorStridingSlicingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:660:  typedef typename internal::traits<TensorStridingSlicingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:661:  typedef typename internal::traits<TensorStridingSlicingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:663:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorStridingSlicingOp(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:681:    EIGEN_STRONG_INLINE TensorStridingSlicingOp& operator = (const TensorStridingSlicingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:683:      typedef TensorAssignOp<TensorStridingSlicingOp, const TensorStridingSlicingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:685:      internal::TensorExecutor<const Assign, DefaultDevice>::run(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:692:    EIGEN_STRONG_INLINE TensorStridingSlicingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:694:      typedef TensorAssignOp<TensorStridingSlicingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:696:      internal::TensorExecutor<const Assign, DefaultDevice>::run(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:710:struct TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:712:  typedef TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:727:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:731:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:749:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:780:        // NOTE: if tensor is degenerate, we send 1 to prevent TensorIntDivisor constructor crash
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:781:        m_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(degenerate ? 1 : m_outputStrides[i]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:796:        // NOTE: if tensor is degenerate, we send 1 to prevent TensorIntDivisor constructor crash
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:797:        m_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(degenerate ? 1 : m_outputStrides[i]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:822:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:823:    return m_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, NumDims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:837:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const{return m_impl;}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:868:  array<internal::TensorIntDivisor<Index>, NumDims> m_fastOutputStrides;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:870:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:885:struct TensorEvaluator<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:886:  : public TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:888:  typedef TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:889:  typedef TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:896:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:897:    CoordAccess = TensorEvaluator<ArgType, Device>::CoordAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h:901:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h:171:  void parallelFor(Index n, const TensorOpCost& cost,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h:174:    typedef TensorCostModel<ThreadPoolDevice> CostModel;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h:255:  void parallelFor(Index n, const TensorOpCost& cost,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h:25:class TensorContractionBlocking {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h:31:  EIGEN_DEVICE_FUNC TensorContractionBlocking(Index k, Index m, Index n, Index num_threads = 1) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h:56:class TensorXsmmContractionBlocking {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h:58:  TensorXsmmContractionBlocking(Index k, Index m, Index n,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:18:struct traits<TensorScanOp<Op, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:30:struct eval<TensorScanOp<Op, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:32:  typedef const TensorScanOp<Op, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:36:struct nested<TensorScanOp<Op, XprType>, 1,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:37:            typename eval<TensorScanOp<Op, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:39:  typedef TensorScanOp<Op, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:43:/** \class TensorScan
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:44:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:46:  * \brief Tensor scan class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:49:class TensorScanOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:50:    : public TensorBase<TensorScanOp<Op, XprType>, ReadOnlyAccessors> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:52:  typedef typename Eigen::internal::traits<TensorScanOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:55:  typedef typename Eigen::internal::nested<TensorScanOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:56:  typedef typename Eigen::internal::traits<TensorScanOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:57:  typedef typename Eigen::internal::traits<TensorScanOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:59:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorScanOp(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:84:struct TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:86:  typedef TensorScanOp<Op, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:88:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:93:  typedef TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:99:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:104:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:151:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& inner() const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:188:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:189:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorScan.h:201:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:15:/** \class TensorForcedEval
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:18:  * \brief Tensor reshaping class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:30:struct traits<TensorForcedEvalOp<XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:48:struct eval<TensorForcedEvalOp<XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:50:  typedef const TensorForcedEvalOp<XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:54:struct nested<TensorForcedEvalOp<XprType>, 1, typename eval<TensorForcedEvalOp<XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:56:  typedef TensorForcedEvalOp<XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:64:class TensorForcedEvalOp : public TensorBase<TensorForcedEvalOp<XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:67:  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:70:  typedef typename Eigen::internal::nested<TensorForcedEvalOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:71:  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:72:  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:74:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorForcedEvalOp(const XprType& expr)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:87:struct TensorEvaluator<const TensorForcedEvalOp<ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:89:  typedef TensorForcedEvalOp<ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:91:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:100:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:104:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:120:    typedef TensorEvalToOp< const typename internal::remove_const<ArgType>::type > EvalTo;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:123:    internal::TensorExecutor<const EvalTo, typename internal::remove_const<Device>::type, PacketAccess>::run(evalToTmp, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:142:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:143:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:149:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h:153:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:15:/** \class TensorPadding
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:18:  * \brief Tensor padding class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:24:struct traits<TensorPaddingOp<PaddingDimensions, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:37:struct eval<TensorPaddingOp<PaddingDimensions, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:39:  typedef const TensorPaddingOp<PaddingDimensions, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:43:struct nested<TensorPaddingOp<PaddingDimensions, XprType>, 1, typename eval<TensorPaddingOp<PaddingDimensions, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:45:  typedef TensorPaddingOp<PaddingDimensions, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:53:class TensorPaddingOp : public TensorBase<TensorPaddingOp<PaddingDimensions, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:56:  typedef typename Eigen::internal::traits<TensorPaddingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:59:  typedef typename Eigen::internal::nested<TensorPaddingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:60:  typedef typename Eigen::internal::traits<TensorPaddingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:61:  typedef typename Eigen::internal::traits<TensorPaddingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorPaddingOp(const XprType& expr, const PaddingDimensions& padding_dims, const Scalar padding_value)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:84:struct TensorEvaluator<const TensorPaddingOp<PaddingDimensions, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:86:  typedef TensorPaddingOp<PaddingDimensions, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:97:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:98:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:103:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:116:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:189:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:190:    TensorOpCost cost = m_impl.costPerCoeff(vectorized);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:208:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const{return m_impl;}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:245:  void updateCostPerDimension(TensorOpCost& cost, int i, bool first) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:253:      cost += TensorOpCost(0, 0, 2 * TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:254:                    reduction * (1 * TensorOpCost::AddCost<Index>()));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:256:      cost += TensorOpCost(0, 0, 2 * TensorOpCost::AddCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:257:                                 2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:258:                    reduction * (2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:259:                                 1 * TensorOpCost::DivCost<Index>()));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h:393:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:15:/** \class TensorConvolution
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:18:  * \brief Tensor convolution class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:116:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputPlaneToTensorInputOffset(Index p) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:140:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputPlaneToTensorOutputOffset(Index p) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:164:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:171:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:178:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i, Index j) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:185:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i, Index j) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:192:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i, Index j, Index k) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:200:  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i, Index j, Index k) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:219:struct traits<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:241:struct eval<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:243:  typedef const TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:247:struct nested<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>, 1, typename eval<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:249:  typedef TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:257:class TensorConvolutionOp : public TensorBase<TensorConvolutionOp<Indices, InputXprType, KernelXprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:260:  typedef typename Eigen::internal::traits<TensorConvolutionOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:264:  typedef typename Eigen::internal::nested<TensorConvolutionOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:265:  typedef typename Eigen::internal::traits<TensorConvolutionOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:266:  typedef typename Eigen::internal::traits<TensorConvolutionOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:268:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConvolutionOp(const InputXprType& input, const KernelXprType& kernel, const Indices& dims)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:291:struct TensorEvaluator<const TensorConvolutionOp<Indices, InputArgType, KernelArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:293:  typedef TensorConvolutionOp<Indices, InputArgType, KernelArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:295:  static const int NumDims = internal::array_size<typename TensorEvaluator<InputArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:306:    IsAligned = TensorEvaluator<InputArgType, Device>::IsAligned & TensorEvaluator<KernelArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:307:    PacketAccess = TensorEvaluator<InputArgType, Device>::PacketAccess & TensorEvaluator<KernelArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:308:    Layout = TensorEvaluator<InputArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:313:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:316:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<InputArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<KernelArgType, Device>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:318:    const typename TensorEvaluator<InputArgType, Device>::Dimensions& input_dims = m_inputImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:319:    const typename TensorEvaluator<KernelArgType, Device>::Dimensions& kernel_dims = m_kernelImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:451:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:456:        TensorOpCost::AddCost<Scalar>() + TensorOpCost::MulCost<Scalar>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:459:        (2 * TensorOpCost::AddCost<Index>() + 2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:460:         TensorOpCost::DivCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:461:    return TensorOpCost(0, 0, firstIndex_compute_cost, vectorized, PacketSize) +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:464:                          TensorOpCost(0, 0, convolve_compute_cost, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:525:      typedef TensorEvalToOp<const KernelArgType> EvalTo;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:528:      internal::TensorExecutor<const EvalTo, Device, PacketAccess>::run(evalToTmp, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:540:  TensorEvaluator<InputArgType, Device> m_inputImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:541:  TensorEvaluator<KernelArgType, Device> m_kernelImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:589:    const int plane_input_offset = indexMapper.mapCudaInputPlaneToTensorInputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:593:      const int tensor_index = plane_input_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i+first_x);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:600:    const int plane_output_offset = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:610:      const int tensor_index = plane_output_offset + indexMapper.mapCudaOutputKernelToTensorOutputOffset(i+first_x);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:643:    const int plane_input_offset = indexMapper.mapCudaInputPlaneToTensorInputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:652:        const int tensor_index = plane_input_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i+first_x, j+first_y);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:660:    const int plane_output_offset = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:676:        const int tensor_index = plane_output_offset + indexMapper.mapCudaOutputKernelToTensorOutputOffset(i+first_x, j+first_y);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:711:    const int plane_input_offset = indexMapper.mapCudaInputPlaneToTensorInputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:717:          const int tensor_index = plane_input_offset + indexMapper.mapCudaInputKernelToTensorInputOffset(i+first_x, j+first_y, k+first_z);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:729:    const int plane_output_offset = indexMapper.mapCudaOutputPlaneToTensorOutputOffset(p);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:742:          const int tensor_index = plane_output_offset + indexMapper.mapCudaOutputKernelToTensorOutputOffset(i+first_x, j+first_y, k+first_z);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:754:struct TensorEvaluator<const TensorConvolutionOp<Indices, InputArgType, KernelArgType>, GpuDevice>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:756:  typedef TensorConvolutionOp<Indices, InputArgType, KernelArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:758:  static const int NumDims =  internal::array_size<typename TensorEvaluator<InputArgType, GpuDevice>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:762:  typedef typename TensorEvaluator<KernelArgType, GpuDevice>::Dimensions KernelDimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:765:    IsAligned = TensorEvaluator<InputArgType, GpuDevice>::IsAligned & TensorEvaluator<KernelArgType, GpuDevice>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:767:    Layout = TensorEvaluator<InputArgType, GpuDevice>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:772:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const GpuDevice& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:775:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<InputArgType, GpuDevice>::Layout) == static_cast<int>(TensorEvaluator<KernelArgType, GpuDevice>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:777:    const typename TensorEvaluator<InputArgType, GpuDevice>::Dimensions& input_dims = m_inputImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:778:    const typename TensorEvaluator<KernelArgType, GpuDevice>::Dimensions& kernel_dims = m_kernelImpl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:833:      typedef TensorEvalToOp<const KernelArgType> EvalTo;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:836:      internal::TensorExecutor<const EvalTo, GpuDevice, PacketAccess>::run(evalToTmp, m_device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:852:    typedef typename TensorEvaluator<InputArgType, GpuDevice>::Dimensions InputDims;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:909:            LAUNCH_CUDA_KERNEL((EigenConvolutionKernel1D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 4>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, 4, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:913:            LAUNCH_CUDA_KERNEL((EigenConvolutionKernel1D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 7>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, 7, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:917:            LAUNCH_CUDA_KERNEL((EigenConvolutionKernel1D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, Dynamic>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, kernel_size, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:970:                LAUNCH_CUDA_KERNEL((EigenConvolutionKernel2D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 4, 7>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, 4, 7, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:974:                LAUNCH_CUDA_KERNEL((EigenConvolutionKernel2D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 4, Dynamic>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, 4, kernel_size_y, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:983:                LAUNCH_CUDA_KERNEL((EigenConvolutionKernel2D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 7, 4>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, 7, 4, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:987:                LAUNCH_CUDA_KERNEL((EigenConvolutionKernel2D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, 7, Dynamic>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, 7, kernel_size_y, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:994:            LAUNCH_CUDA_KERNEL((EigenConvolutionKernel2D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims, Dynamic, Dynamic>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, kernel_size_x, kernel_size_y, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1040:        LAUNCH_CUDA_KERNEL((EigenConvolutionKernel3D<TensorEvaluator<InputArgType, GpuDevice>, Index, InputDims>), num_blocks, block_size, shared_mem, m_device, m_inputImpl, indexMapper, m_kernel, numP, numX, maxX, numY, maxY, numZ, maxZ, kernel_size_x, kernel_size_y, kernel_size_z, data);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1065:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1072:        TensorOpCost::AddCost<Scalar>() + TensorOpCost::MulCost<Scalar>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1075:        (2 * TensorOpCost::AddCost<Index>() + 2 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1076:         TensorOpCost::DivCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1077:    return TensorOpCost(0, 0, firstIndex_compute_cost, vectorized, PacketSize) +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1080:                          TensorOpCost(0, 0, convolve_compute_cost, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1086:  TensorEvaluator& operator = (const TensorEvaluator&);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1088:  TensorEvaluator<InputArgType, GpuDevice> m_inputImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h:1089:  TensorEvaluator<KernelArgType, GpuDevice> m_kernelImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:14: * TensorSyclExprConstructor.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:30:struct DeviceFixedSizeTensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:33:struct DeviceFixedSizeTensor<Expr, Eigen::Sizes<Indices...>>{
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:47:/// space for the TensorMap pointers used in eval function.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:55:/// TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:59:struct ExprConstructor< CVQual TensorMap<T, Options_, MakeGlobalPointer>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:60:CVQual PlaceHolder<CVQual TensorMap<T, Options_, MakePointer_>, N>, Params...>{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:61:  typedef  CVQual TensorMap<T, Options_, MakeGlobalPointer>  Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:73:/// TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:77:struct ExprConstructor< CVQual TensorMap<TensorFixedSize<Scalar_, Dimensions_, Options_2, IndexType>, Options_, MakeGlobalPointer>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:78:CVQual PlaceHolder<CVQual TensorMap<TensorFixedSize<Scalar_, Dimensions_, Options_2, IndexType>, Options_, MakePointer_>, N>, Params...>{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:79:  typedef  CVQual TensorMap<TensorFixedSize<Scalar_, Dimensions_, Options_2, IndexType>, Options_, MakeGlobalPointer>  Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:83:  : expr(DeviceFixedSizeTensor<Type,Dimensions_>::instantiate(utility::tuple::get<N>(t))){}\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:107:/// TensorBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:128:/// TensorCwiseTernaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:151:/// TensorCwiseSelectOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:154:struct ExprConstructor< CVQual TensorSelectOp<OrigIfExpr, OrigThenExpr, OrigElseExpr>, CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:158:  typedef CVQual TensorSelectOp<typename my_if_type::Type, typename my_then_type::Type, typename my_else_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:173:/// const TensorAssignOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:176:struct ExprConstructor<CVQual TensorAssignOp<OrigLHSExpr, OrigRHSExpr>,  CVQual TensorAssignOp<LHSExpr, RHSExpr>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:179:  typedef CVQual TensorAssignOp<typename my_left_type::Type, typename my_right_type::Type>  Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:193: /// const TensorAssignOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:196: struct ExprConstructor<CVQual TensorConversionOp<ConvertType, OrigNestedExpr>,  CVQual TensorConversionOp<ConvertType, NestedExpr>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:198:   typedef CVQual TensorConversionOp<ConvertType, typename my_nested_type::Type>  Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:211:///  TensorEvalToOp /// 0 here is the output number in the buffer
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:214:struct ExprConstructor<CVQual TensorEvalToOp<OrigExpr, MakeGlobalPointer>, CVQual TensorEvalToOp<Expr>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:216:  typedef typename TensorEvalToOp<OrigExpr, MakeGlobalPointer>::PointerType my_buffer_type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:217:  typedef CVQual TensorEvalToOp<typename my_expr_type::Type, MakeGlobalPointer> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:231:/// TensorForcedEvalOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:234:struct ExprConstructor<CVQual TensorForcedEvalOp<OrigExpr>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:235:CVQual PlaceHolder<CVQual TensorForcedEvalOp<DevExpr>, N>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:236:  typedef  TensorForcedEvalOp<OrigExpr> XprType;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:237:  typedef CVQual TensorMap<\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:238:                            Tensor<typename XprType::Scalar,XprType::NumDimensions, Eigen::internal::traits<XprType>::Layout,typename XprType::Index>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:254:struct ExprConstructor<CVQual TensorCustomUnaryOp<CustomUnaryFunc, OrigExpr>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:255:CVQual PlaceHolder<CVQual TensorCustomUnaryOp<CustomUnaryFunc, DevExpr>, N>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:256:  typedef TensorCustomUnaryOp<CustomUnaryFunc, OrigExpr> XprType;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:257:  typedef CVQual TensorMap<\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:258:                            Tensor<typename XprType::Scalar,XprType::NumDimensions, Eigen::internal::traits<XprType>::Layout,typename XprType::Index>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:272:/// specialisation of the \ref ExprConstructor struct when the node type is TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:275:struct ExprConstructor<CVQual TensorReductionOp<OP, Dim, OrigExpr, MakeGlobalPointer>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:276:CVQual PlaceHolder<CVQual TensorReductionOp<OP, Dim, DevExpr>, N>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:277:  static const auto NumIndices= ValueCondition< TensorReductionOp<OP, Dim, DevExpr, MakeGlobalPointer>::NumDimensions==0,  1, TensorReductionOp<OP, Dim, DevExpr, MakeGlobalPointer>::NumDimensions >::Res;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:278:  typedef CVQual TensorMap<Tensor<typename TensorReductionOp<OP, Dim, DevExpr, MakeGlobalPointer>::Scalar,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:279:  NumIndices, Eigen::internal::traits<TensorReductionOp<OP, Dim, DevExpr, MakeGlobalPointer>>::Layout, typename TensorReductionOp<OP, Dim, DevExpr>::Index>, Eigen::internal::traits<TensorReductionOp<OP, Dim, DevExpr, MakeGlobalPointer>>::Layout, MakeGlobalPointer> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:290:/// specialisation of the \ref ExprConstructor struct when the node type is TensorTupleReducerOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:291:/// use reductionOp instead of the TensorTupleReducerOp in order to build the tensor map. Because the tensorMap is the output of Tensor ReductionOP.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:294:struct ExprConstructor<CVQual TensorTupleReducerOp<OP, Dim, OrigExpr>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:295:CVQual PlaceHolder<CVQual TensorTupleReducerOp<OP, Dim, DevExpr>, N>, Params...> {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:296:  static const auto NumRedDims= TensorReductionOp<OP, Dim, const TensorIndexTupleOp<OrigExpr> , MakeGlobalPointer>::NumDimensions;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:298:static const int Layout =static_cast<int>(Eigen::internal::traits<TensorReductionOp<OP, Dim, const TensorIndexTupleOp<OrigExpr>, MakeGlobalPointer>>::Layout);\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:299:  typedef CVQual TensorMap<\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:300:                          Tensor<typename TensorIndexTupleOp<OrigExpr>::CoeffReturnType,NumIndices, Layout, typename TensorTupleReducerOp<OP, Dim, OrigExpr>::Index>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:304:  typedef typename TensorEvaluator<const TensorIndexTupleOp<OrigExpr> , SyclKernelDevice>::Dimensions InputDimensions;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:307:  typedef const TensorTupleReducerDeviceOp<StrideDims, XprType> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:321:/// TensorContractionOp, TensorConvolutionOp TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:328:  typedef CVQual TensorMap<\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:329:                            Tensor<typename XprTyp::Scalar,NumIndices, Eigen::internal::traits<XprTyp>::Layout, typename XprTyp::Index>,\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:339://TensorContractionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:340:SYCLCONTRACTCONVCUSBIOPS(const, TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:341:SYCLCONTRACTCONVCUSBIOPS(, TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:342://TensorConvolutionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:343:SYCLCONTRACTCONVCUSBIOPS(const, TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:344:SYCLCONTRACTCONVCUSBIOPS(, TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:345://TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:346:SYCLCONTRACTCONVCUSBIOPS(const, TensorCustomBinaryOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:347:SYCLCONTRACTCONVCUSBIOPS(, TensorCustomBinaryOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:350://TensorSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:353:struct ExprConstructor<CVQual TensorSlicingOp <StartIndices, Sizes, OrigXprType> , CVQual TensorSlicingOp<StartIndices, Sizes, XprType>, Params... >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:355:  typedef CVQual TensorSlicingOp<StartIndices, Sizes, typename my_xpr_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:367://TensorStridingSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:370:struct ExprConstructor<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, OrigXprType>, CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Params... >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:372:  typedef CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, typename my_xpr_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:384://TensorReshapingOp and TensorShufflingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:397:// TensorReshapingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:398:SYCLRESHAPEANDSHUFFLEOPEXPRCONST(TensorReshapingOp, const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:399:SYCLRESHAPEANDSHUFFLEOPEXPRCONST(TensorReshapingOp, )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:400:// TensorShufflingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:401:SYCLRESHAPEANDSHUFFLEOPEXPRCONST(TensorShufflingOp, const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:402:SYCLRESHAPEANDSHUFFLEOPEXPRCONST(TensorShufflingOp, )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:405://TensorPaddingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:418://TensorPaddingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:419:SYCLPADDINGOPEXPRCONST(TensorPaddingOp, const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:420:SYCLPADDINGOPEXPRCONST(TensorPaddingOp, )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:423:// TensorChippingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:426:struct ExprConstructor<CVQual TensorChippingOp <DimId, OrigXprType> , CVQual TensorChippingOp<DimId, XprType>, Params... >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:428:  typedef CVQual TensorChippingOp<DimId, typename my_xpr_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:440:// TensorImagePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:443:struct  ExprConstructor<CVQual TensorImagePatchOp<Rows, Cols, OrigXprType>, CVQual TensorImagePatchOp<Rows, Cols, XprType>, Params... > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:445:  typedef CVQual TensorImagePatchOp<Rows, Cols, typename my_xpr_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:459:// TensorVolumePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:462:struct  ExprConstructor<CVQual TensorVolumePatchOp<Planes, Rows, Cols, OrigXprType>, CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Params... > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:464:  typedef CVQual TensorVolumePatchOp<Planes, Rows, Cols, typename my_xpr_type::Type> Type;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:480:// TensorLayoutSwapOp and TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:493://TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:494:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXPR(const, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:495:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXPR(, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:496://TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:497:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXPR(const, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:498:SYCLTENSORLAYOUTSWAPINDEXTUPLEOPEXPR(, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h:509:} /// namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1201:struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, GpuDevice> :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1202:    public TensorContractionEvaluatorBase<TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, GpuDevice> > {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1206:  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1207:  typedef TensorContractionEvaluatorBase<Self> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1209:  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1216:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1229:      internal::array_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1231:      internal::array_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1249:  typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1250:  typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1255:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1354:    typedef internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h:1360:    typedef internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:15:/** \class TensorInflation
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:18:  * \brief Tensor inflation class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:24:struct traits<TensorInflationOp<Strides, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:37:struct eval<TensorInflationOp<Strides, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:39:  typedef const TensorInflationOp<Strides, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:43:struct nested<TensorInflationOp<Strides, XprType>, 1, typename eval<TensorInflationOp<Strides, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:45:  typedef TensorInflationOp<Strides, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:51:class TensorInflationOp : public TensorBase<TensorInflationOp<Strides, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:54:  typedef typename Eigen::internal::traits<TensorInflationOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:57:  typedef typename Eigen::internal::nested<TensorInflationOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:58:  typedef typename Eigen::internal::traits<TensorInflationOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:59:  typedef typename Eigen::internal::traits<TensorInflationOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:61:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorInflationOp(const XprType& expr, const Strides& strides)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:78:struct TensorEvaluator<const TensorInflationOp<Strides, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:80:  typedef TensorInflationOp<Strides, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:82:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:90:    IsAligned = /*TensorEvaluator<ArgType, Device>::IsAligned*/ false,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:91:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:93:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:98:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:109:      m_fastStrides[i] = internal::TensorIntDivisor<Index>(m_strides[i]);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:112:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:203:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:204:    const double compute_cost = NumDims * (3 * TensorOpCost::DivCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:205:                                           3 * TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:206:                                           2 * TensorOpCost::AddCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:210:      return TensorOpCost();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:212:           TensorOpCost(sizeof(CoeffReturnType) * input_size / output_size, 0,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:219:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:227:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h:229:  array<internal::TensorIntDivisor<Index>, NumDims> m_fastStrides;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:15:/** \class TensorPatch
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:18:  * \brief Tensor patch class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:24:struct traits<TensorPatchOp<PatchDim, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:37:struct eval<TensorPatchOp<PatchDim, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:39:  typedef const TensorPatchOp<PatchDim, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:43:struct nested<TensorPatchOp<PatchDim, XprType>, 1, typename eval<TensorPatchOp<PatchDim, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:45:  typedef TensorPatchOp<PatchDim, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:53:class TensorPatchOp : public TensorBase<TensorPatchOp<PatchDim, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:56:  typedef typename Eigen::internal::traits<TensorPatchOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:59:  typedef typename Eigen::internal::nested<TensorPatchOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:60:  typedef typename Eigen::internal::traits<TensorPatchOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:61:  typedef typename Eigen::internal::traits<TensorPatchOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorPatchOp(const XprType& expr, const PatchDim& patch_dims)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:81:struct TensorEvaluator<const TensorPatchOp<PatchDim, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:83:  typedef TensorPatchOp<PatchDim, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:85:  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value + 1;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:95:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:96:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:101:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:108:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:251:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:252:    const double compute_cost = NumDims * (TensorOpCost::DivCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:253:                                           TensorOpCost::MulCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:254:                                           2 * TensorOpCost::AddCost<Index>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:256:           TensorOpCost(0, 0, compute_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:262:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h:272:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:15:/** \class TensorExpr
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:18:  * \brief Tensor expression classes.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:20:  * The TensorCwiseNullaryOp class applies a nullary operators to an expression.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:23:  * The TensorCwiseUnaryOp class represents an expression where a unary operator
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:26:  * The TensorCwiseBinaryOp class represents an expression where a binary
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:32:struct traits<TensorCwiseNullaryOp<NullaryOp, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:52:class TensorCwiseNullaryOp : public TensorBase<TensorCwiseNullaryOp<NullaryOp, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:55:    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:58:    typedef TensorCwiseNullaryOp<NullaryOp, XprType> Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:59:    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:60:    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:62:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseNullaryOp(const XprType& xpr, const NullaryOp& func = NullaryOp())
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:81:struct traits<TensorCwiseUnaryOp<UnaryOp, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:95:struct eval<TensorCwiseUnaryOp<UnaryOp, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:97:  typedef const TensorCwiseUnaryOp<UnaryOp, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:101:struct nested<TensorCwiseUnaryOp<UnaryOp, XprType>, 1, typename eval<TensorCwiseUnaryOp<UnaryOp, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:103:  typedef TensorCwiseUnaryOp<UnaryOp, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:111:class TensorCwiseUnaryOp : public TensorBase<TensorCwiseUnaryOp<UnaryOp, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:116:    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:119:    typedef typename Eigen::internal::nested<TensorCwiseUnaryOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:120:    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:121:    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:123:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:142:struct traits<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:171:struct eval<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:173:  typedef const TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:177:struct nested<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, 1, typename eval<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:179:  typedef TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:187:class TensorCwiseBinaryOp : public TensorBase<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:192:    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:195:    typedef typename Eigen::internal::nested<TensorCwiseBinaryOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:196:    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:197:    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:199:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseBinaryOp(const LhsXprType& lhs, const RhsXprType& rhs, const BinaryOp& func = BinaryOp())
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:223:struct traits<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:248:struct eval<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:250:  typedef const TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:254:struct nested<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, 1, typename eval<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:256:  typedef TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:264:class TensorCwiseTernaryOp : public TensorBase<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:267:    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:270:    typedef typename Eigen::internal::nested<TensorCwiseTernaryOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:271:    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:272:    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:274:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseTernaryOp(const Arg1XprType& arg1, const Arg2XprType& arg2, const Arg3XprType& arg3, const TernaryOp& func = TernaryOp())
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:303:struct traits<TensorSelectOp<IfXprType, ThenXprType, ElseXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:320:struct eval<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:322:  typedef const TensorSelectOp<IfXprType, ThenXprType, ElseXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:326:struct nested<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, 1, typename eval<TensorSelectOp<IfXprType, ThenXprType, ElseXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:328:  typedef TensorSelectOp<IfXprType, ThenXprType, ElseXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:335:class TensorSelectOp : public TensorBase<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:338:    typedef typename Eigen::internal::traits<TensorSelectOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:342:    typedef typename Eigen::internal::nested<TensorSelectOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:343:    typedef typename Eigen::internal::traits<TensorSelectOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:344:    typedef typename Eigen::internal::traits<TensorSelectOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h:347:    TensorSelectOp(const IfXprType& a_condition,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h:18:  * \class TensorDimensions
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h:19:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h:21:  * \brief Set of classes used to encode and store the dimensions of a Tensor.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h:29:  * \sa Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:15:/** \class TensorMap
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:27:template<typename PlainObjectType, int Options_, template <class> class MakePointer_> class TensorMap : public TensorBase<TensorMap<PlainObjectType, Options_, MakePointer_> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:30:    typedef TensorMap<PlainObjectType, Options_, MakePointer_> Self;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:60:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr) : m_data(dataPtr), m_dimensions() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:67:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension, IndexTypes... otherDimensions) : m_data(dataPtr), m_dimensions(firstDimension, otherDimensions...) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:73:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension) : m_data(dataPtr), m_dimensions(firstDimension) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:78:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2) : m_data(dataPtr), m_dimensions(dim1, dim2) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:82:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:86:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3, dim4) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:90:    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4, Index dim5) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3, dim4, dim5) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:95:   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, const array<Index, NumIndices>& dimensions)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:100:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, const Dimensions& dimensions)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:104:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PlainObjectType& tensor)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:298:      typedef TensorAssignOp<Self, const Self> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:300:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:308:      typedef TensorAssignOp<Self, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorMap.h:310:      internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:14: * TensorSyclextractFunctors.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:26:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:35:// This struct is used for leafNode (TensorMap) and nodes behaving like leafNode (TensorForcedEval).
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:48:///TensorConversionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:51:struct FunctorExtractor<TensorEvaluator<CVQual ExprNode<ArgType1, ArgType2>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:52:  FunctorExtractor<TensorEvaluator<ArgType2, Dev> > subExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:53:  FunctorExtractor(const TensorEvaluator<CVQual ExprNode<ArgType1, ArgType2>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:57:SYCLEXTRFUNCCONVERSION(TensorConversionOp, const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:58:SYCLEXTRFUNCCONVERSION(TensorConversionOp, )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:63:struct FunctorExtractor< TensorEvaluator <CVQual TensorMap<TensorFixedSize<Scalar_, Dimensions_, Options_2, IndexType>, Options_, MakePointer_> , Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:64:FunctorExtractor(const TensorEvaluator <CVQual TensorMap<TensorFixedSize<Scalar_, Dimensions_, Options_2, IndexType>, Options_, MakePointer_> , Dev>& ){}\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:72:/// TensorCwiseNullaryOp,  TensorCwiseUnaryOp, and  TensorBroadcastingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:75:struct FunctorExtractor<TensorEvaluator<CVQual UnaryCategory<OP, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:76:  FunctorExtractor<TensorEvaluator<RHSExpr, Dev> > rhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:78:  FunctorExtractor(const TensorEvaluator<CVQual UnaryCategory<OP, RHSExpr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:87:/// TensorCwiseBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:90:struct FunctorExtractor<TensorEvaluator<CVQual BinaryCategory<OP, LHSExpr, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:91:  FunctorExtractor<TensorEvaluator<LHSExpr, Dev> > lhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:92:  FunctorExtractor<TensorEvaluator<RHSExpr, Dev> > rhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:94:  FunctorExtractor(const TensorEvaluator<CVQual BinaryCategory<OP, LHSExpr, RHSExpr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:102:/// specialisation of the \ref FunctorExtractor struct when the node type is TensorCwiseTernaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:105:struct FunctorExtractor<TensorEvaluator<CVQual TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:106:  FunctorExtractor<TensorEvaluator<Arg1Expr, Dev> > arg1Expr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:107:  FunctorExtractor<TensorEvaluator<Arg2Expr, Dev> > arg2Expr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:108:  FunctorExtractor<TensorEvaluator<Arg3Expr, Dev> > arg3Expr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:110:  FunctorExtractor(const TensorEvaluator<CVQual TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:120://TensorCustomOp must be specialised otherewise it will be captured by UnaryCategory while its action is different
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:122:/// specialisation of TensorCustomOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:125:struct FunctorExtractor<TensorEvaluator<CVQual TensorCustomUnaryOp<CustomUnaryFunc, ArgType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:126:  typedef TensorEvaluator<CVQual TensorCustomUnaryOp<CustomUnaryFunc, ArgType>, Dev> Evaluator;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:129://TensorCustomUnaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:134://TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:137:struct FunctorExtractor<TensorEvaluator<CVQual TensorCustomBinaryOp<CustomBinaryFunc, ArgType1, ArgType2>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:138:  typedef TensorEvaluator<CVQual TensorCustomBinaryOp<CustomBinaryFunc, ArgType1, ArgType2>, Dev> Evaluator;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:141://TensorCustomBinaryOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:149:/// TensorCwiseSelectOp. This is an specialisation without OP so it has to be separated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:152:struct FunctorExtractor< TensorEvaluator<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:153:  FunctorExtractor<TensorEvaluator<IfExpr, Dev> > ifExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:154:  FunctorExtractor<TensorEvaluator<ThenExpr, Dev> > thenExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:155:  FunctorExtractor<TensorEvaluator<ElseExpr, Dev> > elseExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:156:  FunctorExtractor(const TensorEvaluator<CVQual TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:165:/// const TensorAssignOp. This is an specialisation without OP so it has to be separated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:168:struct FunctorExtractor<TensorEvaluator<CVQual TensorAssignOp<LHSExpr, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:169:  FunctorExtractor<TensorEvaluator<LHSExpr, Dev> > lhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:170:  FunctorExtractor<TensorEvaluator<RHSExpr, Dev> > rhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:171:  FunctorExtractor(const TensorEvaluator<CVQual TensorAssignOp<LHSExpr, RHSExpr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:179:/// TensorEvalToOp, TensorLayoutSwapOp. This is an specialisation without OP so it has to be separated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:182:struct FunctorExtractor<TensorEvaluator<CVQual ExprNode<Expr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:183:  FunctorExtractor<TensorEvaluator<Expr, Dev> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:184:  FunctorExtractor(const TensorEvaluator<CVQual ExprNode<Expr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:187://TensorEvalToOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:188:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(const, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:189:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(, TensorEvalToOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:190:// TensorLayoutSwapOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:191:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(const, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:192:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(, TensorLayoutSwapOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:193:// TensorIndexTupleOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:194:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(const, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:195:SYCLEXTRFUNCEVALTOOPSWAPLAYOUTINDEXTUPLE(, TensorIndexTupleOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:208://TensorReductionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:211:struct FunctorExtractor<TensorEvaluator<CVQual TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:212:  typedef TensorEvaluator<CVQual TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device> Evaluator;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:216:  FunctorExtractor(const TensorEvaluator<CVQual TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:223://TensorTupleReducerOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:226: struct FunctorExtractor<TensorEvaluator<CVQual TensorTupleReducerOp<ReduceOp, Dims, ArgType>, Device> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:227: typedef TensorEvaluator<CVQual TensorTupleReducerOp<ReduceOp, Dims, ArgType>, Device> Evaluator;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:228: static const int  NumOutputDims= Eigen::internal::traits<TensorTupleReducerOp<ReduceOp, Dims, ArgType> >::NumDimensions;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:242: FunctorExtractor(const TensorEvaluator<CVQual TensorTupleReducerOp<ReduceOp, Dims, ArgType>, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:251://TensorContractionOp and TensorConvolutionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:254:struct FunctorExtractor<TensorEvaluator<CVQual ExprNode<Indices, LhsXprType, RhsXprType>, Device>>{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:255:  typedef TensorEvaluator<CVQual ExprNode<Indices, LhsXprType, RhsXprType>, Device> Evaluator;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:259:  FunctorExtractor(const TensorEvaluator<CVQual ExprNode<Indices, LhsXprType, RhsXprType>, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:263://TensorContractionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:264:SYCLEXTRFUNCCONTRACTCONVOLUTIONOP(const,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:265:SYCLEXTRFUNCCONTRACTCONVOLUTIONOP(,TensorContractionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:266://TensorConvolutionOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:267:SYCLEXTRFUNCCONTRACTCONVOLUTIONOP(const,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:268:SYCLEXTRFUNCCONTRACTCONVOLUTIONOP(,TensorConvolutionOp)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:272:/// const TensorSlicingOp. This is an specialisation without OP so it has to be separated.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:275:struct FunctorExtractor<TensorEvaluator<CVQual TensorSlicingOp<StartIndices, Sizes, XprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:276:  FunctorExtractor<TensorEvaluator<XprType, Dev> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:279:  FunctorExtractor(const TensorEvaluator<CVQual  TensorSlicingOp<StartIndices, Sizes, XprType>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:289://TensorStridingSlicingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:292:struct FunctorExtractor<TensorEvaluator<CVQual TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Dev> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:293:  FunctorExtractor<TensorEvaluator<XprType, Dev> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:297:  FunctorExtractor(const TensorEvaluator<CVQual  TensorStridingSlicingOp<StartIndices, StopIndices,Strides, XprType>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:308:// Had to separate TensorReshapingOp and TensorShufflingOp. Otherwise it will be mistaken by UnaryCategory
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:311:struct FunctorExtractor<Eigen::TensorEvaluator<CVQual Eigen::OPEXPR<Param, XprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:312:  FunctorExtractor<Eigen::TensorEvaluator<XprType, Dev> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:315:  FunctorExtractor(const Eigen::TensorEvaluator<CVQual Eigen::OPEXPR<Param, XprType>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:319://TensorReshapingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:320:SYCLRESHAPEANDSHUFFLEOPFUNCEXT(TensorReshapingOp, dimensions(), const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:321:SYCLRESHAPEANDSHUFFLEOPFUNCEXT(TensorReshapingOp, dimensions(), )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:323://TensorShufflingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:324:SYCLRESHAPEANDSHUFFLEOPFUNCEXT(TensorShufflingOp, shufflePermutation(), const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:325:SYCLRESHAPEANDSHUFFLEOPFUNCEXT(TensorShufflingOp, shufflePermutation(), )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:331:struct FunctorExtractor<Eigen::TensorEvaluator<CVQual Eigen::OPEXPR<Param, XprType>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:332:  FunctorExtractor<Eigen::TensorEvaluator<XprType, Dev> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:334:  typedef typename Eigen::TensorEvaluator<CVQual Eigen::OPEXPR<Param, XprType>, Dev>::Scalar Scalar;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:338:  FunctorExtractor(const Eigen::TensorEvaluator<CVQual Eigen::OPEXPR<Param, XprType>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:342:PADDINGOPFUNCEXT(TensorPaddingOp, padding(), padding_value(), const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:343:PADDINGOPFUNCEXT(TensorPaddingOp, padding(), padding_value(), )
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:346:/// specialisation of the \ref FunctorExtractor struct when the node type is TensorContractionOp and TensorConcatenationOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:347:/// for TensorContractionOp the LHS and RHS here are the original one no need to apply condition on their type.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:350:struct FunctorExtractor<TensorEvaluator<CVQual OPEXPR<Param, LHSExpr, RHSExpr>, Dev> > {\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:351:  FunctorExtractor<TensorEvaluator<LHSExpr, Dev> > lhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:352:  FunctorExtractor<TensorEvaluator<RHSExpr, Dev> > rhsExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:354:  FunctorExtractor(const TensorEvaluator<CVQual OPEXPR<Param, LHSExpr, RHSExpr>, Dev>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:358:// TensorConcatenationOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:359:SYCLEXTRFUNCCONTRACTCONCAT(TensorConcatenationOp, axis(), const)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:360:SYCLEXTRFUNCCONTRACTCONCAT(TensorConcatenationOp, axis(),)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:363://TensorChippingOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:366:struct FunctorExtractor<TensorEvaluator<CVQual TensorChippingOp<DimId, XprType>, Device> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:367:  FunctorExtractor<Eigen::TensorEvaluator<XprType, Device> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:372:  FunctorExtractor(const TensorEvaluator<CVQual TensorChippingOp<DimId, XprType>, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:380://TensorImagePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:383:struct FunctorExtractor<TensorEvaluator<CVQual TensorImagePatchOp<Rows, Cols, XprType>, Device> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:384:typedef CVQual TensorImagePatchOp<Rows, Cols, XprType> Self;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:385:FunctorExtractor<Eigen::TensorEvaluator<XprType, Device> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:401:FunctorExtractor(const TensorEvaluator<Self, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:416:/// TensorVolumePatchOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:419:struct FunctorExtractor<TensorEvaluator<CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Device> >{\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:420:typedef CVQual TensorVolumePatchOp<Planes, Rows, Cols, XprType> Self;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:421:FunctorExtractor<Eigen::TensorEvaluator<XprType, Device> > xprExpr;\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:443:FunctorExtractor(const TensorEvaluator<Self, Device>& expr)\
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h:464:}  // namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:14: *  TensorArgMaxSycl.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:16: *  TensorArgMaxSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:25:  struct eval<TensorTupleReducerDeviceOp<Dims, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:27:    typedef const TensorTupleReducerDeviceOp<Dims, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:31:  struct nested<TensorTupleReducerDeviceOp<Dims, XprType>, 1,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:32:                typename eval<TensorTupleReducerDeviceOp<Dims, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:34:    typedef TensorTupleReducerDeviceOp<Dims, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:38:struct traits<TensorTupleReducerDeviceOp<StrideDims, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:53:class TensorTupleReducerDeviceOp : public TensorBase<TensorTupleReducerDeviceOp<StrideDims, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:56:  typedef typename Eigen::internal::traits<TensorTupleReducerDeviceOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:58:  typedef typename Eigen::internal::nested<TensorTupleReducerDeviceOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:59:  typedef typename Eigen::internal::traits<TensorTupleReducerDeviceOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:60:  typedef typename Eigen::internal::traits<TensorTupleReducerDeviceOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorTupleReducerDeviceOp(XprType expr,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:98:struct TensorEvaluator<const TensorTupleReducerDeviceOp<StrideDims, ArgType>, SyclKernelDevice>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:100:  typedef TensorTupleReducerDeviceOp<StrideDims, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:105:  typedef typename TensorEvaluator<ArgType, SyclKernelDevice>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:111:    Layout = TensorEvaluator<ArgType, SyclKernelDevice>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:116:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,  const SyclKernelDevice& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:135:typedef typename MakeGlobalPointer<typename TensorEvaluator<ArgType , SyclKernelDevice>::CoeffReturnType >::Type ptr_Dev_type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorArgMaxSycl.h:139: TensorEvaluator<ArgType , SyclKernelDevice> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:15:/** \class TensorKChippingReshaping
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:25:struct traits<TensorChippingOp<DimId, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:38:struct eval<TensorChippingOp<DimId, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:40:  typedef const TensorChippingOp<DimId, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:44:struct nested<TensorChippingOp<DimId, XprType>, 1, typename eval<TensorChippingOp<DimId, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:46:  typedef TensorChippingOp<DimId, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:79:class TensorChippingOp : public TensorBase<TensorChippingOp<DimId, XprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:82:  typedef typename Eigen::internal::traits<TensorChippingOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:85:  typedef typename Eigen::internal::nested<TensorChippingOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:86:  typedef typename Eigen::internal::traits<TensorChippingOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:87:  typedef typename Eigen::internal::traits<TensorChippingOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:89:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorChippingOp(const XprType& expr, const Index offset, const Index dim)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:103:  EIGEN_STRONG_INLINE TensorChippingOp& operator = (const TensorChippingOp& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:105:    typedef TensorAssignOp<TensorChippingOp, const TensorChippingOp> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:107:    internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:113:  EIGEN_STRONG_INLINE TensorChippingOp& operator = (const OtherDerived& other)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:115:    typedef TensorAssignOp<TensorChippingOp, const OtherDerived> Assign;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:117:    internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:130:struct TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:132:  typedef TensorChippingOp<DimId, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:133:  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:147:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:148:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:153:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:159:    const typename TensorEvaluator<ArgType, Device>::Dimensions& input_dims = m_impl.dimensions();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:245:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:252:      cost += TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:257:      cost += TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:259:      cost += 3 * TensorOpCost::MulCost<Index>() + TensorOpCost::DivCost<Index>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:260:              3 * TensorOpCost::AddCost<Index>();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:264:           TensorOpCost(0, 0, cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:288:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:317:  TensorEvaluator<ArgType, Device> m_impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:328:struct TensorEvaluator<TensorChippingOp<DimId, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:329:  : public TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:331:  typedef TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device> Base;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:332:  typedef TensorChippingOp<DimId, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:333:  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:344:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h:348:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:15: * TensorSyclRun.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:27:namespace TensorSycl {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:40:    auto device_evaluator = Eigen::TensorEvaluator<decltype(device_expr.expr), Eigen::SyclKernelDevice>(device_expr.expr, Eigen::SyclKernelDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:71:  Eigen::TensorEvaluator<Expr, Dev> evaluator(expr, dev);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:74:    typedef Eigen::TensorSycl::internal::FunctorExtractor<Eigen::TensorEvaluator<Expr, Dev> > FunctorExpr;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:78:      typedef decltype(internal::createTupleOfAccessors<Eigen::TensorEvaluator<Expr, Dev> >(cgh, evaluator)) TupleType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:79:      TupleType tuple_of_accessors = internal::createTupleOfAccessors<Eigen::TensorEvaluator<Expr, Dev> >(cgh, evaluator);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:81:      typename Expr::Index total_size = static_cast<typename Expr::Index>(DimensionSize<typename Expr::Index, typename Eigen::TensorEvaluator<Expr, Dev>::Dimensions>::getDimSize(evaluator.dimensions()));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h:93:}  // namespace TensorSycl
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:15:/** \class TensorAssign
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:25:struct traits<TensorAssignOp<LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:44:struct eval<TensorAssignOp<LhsXprType, RhsXprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:46:  typedef const TensorAssignOp<LhsXprType, RhsXprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:50:struct nested<TensorAssignOp<LhsXprType, RhsXprType>, 1, typename eval<TensorAssignOp<LhsXprType, RhsXprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:52:  typedef TensorAssignOp<LhsXprType, RhsXprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:60:class TensorAssignOp : public TensorBase<TensorAssignOp<LhsXprType, RhsXprType> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:63:  typedef typename Eigen::internal::traits<TensorAssignOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:66:  typedef typename Eigen::internal::nested<TensorAssignOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:67:  typedef typename Eigen::internal::traits<TensorAssignOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:68:  typedef typename Eigen::internal::traits<TensorAssignOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:70:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorAssignOp(LhsXprType& lhs, const RhsXprType& rhs)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:89:struct TensorEvaluator<const TensorAssignOp<LeftArgType, RightArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:91:  typedef TensorAssignOp<LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:96:  typedef typename TensorEvaluator<RightArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:100:    IsAligned = TensorEvaluator<LeftArgType, Device>::IsAligned & TensorEvaluator<RightArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:101:    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:102:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:103:    RawAccess = TensorEvaluator<LeftArgType, Device>::RawAccess
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:106:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:110:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<LeftArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<RightArgType, Device>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:139:    const int LhsStoreMode = TensorEvaluator<LeftArgType, Device>::IsAligned ? Aligned : Unaligned;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:140:    const int RhsLoadMode = TensorEvaluator<RightArgType, Device>::IsAligned ? Aligned : Unaligned;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:153:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:158:    TensorOpCost left = m_leftImpl.costPerCoeff(vectorized);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:160:           TensorOpCost(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:163:           TensorOpCost(0, sizeof(CoeffReturnType), 0, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:167:  const TensorEvaluator<LeftArgType, Device>& left_impl() const { return m_leftImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:169:  const TensorEvaluator<RightArgType, Device>& right_impl() const { return m_rightImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:174:  TensorEvaluator<LeftArgType, Device> m_leftImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h:175:  TensorEvaluator<RightArgType, Device> m_rightImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGlobalFunctions.h:22:    TensorCwiseTernaryOp<internal::scalar_betainc_op<typename XDerived::Scalar>,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGlobalFunctions.h:25:  return TensorCwiseTernaryOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:18:  * \class TensorIntDiv
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:19:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:26:  * \sa Tensor
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:112:    return (TensorUInt128<static_val<0>, uint64_t>(a) * TensorUInt128<static_val<0>, uint64_t>(b)).upper();
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:131:      TensorUInt128<uint64_t, uint64_t> result = TensorUInt128<uint64_t, static_val<0> >(shift, 0) / TensorUInt128<static_val<0>, uint64_t>(divider)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:132:                                               - TensorUInt128<static_val<1>, static_val<0> >(1, 0)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:133:                                               + TensorUInt128<static_val<0>, static_val<1> >(1);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:142:struct TensorIntDivisor {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:144:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:153:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor(const T divider) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:193:class TensorIntDivisor<int32_t, true> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:195:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor() {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:200:  EIGEN_DEVICE_FUNC TensorIntDivisor(int32_t divider)  {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h:255:static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator / (const T& numerator, const TensorIntDivisor<T, div_gt_one>& divisor) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:15:/** \class TensorEvaluator
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:28:struct TensorEvaluator
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:49:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const Derived& m, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:53:  // Used for accessor extraction in SYCL Managed TensorMap:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:111:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:112:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:153:struct TensorEvaluator<const Derived, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:175:  // Used for accessor extraction in SYCL Managed TensorMap:
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:178:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const Derived& m, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:217:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:218:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:240:struct TensorEvaluator<const TensorCwiseNullaryOp<NullaryOp, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:242:  typedef TensorCwiseNullaryOp<NullaryOp, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:247:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:253:  TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:262:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:280:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:282:    return TensorOpCost(sizeof(CoeffReturnType), 0, 0, vectorized,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:289:  const TensorEvaluator<ArgType, Device>& impl() const { return m_argImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:296:  TensorEvaluator<ArgType, Device> m_argImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:305:struct TensorEvaluator<const TensorCwiseUnaryOp<UnaryOp, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:307:  typedef TensorCwiseUnaryOp<UnaryOp, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:310:    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:311:    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess & internal::functor_traits<UnaryOp>::PacketAccess,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:312:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:317:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:327:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:350:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:353:        TensorOpCost(0, 0, functor_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:359:  const TensorEvaluator<ArgType, Device> & impl() const { return m_argImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:366:  TensorEvaluator<ArgType, Device> m_argImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:373:struct TensorEvaluator<const TensorCwiseBinaryOp<BinaryOp, LeftArgType, RightArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:375:  typedef TensorCwiseBinaryOp<BinaryOp, LeftArgType, RightArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:378:    IsAligned = TensorEvaluator<LeftArgType, Device>::IsAligned & TensorEvaluator<RightArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:379:    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess &
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:381:    Layout = TensorEvaluator<LeftArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:386:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:391:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<LeftArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<RightArgType, Device>::Layout) || internal::traits<XprType>::NumDimensions <= 1), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:400:  typedef typename TensorEvaluator<LeftArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:428:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:433:           TensorOpCost(0, 0, functor_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:438:  const TensorEvaluator<LeftArgType, Device>& left_impl() const { return m_leftImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:440:  const TensorEvaluator<RightArgType, Device>& right_impl() const { return m_rightImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:446:  TensorEvaluator<LeftArgType, Device> m_leftImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:447:  TensorEvaluator<RightArgType, Device> m_rightImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:453:struct TensorEvaluator<const TensorCwiseTernaryOp<TernaryOp, Arg1Type, Arg2Type, Arg3Type>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:455:  typedef TensorCwiseTernaryOp<TernaryOp, Arg1Type, Arg2Type, Arg3Type> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:458:    IsAligned = TensorEvaluator<Arg1Type, Device>::IsAligned & TensorEvaluator<Arg2Type, Device>::IsAligned & TensorEvaluator<Arg3Type, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:459:    PacketAccess = TensorEvaluator<Arg1Type, Device>::PacketAccess & TensorEvaluator<Arg2Type, Device>::PacketAccess & TensorEvaluator<Arg3Type, Device>::PacketAccess &
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:461:    Layout = TensorEvaluator<Arg1Type, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:466:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:472:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<Arg1Type, Device>::Layout) == static_cast<int>(TensorEvaluator<Arg3Type, Device>::Layout) || internal::traits<XprType>::NumDimensions <= 1), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:495:  typedef typename TensorEvaluator<Arg1Type, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:527:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:533:           TensorOpCost(0, 0, functor_cost, vectorized, PacketSize);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:539:  const TensorEvaluator<Arg1Type, Device> & arg1Impl() const { return m_arg1Impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:541:  const TensorEvaluator<Arg2Type, Device>& arg2Impl() const { return m_arg2Impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:543:  const TensorEvaluator<Arg3Type, Device>& arg3Impl() const { return m_arg3Impl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:547:  TensorEvaluator<Arg1Type, Device> m_arg1Impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:548:  TensorEvaluator<Arg2Type, Device> m_arg2Impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:549:  TensorEvaluator<Arg3Type, Device> m_arg3Impl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:556:struct TensorEvaluator<const TensorSelectOp<IfArgType, ThenArgType, ElseArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:558:  typedef TensorSelectOp<IfArgType, ThenArgType, ElseArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:562:    IsAligned = TensorEvaluator<ThenArgType, Device>::IsAligned & TensorEvaluator<ElseArgType, Device>::IsAligned,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:563:    PacketAccess = TensorEvaluator<ThenArgType, Device>::PacketAccess & TensorEvaluator<ElseArgType, Device>::PacketAccess &
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:565:    Layout = TensorEvaluator<IfArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:570:  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:575:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<IfArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<ThenArgType, Device>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:576:    EIGEN_STATIC_ASSERT((static_cast<int>(TensorEvaluator<IfArgType, Device>::Layout) == static_cast<int>(TensorEvaluator<ElseArgType, Device>::Layout)), YOU_MADE_A_PROGRAMMING_MISTAKE);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:585:  typedef typename TensorEvaluator<IfArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:621:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:630:  const TensorEvaluator<IfArgType, Device> & cond_impl() const { return m_condImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:632:  const TensorEvaluator<ThenArgType, Device>& then_impl() const { return m_thenImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:634:  const TensorEvaluator<ElseArgType, Device>& else_impl() const { return m_elseImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:637:  TensorEvaluator<IfArgType, Device> m_condImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:638:  TensorEvaluator<ThenArgType, Device> m_thenImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h:639:  TensorEvaluator<ElseArgType, Device> m_elseImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:15:/** \class TensorEvaluator
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:25:class TensorOpCost {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:55:  TensorOpCost() : bytes_loaded_(0), bytes_stored_(0), compute_cycles_(0) {}
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:57:  TensorOpCost(double bytes_loaded, double bytes_stored, double compute_cycles)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:63:  TensorOpCost(double bytes_loaded, double bytes_stored, double compute_cycles,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:97:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost cwiseMin(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:98:      const TensorOpCost& rhs) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:102:    return TensorOpCost(bytes_loaded, bytes_stored, compute_cycles);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:106:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost cwiseMax(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:107:      const TensorOpCost& rhs) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:111:    return TensorOpCost(bytes_loaded, bytes_stored, compute_cycles);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:114:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost& operator+=(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:115:      const TensorOpCost& rhs) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:122:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost& operator*=(double rhs) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:129:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE friend TensorOpCost operator+(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:130:      TensorOpCost lhs, const TensorOpCost& rhs) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:134:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE friend TensorOpCost operator*(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:135:      TensorOpCost lhs, double rhs) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:139:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE friend TensorOpCost operator*(
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:140:      double lhs, TensorOpCost rhs) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:145:  friend std::ostream& operator<<(std::ostream& os, const TensorOpCost& tc) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:161:class TensorCostModel {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:175:      double output_size, const TensorOpCost& cost_per_coeff, int max_threads) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:185:      double output_size, const TensorOpCost& cost_per_coeff) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h:191:      double output_size, const TensorOpCost& cost_per_coeff) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:15:/** \class TensorGenerator
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:16:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:18:  * \brief Tensor generator class.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:24:struct traits<TensorGeneratorOp<Generator, XprType> > : public traits<XprType>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:37:struct eval<TensorGeneratorOp<Generator, XprType>, Eigen::Dense>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:39:  typedef const TensorGeneratorOp<Generator, XprType>& type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:43:struct nested<TensorGeneratorOp<Generator, XprType>, 1, typename eval<TensorGeneratorOp<Generator, XprType> >::type>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:45:  typedef TensorGeneratorOp<Generator, XprType> type;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:53:class TensorGeneratorOp : public TensorBase<TensorGeneratorOp<Generator, XprType>, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:56:  typedef typename Eigen::internal::traits<TensorGeneratorOp>::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:59:  typedef typename Eigen::internal::nested<TensorGeneratorOp>::type Nested;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:60:  typedef typename Eigen::internal::traits<TensorGeneratorOp>::StorageKind StorageKind;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:61:  typedef typename Eigen::internal::traits<TensorGeneratorOp>::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:63:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorGeneratorOp(const XprType& expr, const Generator& generator)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:81:struct TensorEvaluator<const TensorGeneratorOp<Generator, ArgType>, Device>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:83:  typedef TensorGeneratorOp<Generator, ArgType> XprType;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:85:  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:94:    Layout = TensorEvaluator<ArgType, Device>::Layout,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:99:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:105:    TensorEvaluator<ArgType, Device> argImpl(op.expression(), device);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:151:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:155:    return TensorOpCost(0, 0, TensorOpCost::AddCost<Scalar>() +
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:156:                                  TensorOpCost::MulCost<Scalar>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:162:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& impl() const { return m_argImpl; }
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h:190:  TensorEvaluator<ArgType, Device> m_argImpl;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:19:/** \class TensorInitializer
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:20:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:22:  * \brief Helper template to initialize Tensors from std::initializer_lists.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:31:  static void run(TensorEvaluator<Derived, DefaultDevice>& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:46:  static void run(TensorEvaluator<Derived, DefaultDevice>& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:62:  static void run(TensorEvaluator<Derived, DefaultDevice>& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h:71:void initialize_tensor(TensorEvaluator<Derived, DefaultDevice>& tensor,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:17:/** \class TensorBase
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:18:  * \ingroup CXX11_Tensor_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:22:  * This class is the common parent of the Tensor and TensorMap class, thus
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:27:class TensorBase<Derived, ReadOnlyAccessors>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:38:    EIGEN_STRONG_INLINE const TensorCwiseNullaryOp<CustomNullaryOp, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:40:      return TensorCwiseNullaryOp<CustomNullaryOp, const Derived>(derived(), func);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:45:    EIGEN_STRONG_INLINE const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:51:    EIGEN_STRONG_INLINE const TensorCwiseNullaryOp<internal::UniformRandomGenerator<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:56:    EIGEN_STRONG_INLINE const TensorCwiseNullaryOp<RandomGenerator, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:61:    // Tensor generation
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:63:    EIGEN_STRONG_INLINE const TensorGeneratorOp<Generator, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:65:      return TensorGeneratorOp<Generator, const Derived>(derived(), generator);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:70:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<CustomUnaryOp, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:72:      return TensorCwiseUnaryOp<CustomUnaryOp, const Derived>(derived(), func);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:77:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_opposite_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:83:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:89:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:95:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_rsqrt_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:101:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_square_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:107:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_cube_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:113:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:119:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_tanh_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:125:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_lgamma_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:131:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_digamma_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:138:    const TensorCwiseBinaryOp<internal::scalar_igamma_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:145:    const TensorCwiseBinaryOp<internal::scalar_igammac_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:152:    const TensorCwiseBinaryOp<internal::scalar_zeta_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:159:    const TensorCwiseBinaryOp<internal::scalar_polygamma_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:165:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_erf_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:171:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_erfc_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:177:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_sigmoid_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:183:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_exp_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:189:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_expm1_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:195:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_log_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:201:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_log1p_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:207:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:213:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:219:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::bind2nd_op<internal::scalar_pow_op<Scalar,Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:225:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_real_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:231:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:237:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::bind2nd_op<internal::scalar_sum_op<Scalar,Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:244:    const TensorCwiseUnaryOp<internal::bind1st_op<internal::scalar_sum_op<Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:250:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::bind2nd_op<internal::scalar_difference_op<Scalar,Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:258:    const TensorCwiseUnaryOp<internal::bind1st_op<internal::scalar_difference_op<Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:264:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::bind2nd_op<internal::scalar_product_op<Scalar,Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:271:    const TensorCwiseUnaryOp<internal::bind1st_op<internal::scalar_product_op<Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:277:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::bind2nd_op<internal::scalar_quotient_op<Scalar,Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:284:    const TensorCwiseUnaryOp<internal::bind1st_op<internal::scalar_quotient_op<Scalar> >, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:290:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_mod_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:297:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:303:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:309:    EIGEN_STRONG_INLINE const TensorConversionOp<NewType, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:311:      return TensorConversionOp<NewType, const Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:315:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_round_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:321:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_ceil_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:327:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_floor_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:334:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:336:      return TensorCwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>(derived(), other, func);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:341:    const TensorCwiseBinaryOp<internal::scalar_sum_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:347:    const TensorCwiseBinaryOp<internal::scalar_difference_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:353:    const TensorCwiseBinaryOp<internal::scalar_product_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:359:    const TensorCwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:365:    const TensorCwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:371:    const TensorCwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:377:    const TensorCwiseBinaryOp<internal::scalar_boolean_and_op, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:383:    const TensorCwiseBinaryOp<internal::scalar_boolean_or_op, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:389:    const TensorCwiseBinaryOp<internal::scalar_boolean_xor_op, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:396:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_LT>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:401:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_LE>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:406:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_GT>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:411:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_GE>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:417:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_EQ>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:423:    const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_NEQ>, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:430:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_LT>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:435:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_LE>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:440:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_GT>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:445:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_GE>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:450:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_EQ>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:455:    EIGEN_STRONG_INLINE const TensorCwiseBinaryOp<internal::scalar_cmp_op<Scalar, Scalar, internal::cmp_NEQ>, const Derived, const TensorCwiseNullaryOp<internal::scalar_constant_op<Scalar>, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:462:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_isnan_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:467:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_isinf_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:472:    EIGEN_STRONG_INLINE const TensorCwiseUnaryOp<internal::scalar_isfinite_op<Scalar>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:479:    const TensorSelectOp<const Derived, const ThenDerived, const ElseDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:480:    select(const ThenDerived& thenTensor, const ElseDerived& elseTensor) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:481:      return TensorSelectOp<const Derived, const ThenDerived, const ElseDerived>(derived(), thenTensor.derived(), elseTensor.derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:488:    const TensorContractionOp<const Dimensions, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:490:      return TensorContractionOp<const Dimensions, const Derived, const OtherDerived>(derived(), other.derived(), dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:495:    const TensorConvolutionOp<const Dimensions, const Derived, const KernelDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:497:      return TensorConvolutionOp<const Dimensions, const Derived, const KernelDerived>(derived(), kernel.derived(), dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:502:    const TensorFFTOp<const FFT, const Derived, FFTDataType, FFTDirection>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:504:      return TensorFFTOp<const FFT, const Derived, FFTDataType, FFTDirection>(derived(), fft);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:508:    typedef TensorScanOp<internal::SumReducer<CoeffReturnType>, const Derived> TensorScanSumOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:510:    const TensorScanSumOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:512:      return TensorScanSumOp(derived(), axis, exclusive);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:515:    typedef TensorScanOp<internal::ProdReducer<CoeffReturnType>, const Derived> TensorScanProdOp;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:517:    const TensorScanProdOp
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:519:      return TensorScanProdOp(derived(), axis, exclusive);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:524:    const TensorScanOp<Reducer, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:526:      return TensorScanOp<Reducer, const Derived>(derived(), axis, exclusive, reducer);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:531:    const TensorReductionOp<internal::SumReducer<CoeffReturnType>, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:533:      return TensorReductionOp<internal::SumReducer<CoeffReturnType>, const Dims, const Derived>(derived(), dims, internal::SumReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:536:    const TensorReductionOp<internal::SumReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:539:      return TensorReductionOp<internal::SumReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>(derived(), in_dims, internal::SumReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:543:    const TensorReductionOp<internal::MeanReducer<CoeffReturnType>, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:545:      return TensorReductionOp<internal::MeanReducer<CoeffReturnType>, const Dims, const Derived>(derived(), dims, internal::MeanReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:548:    const TensorReductionOp<internal::MeanReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:551:      return TensorReductionOp<internal::MeanReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>(derived(), in_dims, internal::MeanReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:555:    const TensorReductionOp<internal::ProdReducer<CoeffReturnType>, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:557:      return TensorReductionOp<internal::ProdReducer<CoeffReturnType>, const Dims, const Derived>(derived(), dims, internal::ProdReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:560:    const TensorReductionOp<internal::ProdReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:563:      return TensorReductionOp<internal::ProdReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>(derived(), in_dims, internal::ProdReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:567:    const TensorReductionOp<internal::MaxReducer<CoeffReturnType>, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:569:      return TensorReductionOp<internal::MaxReducer<CoeffReturnType>, const Dims, const Derived>(derived(), dims, internal::MaxReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:572:    const TensorReductionOp<internal::MaxReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:575:      return TensorReductionOp<internal::MaxReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>(derived(), in_dims, internal::MaxReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:579:    const TensorReductionOp<internal::MinReducer<CoeffReturnType>, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:581:      return TensorReductionOp<internal::MinReducer<CoeffReturnType>, const Dims, const Derived>(derived(), dims, internal::MinReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:584:    const TensorReductionOp<internal::MinReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:587:      return TensorReductionOp<internal::MinReducer<CoeffReturnType>, const DimensionList<Index, NumDimensions>, const Derived>(derived(), in_dims, internal::MinReducer<CoeffReturnType>());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:591:    const TensorReductionOp<internal::AndReducer, const Dims, const TensorConversionOp<bool, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:597:    const TensorReductionOp<internal::AndReducer, const DimensionList<Index, NumDimensions>, const TensorConversionOp<bool, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:604:    const TensorReductionOp<internal::OrReducer, const Dims, const TensorConversionOp<bool, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:610:    const TensorReductionOp<internal::OrReducer, const DimensionList<Index, NumDimensions>, const TensorConversionOp<bool, const Derived> >
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:617:    const TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:623:      return TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:630:    const TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:636:      return TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:643:    const TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:649:      return TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:656:    const TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:662:      return TensorTupleReducerOp<
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:669:    const TensorReductionOp<Reducer, const Dims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:671:      return TensorReductionOp<Reducer, const Dims, const Derived>(derived(), dims, reducer);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:675:    const TensorBroadcastingOp<const Broadcast, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:677:      return TensorBroadcastingOp<const Broadcast, const Derived>(derived(), broadcast);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:681:    const TensorConcatenationOp<Axis, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:683:      return TensorConcatenationOp<Axis, const Derived, const OtherDerived>(derived(), other.derived(), axis);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:687:    const TensorPatchOp<const PatchDims, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:689:      return TensorPatchOp<const PatchDims, const Derived>(derived(), patch_dims);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:693:    const TensorImagePatchOp<Dynamic, Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:698:      return TensorImagePatchOp<Dynamic, Dynamic, const Derived>(derived(), patch_rows, patch_cols, row_stride, col_stride,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:703:    const TensorImagePatchOp<Dynamic, Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:711:      return TensorImagePatchOp<Dynamic, Dynamic, const Derived>(derived(), patch_rows, patch_cols, row_stride, col_stride,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:717:    const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:721:      return TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Derived>(derived(), patch_planes, patch_rows, patch_cols, plane_stride, row_stride, col_stride, 1, 1, 1, 1, 1, 1, padding_type, padding_value);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:726:    const TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:733:      return TensorVolumePatchOp<Dynamic, Dynamic, Dynamic, const Derived>(derived(), patch_planes, patch_rows, patch_cols, plane_stride, row_stride, col_stride, 1, 1, 1, plane_inflate_stride, row_inflate_stride, col_inflate_stride, padding_top_z, padding_bottom_z, padding_top, padding_bottom, padding_left, padding_right, padding_value);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:738:    const TensorLayoutSwapOp<const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:740:      return TensorLayoutSwapOp<const Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:743:    const TensorReshapingOp<const NewDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:745:      return TensorReshapingOp<const NewDimensions, const Derived>(derived(), newDimensions);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:748:    const TensorSlicingOp<const StartIndices, const Sizes, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:750:      return TensorSlicingOp<const StartIndices, const Sizes, const Derived>(derived(), startIndices, sizes);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:753:    const TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:755:      return TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:759:    const TensorChippingOp<DimId, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:761:      return TensorChippingOp<DimId, const Derived>(derived(), offset, DimId);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:764:    const TensorChippingOp<Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:766:      return TensorChippingOp<Dynamic, const Derived>(derived(), offset, dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:769:    const TensorReverseOp<const ReverseDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:771:      return TensorReverseOp<const ReverseDimensions, const Derived>(derived(), rev);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:774:    const TensorPaddingOp<const PaddingDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:776:      return TensorPaddingOp<const PaddingDimensions, const Derived>(derived(), padding, internal::scalar_cast_op<int, Scalar>()(0));
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:779:    const TensorPaddingOp<const PaddingDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:781:      return TensorPaddingOp<const PaddingDimensions, const Derived>(derived(), padding, padding_value);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:784:    const TensorShufflingOp<const Shuffle, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:786:      return TensorShufflingOp<const Shuffle, const Derived>(derived(), shuffle);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:789:    const TensorStridingOp<const Strides, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:791:      return TensorStridingOp<const Strides, const Derived>(derived(), strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:794:    const TensorInflationOp<const Strides, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:796:      return TensorInflationOp<const Strides, const Derived>(derived(), strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:801:    const TensorIndexTupleOp<const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:803:      return TensorIndexTupleOp<const Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:809:    const TensorCustomUnaryOp<const CustomUnaryFunc, const Derived> customOp(const CustomUnaryFunc& op) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:810:      return TensorCustomUnaryOp<const CustomUnaryFunc, const Derived>(derived(), op);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:814:    const TensorCustomBinaryOp<const CustomBinaryFunc, const Derived, const OtherDerived> customOp(const OtherDerived& other, const CustomBinaryFunc& op) const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:815:      return TensorCustomBinaryOp<const CustomBinaryFunc, const Derived, const OtherDerived>(derived(), other, op);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:820:    const TensorForcedEvalOp<const Derived> eval() const {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:821:      return TensorForcedEvalOp<const Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:825:    template <typename Scalar, int NumIndices, int Options, typename IndexType> friend class Tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:826:    template <typename Scalar, typename Dimensions, int Option, typename IndexTypes> friend class TensorFixedSize;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:827:    template <typename OtherDerived, int AccessLevel> friend class TensorBase;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:833:class TensorBase : public TensorBase<Derived, ReadOnlyAccessors> {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:841:    template <typename Scalar, int NumIndices, int Options, typename IndexType> friend class Tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:842:    template <typename Scalar, typename Dimensions, int Option, typename IndexTypes> friend class TensorFixedSize;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:843:    template <typename OtherDerived, int OtherAccessLevel> friend class TensorBase;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:866:      TensorEvaluator<Derived, DefaultDevice> eval(derived(), DefaultDevice());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:890:    const TensorLayoutSwapOp<const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:892:      return TensorLayoutSwapOp<const Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:895:    TensorLayoutSwapOp<Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:897:      return TensorLayoutSwapOp<Derived>(derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:901:    const TensorConcatenationOp<const Axis, const Derived, const OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:903:      return TensorConcatenationOp<const Axis, const Derived, const OtherDerived>(derived(), other, axis);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:906:    TensorConcatenationOp<const Axis, Derived, OtherDerived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:908:      return TensorConcatenationOp<const Axis, Derived, OtherDerived>(derived(), other, axis);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:912:    const TensorReshapingOp<const NewDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:914:      return TensorReshapingOp<const NewDimensions, const Derived>(derived(), newDimensions);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:917:    TensorReshapingOp<const NewDimensions, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:919:      return TensorReshapingOp<const NewDimensions, Derived>(derived(), newDimensions);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:923:    const TensorSlicingOp<const StartIndices, const Sizes, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:925:      return TensorSlicingOp<const StartIndices, const Sizes, const Derived>(derived(), startIndices, sizes);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:928:    TensorSlicingOp<const StartIndices, const Sizes, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:930:      return TensorSlicingOp<const StartIndices, const Sizes, Derived>(derived(), startIndices, sizes);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:934:    const TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:936:      return TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:940:    TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:942:      return TensorStridingSlicingOp<const StartIndices, const StopIndices, const Strides,
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:947:    const TensorChippingOp<DimId, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:949:      return TensorChippingOp<DimId, const Derived>(derived(), offset, DimId);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:952:    TensorChippingOp<DimId, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:954:      return TensorChippingOp<DimId, Derived>(derived(), offset, DimId);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:958:    const TensorChippingOp<Dynamic, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:960:      return TensorChippingOp<Dynamic, const Derived>(derived(), offset, dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:963:    TensorChippingOp<Dynamic, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:965:      return TensorChippingOp<Dynamic, Derived>(derived(), offset, dim);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:969:    const TensorReverseOp<const ReverseDimensions, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:971:      return TensorReverseOp<const ReverseDimensions, const Derived>(derived(), rev);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:974:    TensorReverseOp<const ReverseDimensions, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:976:      return TensorReverseOp<const ReverseDimensions, Derived>(derived(), rev);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:980:    const TensorShufflingOp<const Shuffle, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:982:      return TensorShufflingOp<const Shuffle, const Derived>(derived(), shuffle);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:985:    TensorShufflingOp<const Shuffle, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:987:      return TensorShufflingOp<const Shuffle, Derived>(derived(), shuffle);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:991:    const TensorStridingOp<const Strides, const Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:993:      return TensorStridingOp<const Strides, const Derived>(derived(), strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:996:    TensorStridingOp<const Strides, Derived>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:998:      return TensorStridingOp<const Strides, Derived>(derived(), strides);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:1003:    TensorDevice<Derived, DeviceType> device(const DeviceType& device) {
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/Tensor/TensorBase.h:1004:      return TensorDevice<Derived, DeviceType>(device, derived());
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:31:template<typename Tensor_> struct tensor_symmetry_calculate_flags;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:32:template<typename Tensor_> struct tensor_symmetry_assign_value;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:74:  * \ingroup TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:91:  * \ingroup TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:102:  * \ingroup TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:124:  * \ingroup TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:182:  * \ingroup TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:257:template<typename Tensor_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:260:  typedef typename Tensor_::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:261:  typedef typename Tensor_::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:262:  constexpr static std::size_t NumIndices = Tensor_::NumIndices;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:264:  static inline int run(const std::array<Index, NumIndices>& transformed_indices, int transformation_flags, int dummy, Tensor_& tensor, const Scalar& value_)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:276:template<typename Tensor_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:279:  typedef typename Tensor_::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:280:  constexpr static std::size_t NumIndices = Tensor_::NumIndices;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:296:template<typename Tensor_, typename Symmetry_, int Flags = 0>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:300:    typedef typename Tensor_::Index Index;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:301:    typedef typename Tensor_::Scalar Scalar;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:302:    constexpr static std::size_t NumIndices = Tensor_::NumIndices;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:304:    inline tensor_symmetry_value_setter(Tensor_& tensor, Symmetry_ const& symmetry, std::array<Index, NumIndices> const& indices)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:307:    inline tensor_symmetry_value_setter<Tensor_, Symmetry_, Flags>& operator=(Scalar const& value)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:313:    Tensor_& m_tensor;
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:320:        int value_flags = m_symmetry.template apply<internal::tensor_symmetry_calculate_flags<Tensor_>, int>(m_indices, m_symmetry.globalFlags(), m_indices);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h:326:      m_symmetry.template apply<internal::tensor_symmetry_assign_value<Tensor_>, int>(m_indices, 0, m_tensor, value);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:54:    template<typename Tensor_, typename... IndexTypes>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:55:    inline internal::tensor_symmetry_value_setter<Tensor_, DynamicSGroup> operator()(Tensor_& tensor, typename Tensor_::Index firstIndex, IndexTypes... otherIndices) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:57:      static_assert(sizeof...(otherIndices) + 1 == Tensor_::NumIndices, "Number of indices used to access a tensor coefficient must be equal to the rank of the tensor.");
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:58:      return operator()(tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices>{{firstIndex, otherIndices...}});
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:61:    template<typename Tensor_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:62:    inline internal::tensor_symmetry_value_setter<Tensor_, DynamicSGroup> operator()(Tensor_& tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices> const& indices) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h:64:      return internal::tensor_symmetry_value_setter<Tensor_, DynamicSGroup>(tensor, *this, indices);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:20:  * \file CXX11/Tensor/util/TemplateGroupTheory.h
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:109:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:151:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:198:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:236:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:277:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:365:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:440:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:502:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:570:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h:625:  * \ingroup CXX11_TensorSymmetry_Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:216:    template<typename Tensor_, typename... IndexTypes>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:217:    inline internal::tensor_symmetry_value_setter<Tensor_, StaticSGroup<Gen...>> operator()(Tensor_& tensor, typename Tensor_::Index firstIndex, IndexTypes... otherIndices) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:219:      static_assert(sizeof...(otherIndices) + 1 == Tensor_::NumIndices, "Number of indices used to access a tensor coefficient must be equal to the rank of the tensor.");
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:220:      return operator()(tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices>{{firstIndex, otherIndices...}});
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:223:    template<typename Tensor_>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:224:    inline internal::tensor_symmetry_value_setter<Tensor_, StaticSGroup<Gen...>> operator()(Tensor_& tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices> const& indices) const
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h:226:      return internal::tensor_symmetry_value_setter<Tensor_, StaticSGroup<Gen...>>(tensor, *this, indices);
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/CMakeLists.txt:1:set(Eigen_CXX11_HEADERS Tensor TensorSymmetry ThreadPool)
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:35:/** \defgroup CXX11_Tensor_Module Tensor Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:37:  * This module provides a Tensor class for storing arbitrarily indexed
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:41:  * #include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:91:#include "src/Tensor/TensorMacros.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:92:#include "src/Tensor/TensorForwardDeclarations.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:93:#include "src/Tensor/TensorMeta.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:94:#include "src/Tensor/TensorFunctors.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:95:#include "src/Tensor/TensorCostModel.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:96:#include "src/Tensor/TensorDeviceDefault.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:97:#include "src/Tensor/TensorDeviceThreadPool.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:98:#include "src/Tensor/TensorDeviceCuda.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:99:#include "src/Tensor/TensorDeviceSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:100:#include "src/Tensor/TensorIndexList.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:101:#include "src/Tensor/TensorDimensionList.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:102:#include "src/Tensor/TensorDimensions.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:103:#include "src/Tensor/TensorInitializer.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:104:#include "src/Tensor/TensorTraits.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:105:#include "src/Tensor/TensorRandom.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:106:#include "src/Tensor/TensorUInt128.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:107:#include "src/Tensor/TensorIntDiv.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:108:#include "src/Tensor/TensorGlobalFunctions.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:110:#include "src/Tensor/TensorBase.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:112:#include "src/Tensor/TensorEvaluator.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:113:#include "src/Tensor/TensorExpr.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:114:#include "src/Tensor/TensorReduction.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:115:#include "src/Tensor/TensorReductionCuda.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:116:#include "src/Tensor/TensorArgMax.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:117:#include "src/Tensor/TensorConcatenation.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:118:#include "src/Tensor/TensorContractionMapper.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:119:#include "src/Tensor/TensorContractionBlocking.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:120:#include "src/Tensor/TensorContraction.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:121:#include "src/Tensor/TensorContractionThreadPool.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:122:#include "src/Tensor/TensorContractionCuda.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:123:#include "src/Tensor/TensorConversion.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:124:#include "src/Tensor/TensorConvolution.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:125:#include "src/Tensor/TensorFFT.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:126:#include "src/Tensor/TensorPatch.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:127:#include "src/Tensor/TensorImagePatch.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:128:#include "src/Tensor/TensorVolumePatch.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:129:#include "src/Tensor/TensorBroadcasting.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:130:#include "src/Tensor/TensorChipping.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:131:#include "src/Tensor/TensorInflation.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:132:#include "src/Tensor/TensorLayoutSwap.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:133:#include "src/Tensor/TensorMorphing.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:134:#include "src/Tensor/TensorPadding.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:135:#include "src/Tensor/TensorReverse.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:136:#include "src/Tensor/TensorShuffling.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:137:#include "src/Tensor/TensorStriding.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:138:#include "src/Tensor/TensorCustomOp.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:139:#include "src/Tensor/TensorEvalTo.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:140:#include "src/Tensor/TensorForcedEval.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:141:#include "src/Tensor/TensorGenerator.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:142:#include "src/Tensor/TensorAssign.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:143:#include "src/Tensor/TensorScan.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:145:#include "src/Tensor/TensorSycl.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:146:#include "src/Tensor/TensorExecutor.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:147:#include "src/Tensor/TensorDevice.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:149:#include "src/Tensor/TensorStorage.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:150:#include "src/Tensor/Tensor.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:151:#include "src/Tensor/TensorFixedSize.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:152:#include "src/Tensor/TensorMap.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:153:#include "src/Tensor/TensorRef.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/Tensor:155:#include "src/Tensor/TensorIO.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:13:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:19:/** \defgroup CXX11_TensorSymmetry_Module Tensor Symmetry Module
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:24:  * Including this module will implicitly include the Tensor module.
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:27:  * #include <Eigen/TensorSymmetry>
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:31:#include "src/TensorSymmetry/util/TemplateGroupTheory.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:32:#include "src/TensorSymmetry/Symmetry.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:33:#include "src/TensorSymmetry/StaticSymmetry.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/CXX11/TensorSymmetry:34:#include "src/TensorSymmetry/DynamicSymmetry.h"
build/third_party/eigen3/src/eigen3/unsupported/Eigen/KroneckerProduct:32:#include "src/KroneckerProduct/KroneckerTensorProduct.h"
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device_sycl.cpp:32:  Tensor<DataType, 1, DataLayout,IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device_sycl.cpp:33:  Tensor<DataType, 1, DataLayout,IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device_sycl.cpp:52:  TensorMap<Tensor<DataType, 1, DataLayout,IndexType>> in(gpu_data, tensorDims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device_sycl.cpp:53:  TensorMap<Tensor<DataType, 1, DataLayout,IndexType>> out(gpu_data, tensorDims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:17:  Tensor<float, 2> source;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:18:  Tensor<float, 2> tgt1 = source;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:19:  Tensor<float, 2> tgt2(source);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:20:  Tensor<float, 2> tgt3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:27:  TensorFixedSize<float, Sizes<0> > source;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:28:  TensorFixedSize<float, Sizes<0> > tgt1 = source;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:29:  TensorFixedSize<float, Sizes<0> > tgt2(source);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_empty.cpp:30:  TensorFixedSize<float, Sizes<0> > tgt3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:19:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:21:  Tensor<char, 2> chartensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:23:  Tensor<std::complex<float>, 2> cplextensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:40:  Tensor<int, 2> itensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:42:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:44:  Tensor<double, 2> dtensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:61:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:63:  Tensor<double, 2> dtensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:66:  Tensor<int, 2> i1tensor = ftensor.cast<int>();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:67:  Tensor<int, 2> i2tensor = dtensor.cast<int>();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:80:  Tensor<double, 2> dtensor(20, 30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:82:  Tensor<float, 2> ftensor(20, 30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:95:  Tensor<float, 2> ftensor(20, 30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_casts.cpp:97:  Tensor<double, 2> dtensor(20, 30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:11:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:13:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:17:  Tensor<float, 2, DataLayout> input(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:29:  Tensor<std::complex<float>, 2, DataLayout> output = input.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:60:  Tensor<std::complex<float>, 1, ColMajor> input(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:70:  Tensor<std::complex<float>, 1, ColMajor> forward_output_both_parts = input.fft<BothParts, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:71:  Tensor<std::complex<float>, 1, ColMajor> reverse_output_both_parts = input.fft<BothParts, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:73:  Tensor<float, 1, ColMajor> forward_output_real_part = input.fft<RealPart, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:74:  Tensor<float, 1, ColMajor> reverse_output_real_part = input.fft<RealPart, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:76:  Tensor<float, 1, ColMajor> forward_output_imag_part = input.fft<ImagPart, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:77:  Tensor<float, 1, ColMajor> reverse_output_imag_part = input.fft<ImagPart, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:117:  Tensor<float, 1, ColMajor> input(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:127:  Tensor<std::complex<float>, 1, ColMajor> forward_output_both_parts = input.fft<BothParts, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:128:  Tensor<std::complex<float>, 1, ColMajor> reverse_output_both_parts = input.fft<BothParts, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:130:  Tensor<float, 1, ColMajor> forward_output_real_part = input.fft<RealPart, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:131:  Tensor<float, 1, ColMajor> reverse_output_real_part = input.fft<RealPart, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:133:  Tensor<float, 1, ColMajor> forward_output_imag_part = input.fft<ImagPart, FFT_FORWARD>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:134:  Tensor<float, 1, ColMajor> reverse_output_imag_part = input.fft<ImagPart, FFT_REVERSE>(fft);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:178:template <int DataLayout, typename RealScalar, bool isComplexInput, int FFTResultType, int FFTDirection, int TensorRank>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:181:  Eigen::DSizes<ptrdiff_t, TensorRank> dimensions;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:183:  for (int i = 0; i < TensorRank; ++i) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:187:  const DSizes<ptrdiff_t, TensorRank> arr = dimensions;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:191:  Tensor<InputScalar, TensorRank, DataLayout> input;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:195:  array<ptrdiff_t, TensorRank> fft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:196:  for (int i = 0; i < TensorRank; ++i) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:201:  Tensor<OutputScalar, TensorRank, DataLayout> output;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fft.cpp:204:  for (int i = 0; i < TensorRank; ++i) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:20:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:22:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:27:  CPUContext(const Eigen::Tensor<float, 3>& in1, Eigen::Tensor<float, 3>& in2, Eigen::Tensor<float, 3>& out) : in1_(in1), in2_(in2), out_(out), kernel_1d_(2), kernel_2d_(2,2), kernel_3d_(2,2,2) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:48:  const Eigen::Tensor<float, 3>& in1() const { return in1_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:49:  const Eigen::Tensor<float, 3>& in2() const { return in2_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:50:  Eigen::Tensor<float, 3>& out() { return out_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:51:  const Eigen::Tensor<float, 1>& kernel1d() const { return kernel_1d_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:52:  const Eigen::Tensor<float, 2>& kernel2d() const { return kernel_2d_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:53:  const Eigen::Tensor<float, 3>& kernel3d() const { return kernel_3d_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:56:  const Eigen::Tensor<float, 3>& in1_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:57:  const Eigen::Tensor<float, 3>& in2_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:58:  Eigen::Tensor<float, 3>& out_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:60:  Eigen::Tensor<float, 1> kernel_1d_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:61:  Eigen::Tensor<float, 2> kernel_2d_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:62:  Eigen::Tensor<float, 3> kernel_3d_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:70:  GPUContext(const Eigen::TensorMap<Eigen::Tensor<float, 3> >& in1, Eigen::TensorMap<Eigen::Tensor<float, 3> >& in2, Eigen::TensorMap<Eigen::Tensor<float, 3> >& out) : in1_(in1), in2_(in2), out_(out), gpu_device_(&stream_) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:91:  const Eigen::TensorMap<Eigen::Tensor<float, 3> >& in1() const { return in1_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:92:  const Eigen::TensorMap<Eigen::Tensor<float, 3> >& in2() const { return in2_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:93:  Eigen::TensorMap<Eigen::Tensor<float, 3> >& out() { return out_; }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:94:  Eigen::TensorMap<Eigen::Tensor<float, 1> > kernel1d() const { return Eigen::TensorMap<Eigen::Tensor<float, 1> >(kernel_1d_, 2); }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:95:  Eigen::TensorMap<Eigen::Tensor<float, 2> > kernel2d() const { return Eigen::TensorMap<Eigen::Tensor<float, 2> >(kernel_2d_, 2, 2); }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:96:  Eigen::TensorMap<Eigen::Tensor<float, 3> > kernel3d() const { return Eigen::TensorMap<Eigen::Tensor<float, 3> >(kernel_3d_, 2, 2, 2); }
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:99:  const Eigen::TensorMap<Eigen::Tensor<float, 3> >& in1_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:100:  const Eigen::TensorMap<Eigen::Tensor<float, 3> >& in2_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:101:  Eigen::TensorMap<Eigen::Tensor<float, 3> >& out_;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:181:  Eigen::Tensor<float, 3> in1(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:182:  Eigen::Tensor<float, 3> in2(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:183:  Eigen::Tensor<float, 3> out(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:273:  Eigen::Tensor<float, 3> in1(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:274:  Eigen::Tensor<float, 3> in2(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:275:  Eigen::Tensor<float, 3> out(40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:293:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_in1(d_in1, 40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:294:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_in2(d_in2, 40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_device.cu:295:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_out(d_out, 40,50,70);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:18:  const Eigen::internal::TensorIntDivisor<int32_t, false> div_by_one(1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:28:    const Eigen::internal::TensorIntDivisor<int32_t, false> div(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:39:    const Eigen::internal::TensorIntDivisor<int32_t, true> div(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:53:    const Eigen::internal::TensorIntDivisor<uint32_t> div(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:67:    const Eigen::internal::TensorIntDivisor<int64_t> div(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:81:    const Eigen::internal::TensorIntDivisor<uint64_t> div(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:100:        Eigen::internal::TensorIntDivisor<int32_t> divider =
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:101:          Eigen::internal::TensorIntDivisor<int32_t>(div);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:119:        Eigen::internal::TensorIntDivisor<int64_t> divider(div);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_intdiv.cpp:132:  Eigen::internal::TensorIntDivisor<int64_t> divider(div);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_notification.cpp:14:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:42:  Tensor<DataType, 3, DataLayout, IndexType> left(leftRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:43:  Tensor<DataType, 3, DataLayout, IndexType> right(rightRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:50:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_in1(gpu_in1_data, leftRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:51:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_in2(gpu_in2_data, rightRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:55:  Tensor<DataType, 3, DataLayout, IndexType> concatenation1(leftDim1+rightDim1, leftDim2, leftDim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:57:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_out1(gpu_out_data1, concatenation1.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:76:  Tensor<DataType, 3, DataLayout, IndexType> concatenation2(leftDim1, leftDim2 +rightDim2, leftDim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:78:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_out2(gpu_out_data2, concatenation2.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:95:  Tensor<DataType, 3, DataLayout, IndexType> concatenation3(leftDim1, leftDim2, leftDim3+rightDim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:97:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_out3(gpu_out_data3, concatenation3.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:131:  Tensor<DataType, 2, DataLayout, IndexType> left(leftRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:132:  Tensor<DataType, 2, DataLayout, IndexType> right(rightRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:133:  Tensor<DataType, 2, DataLayout, IndexType> result(resRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:144:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType>> gpu_in1(gpu_in1_data, leftRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:145:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType>> gpu_in2(gpu_in2_data, rightRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation_sycl.cpp:146:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType>> gpu_out(gpu_out_data, resRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:25:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:30:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:31:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:48:  Tensor<DataType, 3, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:49:  Tensor<DataType, 1, DataLayout,IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:50:  Tensor<DataType, 3, DataLayout,IndexType> result(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:51:  Tensor<DataType, 3, DataLayout,IndexType> result_host(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:68:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:69:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout, IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:70:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_result(d_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:109:  Tensor<DataType, 3, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:110:  Tensor<DataType, 2, DataLayout,IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:111:  Tensor<DataType, 3, DataLayout,IndexType> result(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:112:  Tensor<DataType, 3, DataLayout,IndexType> result_host(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:129:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:130:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:131:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_result(d_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:170:  Tensor<DataType, 3, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:171:  Tensor<DataType, 3, DataLayout,IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:172:  Tensor<DataType, 3, DataLayout,IndexType> result(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:173:  Tensor<DataType, 3, DataLayout,IndexType> result_host(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:190:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:191:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:192:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > gpu_result(d_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:225:  Tensor<DataType, 2, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:226:  Tensor<DataType, 1, DataLayout,IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:227:  Tensor<DataType, 2, DataLayout,IndexType> result(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:243:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:244:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout, IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:245:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_result(d_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:271:  Tensor<DataType, 2, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:272:  Tensor<DataType, 2, DataLayout, IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:273:  Tensor<DataType, 2, DataLayout, IndexType> result(result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:289:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout,IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:290:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout,IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:291:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout,IndexType> > gpu_result(d_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:319:Tensor<DataType, 1, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:320:Tensor<DataType, 1, DataLayout, IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:339:  Tensor<DataType, 1, DataLayout, IndexType> valid(1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:349:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:350:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:351:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_valid(d_valid, valid.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:364:  Tensor<DataType, 1, DataLayout, IndexType> same(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:367:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_same(d_same, same.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:380:  Tensor<DataType, 1, DataLayout, IndexType> full(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:383:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_full(d_full, full.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:408:  Tensor<DataType, 1, DataLayout, IndexType> input(input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:409:  Tensor<DataType, 1, DataLayout, IndexType> kernel(kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:410:  Tensor<DataType, 1, DataLayout, IndexType> result(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:430:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_input(d_input, input_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:431:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_kernel(d_kernel, kernel_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution_sycl.cpp:432:  Eigen::TensorMap<Eigen::Tensor<DataType, 1, DataLayout,IndexType> > gpu_result(d_result, result.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:18:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:20:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:23:  Tensor<std::complex<float>, 1, 0, int> in1(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:24:  Tensor<std::complex<float>, 1, 0, int> in2(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:43:  Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 1, 0, int>, Eigen::Aligned> gpu_in1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:45:  Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 1, 0, int>, Eigen::Aligned> gpu_in2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:47:  Eigen::TensorMap<Eigen::Tensor<float, 1, 0, int>, Eigen::Aligned> gpu_out2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:53:  Tensor<std::complex<float>, 1, 0, int> new1(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:54:  Tensor<float, 1, 0, int> new2(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:82:  Tensor<std::complex<float>, 2> in(num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:85:  Tensor<std::complex<float>, 0> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:94:  TensorMap<Tensor<std::complex<float>, 2> > in_gpu(gpu_in_ptr, num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:95:  TensorMap<Tensor<std::complex<float>, 0> > out_gpu(gpu_out_ptr);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:99:  Tensor<std::complex<float>, 0> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:118:  Tensor<std::complex<float>, 2> in(num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:121:  Tensor<std::complex<float>, 0> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:130:  TensorMap<Tensor<std::complex<float>, 2> > in_gpu(gpu_in_ptr, num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:131:  TensorMap<Tensor<std::complex<float>, 0> > out_gpu(gpu_out_ptr);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:135:  Tensor<std::complex<float>, 0> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:154:  Tensor<std::complex<float>, 2> in(num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:157:  Tensor<std::complex<float>, 0> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:166:  TensorMap<Tensor<std::complex<float>, 2> > in_gpu(gpu_in_ptr, num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:167:  TensorMap<Tensor<std::complex<float>, 0> > out_gpu(gpu_out_ptr);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cuda.cu:171:  Tensor<std::complex<float>, 0> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:20:  Tensor<float, 2, DataLayout> input(3, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:21:  Tensor<float, 1, DataLayout> kernel(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:26:  Tensor<float, 2, DataLayout> result(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:28:  Eigen::array<Tensor<float, 2>::Index, 1> dims3{{0}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:30:  typedef TensorEvaluator<decltype(input.convolve(kernel, dims3)), DefaultDevice> Evaluator;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:48:  Tensor<float, 2, DataLayout> input(3, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:49:  Tensor<float, 2, DataLayout> kernel(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:53:  Tensor<float, 2, DataLayout> result(2,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:71:  Tensor<float, 1, DataLayout> input(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:72:  Tensor<float, 1, DataLayout> kernel(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:87:  Tensor<float, 1, DataLayout> valid(1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:95:  Tensor<float, 1, DataLayout> same(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:105:  Tensor<float, 1, DataLayout> full(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:117:  Tensor<float, 1, DataLayout> input(13);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:118:  Tensor<float, 1, DataLayout> kernel(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_convolution.cpp:129:  Tensor<float, 1, DataLayout> result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:18:  Tensor<float, 3, ColMajor> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:21:  Tensor<float, 3, RowMajor> tensor2 = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:38:  Tensor<float, 3, ColMajor> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap.cpp:41:  Tensor<float, 3, RowMajor> tensor2(7,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:23:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:25:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:35:  array<IndexType, 5> patchTensorRange;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:37:   patchTensorRange = {{1, 1, 1, 1, sizeDim1*sizeDim2*sizeDim3*sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:39:     patchTensorRange = {{sizeDim1*sizeDim2*sizeDim3*sizeDim4,1, 1, 1, 1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:42:  Tensor<DataType, 4, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:43:  Tensor<DataType, 5, DataLayout,IndexType> no_patch(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:54:  size_t patchTensorBuffSize =no_patch.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:56:  DataType* gpu_data_no_patch  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:58:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:59:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_no_patch(gpu_data_no_patch, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:63:  sycl_device.memcpyDeviceToHost(no_patch.data(), gpu_data_no_patch, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:89:   patchTensorRange = {{sizeDim1,sizeDim2,sizeDim3,sizeDim4,1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:91:     patchTensorRange = {{1,sizeDim1,sizeDim2,sizeDim3,sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:93:  Tensor<DataType, 5, DataLayout,IndexType> single_patch(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:94:  patchTensorBuffSize =single_patch.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:95:  DataType* gpu_data_single_patch  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:96:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_single_patch(gpu_data_single_patch, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:99:  sycl_device.memcpyDeviceToHost(single_patch.data(), gpu_data_single_patch, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:124:   patchTensorRange = {{1,2,2,1,2*2*4*7}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:126:     patchTensorRange = {{2*2*4*7, 1, 2,2,1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:128:  Tensor<DataType, 5, DataLayout,IndexType> twod_patch(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:129:  patchTensorBuffSize =twod_patch.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:130:  DataType* gpu_data_twod_patch  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:131:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_twod_patch(gpu_data_twod_patch, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:134:  sycl_device.memcpyDeviceToHost(twod_patch.data(), gpu_data_twod_patch, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:180:   patchTensorRange = {{1,2,3,5,2*2*3*3}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:182:     patchTensorRange = {{2*2*3*3, 1, 2,3,5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:184:  Tensor<DataType, 5, DataLayout,IndexType> threed_patch(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:185:  patchTensorBuffSize =threed_patch.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:186:  DataType* gpu_data_threed_patch  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:187:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_threed_patch(gpu_data_threed_patch, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch_sycl.cpp:190:  sycl_device.memcpyDeviceToHost(threed_patch.data(), gpu_data_threed_patch, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:17:typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:22:  Tensor<float, 2, DataLayout> mat1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:23:  Tensor<float, 2, DataLayout> mat2(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:24:  Tensor<float, 2, DataLayout> mat3(3, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:30:  Tensor<float, 2, DataLayout> mat4(3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:33:  typedef TensorEvaluator<decltype(mat1.contract(mat2, dims3)), DefaultDevice> Evaluator;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:50:  Tensor<float, 2, DataLayout> mat5(2,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:53:  typedef TensorEvaluator<decltype(mat1.contract(mat2, dims4)), DefaultDevice> Evaluator2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:65:  Tensor<float, 2, DataLayout> mat6(2,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:68:  typedef TensorEvaluator<decltype(mat1.contract(mat3, dims6)), DefaultDevice> Evaluator3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:84:  Tensor<float, 1, DataLayout> vec1({6});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:85:  Tensor<float, 1, DataLayout> vec2({6});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:91:  Tensor<float, 0, DataLayout> scalar = vec1.contract(vec2, dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:103:  Tensor<float, 3, DataLayout> mat1(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:104:  Tensor<float, 4, DataLayout> mat2(2, 2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:109:  Tensor<float, 3, DataLayout> mat3(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:112:  typedef TensorEvaluator<decltype(mat1.contract(mat2, dims)), DefaultDevice> Evaluator;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:137:  Tensor<float, 2, DataLayout> mat4(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:138:  Tensor<float, 3, DataLayout> mat5(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:143:  Tensor<float, 1, DataLayout> mat6(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:146:  typedef TensorEvaluator<decltype(mat4.contract(mat5, dims2)), DefaultDevice> Evaluator2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:160:  Tensor<float, 4, DataLayout> t1(2, 5, 7, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:161:  Tensor<float, 5, DataLayout> t2(2, 7, 11, 13, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:166:  Tensor<float, 5, DataLayout> result = t1.contract(t2, dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:195:  Tensor<float, 2, DataLayout> t1(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:196:  Tensor<float, 3, DataLayout> t2(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:201:  Tensor<float, 1, DataLayout> result = t1.contract(t2, dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:221:  Tensor<float, 2, DataLayout> t1(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:222:  Tensor<float, 2, DataLayout> t2(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:223:  Tensor<float, 2, DataLayout> t3(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:224:  Tensor<float, 2, DataLayout> t4(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:234:  Tensor<float, 2, DataLayout> result = contract2.contract(diff, dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:254:  Tensor<float, 2, DataLayout> mat1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:255:  Tensor<float, 2, DataLayout> mat2(3, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:259:  Tensor<float, 2, DataLayout> mat3(2,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:273:  Tensor<float, 3, DataLayout> mat1(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:274:  Tensor<float, 3, DataLayout> mat2(2, 2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:279:  Tensor<float, 2, DataLayout> mat3(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:320:  Tensor<float, 3, DataLayout> mat1(4, 3, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:321:  Tensor<float, 5, DataLayout> mat2(3, 2, 1, 5, 4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:325:  Tensor<float, 4, DataLayout> mat3(5, 2, 1, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:326:  Tensor<float, 4, DataLayout> mat4(2, 1, 5, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:355:  Tensor<float, 4, DataLayout> t_left(30, 50, 8, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:356:  Tensor<float, 5, DataLayout> t_right(8, 31, 7, 20, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:357:  Tensor<float, 5, DataLayout> t_result(30, 50, 7, 20, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:387:  Tensor<float, 2, DataLayout> t_left(30, 50);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:388:  Tensor<float, 1, DataLayout> t_right(50);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:389:  Tensor<float, 1, DataLayout> t_result(30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:415:  Tensor<float, 3, DataLayout> t_left(7, 13, 17);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:416:  Tensor<float, 2, DataLayout> t_right(1, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:421:  typedef typename Tensor<float, 1, DataLayout>::DimensionPair DimensionPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:423:  Tensor<float, 3, DataLayout> t_result = t_left.contract(t_right, dim_pair01);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:439:  Tensor<float, 4, DataLayout> t_left(30, 5, 3, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:440:  Tensor<float, 5, DataLayout> t_right(3, 31, 7, 20, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:453:  Tensor<float, 5, DataLayout> t_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:469:  Tensor<float, 2, DataLayout> mat1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:470:  Tensor<float, 2, DataLayout> mat2(4, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:474:  Tensor<float, 4, DataLayout> result = mat1.contract(mat2, Eigen::array<DimPair, 0>{{}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:495:  Tensor<float, 2, DataLayout> in1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:496:  Tensor<float, 2, DataLayout> in2(3, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:500:  TensorMap<Tensor<const float, 2, DataLayout> > mat1(in1.data(), 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:501:  TensorMap<Tensor<const float, 2, DataLayout> > mat2(in2.data(), 3, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contraction.cpp:502:  Tensor<float, 2, DataLayout> mat3(2,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:24:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:28:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:29:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:42:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:57:  Tensor<DataType, 4, DataLayout, IndexType> padded(padedtensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:62:  TensorMap<Tensor<DataType, 4,DataLayout,IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:63:  TensorMap<Tensor<DataType, 4,DataLayout,IndexType>> gpu2(gpu_data2, padedtensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:98:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:112:  Tensor<DataType, 2, DataLayout, IndexType>  result(reshape_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:116:  TensorMap<Tensor<DataType, 4,DataLayout,IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding_sycl.cpp:117:  TensorMap<Tensor<DataType, 2,DataLayout,IndexType>> gpu2(gpu_data2, reshape_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:20:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:22:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:23:typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:29:  Tensor<float, 3, DataLayout> t_input(m_size, k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:30:  Tensor<float, 3, DataLayout> t_result(m_size, k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:31:  Tensor<float, 3, DataLayout> t_result_gpu(m_size, k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:49:  Eigen::TensorMap<Eigen::Tensor<float, 3, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan_cuda.cu:51:  Eigen::TensorMap<Eigen::Tensor<float, 3, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:19:  Tensor<int, 0, DataLayout> tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:33:  Tensor<int, 1, DataLayout> tensor(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:44:  Eigen::Tensor<double,1,DataLayout> empty_tensor(0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:55:  Tensor<int, 2, DataLayout> tensor(5, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:73:  Tensor<int, 1, DataLayout> tensor1(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:74:  Tensor<int, 1, DataLayout> tensor2(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:91:  Tensor<std::string, 2, DataLayout> tensor(5, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:107:  Tensor<int, 1, DataLayout> tensor(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_io.cpp:112:  TensorMap<Tensor<const int, 1, DataLayout> > tensor_map(tensor.data(), 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation.cpp:19:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation.cpp:28:  Tensor<float, 4, DataLayout> no_stride;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation.cpp:50:  Tensor<float, 4, DataLayout> inflated;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:17:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:20:  Tensor<float, 2> result = ftensor.round();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:31:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:34:  Tensor<float, 2> result = ftensor.floor();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:45:  Tensor<float, 2> ftensor(20,30);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_roundings.cpp:48:  Tensor<float, 2> result = ftensor.ceil();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:20:  TensorFixedSize<float, Sizes<> > scalar1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:21:  TensorFixedSize<float, Sizes<>, RowMajor> scalar2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:30:  TensorFixedSize<float, Sizes<> > copy = scalar1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:37:  TensorFixedSize<float, Sizes<> > scalar3 = scalar1.sqrt();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:38:  TensorFixedSize<float, Sizes<>, RowMajor> scalar4 = scalar2.sqrt();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:49:  TensorFixedSize<float, Sizes<6> > vec1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:50:  TensorFixedSize<float, Sizes<6>, RowMajor> vec2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:64:  TensorFixedSize<float, Sizes<6> > copy = vec1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:75:  TensorFixedSize<float, Sizes<6> > vec3 = vec1.sqrt();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:76:  TensorFixedSize<float, Sizes<6>, RowMajor> vec4 = vec2.sqrt();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:108:  TensorFixedSize<float, Sizes<6> > vec1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:109:  TensorFixedSize<float, Sizes<6>, RowMajor> vec2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:119:  TensorMap<TensorFixedSize<float, Sizes<6> > > vec3(data3, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:133:  TensorMap<TensorFixedSize<float, Sizes<2, 3> > > mat1(data1,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:135:  TensorMap<TensorFixedSize<float, Sizes<2, 3>, RowMajor> > mat2(data2,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:156:  TensorFixedSize<float, Sizes<2, 3> > mat3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:157:  TensorFixedSize<float, Sizes<2, 3>, RowMajor> mat4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:182:  TensorFixedSize<float, Sizes<2, 3, 7> > mat1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:183:  TensorFixedSize<float, Sizes<2, 3, 7>, RowMajor> mat2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:202:  TensorFixedSize<float, Sizes<2, 3, 7> > mat3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:204:  TensorFixedSize<float, Sizes<2, 3, 7>, RowMajor> mat4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:228:  TensorFixedSize<float, Sizes<2, 3, 7> > mat1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_fixed_size.cpp:239:  TensorFixedSize<float, Sizes<2, 3, 7> > mat3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:20:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:22:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:29:  Tensor<float, 1> floats(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:36:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:38:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:40:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_conv(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:48:  Tensor<float, 1> initial(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:49:  Tensor<float, 1> final(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:66:  Tensor<float, 1> floats(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:69:  Eigen::Tensor<Eigen::half, 1> halfs = floats.cast<Eigen::half>();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cast_float16_cuda.cu:70:  Eigen::Tensor<float, 1> conv = halfs.cast<float>();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random.cpp:16:  Tensor<float, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random.cpp:28:  Tensor<float, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random.cpp:65:  Tensor<int, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:19:  Tensor<int, 1> input(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:22:  TensorRef<Tensor<int, 1>> ref3(input);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:23:  TensorRef<Tensor<int, 1>> ref4 = input;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:50:  Tensor<int, 1> input1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:52:  Tensor<int, 1> input2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:55:  TensorRef<Tensor<int, 1>> ref3(input1 + input2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:56:  TensorRef<Tensor<int, 1>> ref4 = input1 + input2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:72:  Tensor<float, 3> input(3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:75:  TensorRef<Tensor<float, 3>> ref(input);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:93:  Tensor<float, 5> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:98:  TensorRef<Tensor<float, 5>> slice = tensor.slice(indices, sizes);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:121:  Tensor<float, 3> input(3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:124:  TensorRef<Tensor<float, 3>> ref(input);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:125:  TensorRef<Tensor<float, 3>> ref_of_ref(ref);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:126:  TensorRef<Tensor<float, 3>> ref_of_ref2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:152:  Tensor<float, 3> input(3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:154:  TensorRef<Tensor<float, 3>> input_ref(input);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:156:  Tensor<float, 3> result(3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:158:  TensorRef<Tensor<float, 3>> result_ref(result);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:160:  Tensor<float, 3> bias(3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:186:  Tensor<float, 5> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:188:  Tensor<float, 5> original = tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:190:  TensorRef<Tensor<float, 4>> slice = tensor.chip(7, 4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:201:  Tensor<float, 4> t(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:203:  TensorMap<Tensor<const float, 4> > m(t.data(), 2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:210:  TensorRef<Tensor<const float, 4> > ref(m.pad(paddings));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ref.cpp:216:  Tensor<float, 4> padded = ref.shuffle(shuffle_dims).pad(trivial);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_mixed_indices.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_mixed_indices.cpp:17:  Tensor<float, 1, ColMajor> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_mixed_indices.cpp:18:  Tensor<float, 1, ColMajor, int> vec2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_mixed_indices.cpp:28:  TensorMap<Tensor<float, 1, ColMajor>> vec3(data3, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_mixed_indices.cpp:31:  TensorMap<Tensor<float, 1, ColMajor, int>> vec4(data4, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:18:  DSizes<DenseIndex, 2> dimensions(const Tensor<float, 2>& input) const {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:26:  void eval(const Tensor<float, 2>& input, Output& output, const Device& device) const
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:41:  Tensor<float, 2> tensor(3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:44:  Tensor<float, 2> result = tensor.customOp(InsertZeros());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:62:  DSizes<DenseIndex, 3> dimensions(const Tensor<float, 3>& input1, const Tensor<float, 3>& input2) const {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:71:  void eval(const Tensor<float, 3>& input1, const Tensor<float, 3>& input2,
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:74:    typedef Tensor<float, 3>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:86:  Tensor<float, 3> tensor1(2,3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:88:  Tensor<float, 3> tensor2(3,7,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:91:  Tensor<float, 3> result = tensor1.customOp(tensor2, BatchMatMul());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:93:    typedef Tensor<float, 3>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:96:    Tensor<float, 2> reference = tensor1.chip<2>(i).contract(tensor2.chip<2>(i), dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op.cpp:97:    TensorRef<Tensor<float, 2> > val = result.chip<2>(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:18:  Tensor<float, 4> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:20:  Tensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:27:  Tensor<float, 5> single_pixel_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:36:  Tensor<float, 5, RowMajor> single_pixel_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:66:  Tensor<float, 5> entire_image_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:75:  Tensor<float, 5, RowMajor> entire_image_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:120:  Tensor<float, 5> twod_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:129:  Tensor<float, 5, RowMajor> twod_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:138:  // Based on the calculation described in TensorTraits.h, padding happens to be 0.
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:191:  Tensor<float, 4> tensor(input_depth, input_rows, input_cols, input_batches);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:197:  Tensor<float, 5> result = tensor.extract_image_patches(ksize, ksize, stride, stride, 1, 1, PADDING_VALID);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:206:  Tensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:212:  Tensor<float, 5, RowMajor> result_row_major = tensor_row_major.extract_image_patches(ksize, ksize, stride, stride, 1, 1, PADDING_VALID);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:268:  Tensor<float, 4> tensor(input_depth, input_rows, input_cols, input_batches);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:270:  Tensor<float, 5> result = tensor.extract_image_patches(ksize, ksize, stride, stride, 1, 1, PADDING_VALID);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:279:  Tensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:285:  Tensor<float, 5, RowMajor> result_row_major = tensor_row_major.extract_image_patches(ksize, ksize, stride, stride, 1, 1, PADDING_VALID);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:341:  Tensor<float, 4> tensor(input_depth, input_rows, input_cols, input_batches);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:346:  Tensor<float, 5> result = tensor.extract_image_patches(ksize, ksize, stride, stride, PADDING_SAME);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:355:  Tensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:361:  Tensor<float, 5, RowMajor> result_row_major = tensor_row_major.extract_image_patches(ksize, ksize, stride, stride, PADDING_SAME);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:368:  // Based on the calculation described in TensorTraits.h, padding happens to be
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:410:  Tensor<float, 3> tensor(2,3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:412:  Tensor<float, 3, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:418:  Tensor<float, 4> single_pixel_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:426:  Tensor<float, 4, RowMajor> single_pixel_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:453:  Tensor<float, 4> entire_image_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:461:  Tensor<float, 4, RowMajor> entire_image_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:501:  Tensor<float, 4> twod_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:509:  Tensor<float, 4, RowMajor> twod_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:516:  // Based on the calculation described in TensorTraits.h, padding happens to be 0.
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:561:  Tensor<float, 4> l_in(3, 128, 128, 16);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:563:  Tensor<float, 5> l_out = l_in.extract_image_patches(11, 11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch.cpp:571:  Tensor<float, 5, RowMajor> l_out_row_major = l_in.swap_layout().extract_image_patches(11, 11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_non_blocking_thread_pool.cpp:14:#include "Eigen/CXX11/Tensor"
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:19:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:28:  Tensor<float, 4, DataLayout> padded;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:54:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_padding.cpp:67:  Tensor<float, 2, DataLayout> result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:19:  Tensor<float, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:20:  Tensor<float, 1, RowMajor> vec2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:30:  TensorMap<Tensor<float, 1>> vec3(data3, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:33:  TensorMap<Tensor<float, 1, RowMajor>> vec4(data4, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:36:  TensorMap<Tensor<float, 1, RowMajor>> vec5(data5, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:72:  TensorMap<Tensor<float, 2>> mat1(data1, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:74:  TensorMap<Tensor<float, 2, RowMajor>> mat2(data2, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:90:  Tensor<float, 2> mat3(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:91:  Tensor<float, 2, RowMajor> mat4(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:112:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:113:  Tensor<float, 3, RowMajor> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:126:  Tensor<float, 3> mat3(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:128:  Tensor<float, 3, RowMajor> mat4(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:130:  Tensor<float, 3> mat5(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:132:  Tensor<float, 3, RowMajor> mat6(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:134:  Tensor<float, 3> mat7(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:136:  Tensor<float, 3, RowMajor> mat8(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:138:  Tensor<float, 3, RowMajor> mat9(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:140:  Tensor<float, 3, RowMajor> mat10(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:142:  Tensor<float, 3, RowMajor> mat11(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:166:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:167:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:168:  Tensor<float, 3> mat3(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:196:  Tensor<int, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:200:  Tensor<bool, 1> bool1 = vec < vec.constant(1) || vec > vec.constant(4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:209:  Tensor<bool, 1> bool2 = vec.cast<bool>() && vec < vec.constant(4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:218:  // Test Tensor<bool> against results of cast or comparison; verifies that
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:221:  Tensor<bool, 1> bool3 = vec.cast<bool>() && bool2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:227:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:228:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:229:  Tensor<float, 3> mat3(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:257:  Tensor<bool, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:258:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:259:  Tensor<double, 3> mat3(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:284:  Tensor<float, 3> selector(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:285:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:286:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:287:  Tensor<float, 3> result(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:307:    Tensor<Scalar, 1> vec_nan(size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:308:    Tensor<Scalar, 1> vec_zero(size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_expr.cpp:309:    Tensor<Scalar, 1> vec_res(size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:20:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:28:  Tensor<float, 4, DataLayout> no_shuffle;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:50:  Tensor<float, 4, DataLayout> shuffle;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:73:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:81:  Tensor<float, 4, DataLayout> expected;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:84:  Tensor<float, 4, DataLayout> result(5,7,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:136:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:143:  Tensor<float, 4, DataLayout> shuffle(5,7,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:166:  Tensor<float, 4, DataLayout> shuffle2(5,7,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:183:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling.cpp:198:  Tensor<float, 4, DataLayout> shuffle;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:18:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:20:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:37:  Eigen::TensorMap<Eigen::Tensor<std::complex<T>, 1, 0, int>, Eigen::Aligned> gpu_in1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:39:  Eigen::TensorMap<Eigen::Tensor<std::complex<T>, 1, 0, int>, Eigen::Aligned> gpu_in2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:41:  Eigen::TensorMap<Eigen::Tensor<std::complex<T>, 1, 0, int>, Eigen::Aligned> gpu_out(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_complex_cwise_ops_cuda.cu:57:  Tensor<std::complex<T>, 1, 0, int> actual(kNumItems);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:19:  Tensor<float, 5, DataLayout> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:22:  Tensor<float, 4, DataLayout> chip1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:40:  Tensor<float, 4, DataLayout> chip2 = tensor.template chip<1>(1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:55:  Tensor<float, 4, DataLayout> chip3 = tensor.template chip<2>(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:70:  Tensor<float, 4, DataLayout> chip4(tensor.template chip<3>(5));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:85:  Tensor<float, 4, DataLayout> chip5(tensor.template chip<4>(7));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:104:  Tensor<float, 5, DataLayout> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:107:  Tensor<float, 4, DataLayout> chip1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:123:  Tensor<float, 4, DataLayout> chip2 = tensor.chip(1, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:138:  Tensor<float, 4, DataLayout> chip3 = tensor.chip(2, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:153:  Tensor<float, 4, DataLayout> chip4(tensor.chip(5, 3));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:168:  Tensor<float, 4, DataLayout> chip5(tensor.chip(7, 4));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:186:  Tensor<float, 5, DataLayout> input1(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:188:  Tensor<float, 4, DataLayout> input2(3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:191:  Tensor<float, 4, DataLayout> result = input1.template chip<0>(0) + input2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:203:  Tensor<float, 3, DataLayout> input3(3,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:205:  Tensor<float, 3, DataLayout> result2 = input1.template chip<0>(0).template chip<1>(2) + input3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:219:  Tensor<float, 5, DataLayout> input1(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:222:  Tensor<float, 4, DataLayout> input2(3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:224:  Tensor<float, 5, DataLayout> tensor = input1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:242:  Tensor<float, 4, DataLayout> input3(2,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:262:  Tensor<float, 4, DataLayout> input4(2,3,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:282:  Tensor<float, 4, DataLayout> input5(2,3,5,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:302:  Tensor<float, 4, DataLayout> input6(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:322:  Tensor<float, 5, DataLayout> input7(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:345:  Tensor<float, 5, ColMajor> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:348:  typedef TensorEvaluator<decltype(tensor.chip<4>(3)), DefaultDevice> Evaluator4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:361:  typedef TensorEvaluator<decltype(tensor.chip<0>(0)), DefaultDevice> Evaluator0;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:365:  typedef TensorEvaluator<decltype(tensor.chip<1>(0)), DefaultDevice> Evaluator1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:369:  typedef TensorEvaluator<decltype(tensor.chip<2>(0)), DefaultDevice> Evaluator2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:373:  typedef TensorEvaluator<decltype(tensor.chip<3>(0)), DefaultDevice> Evaluator3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:380:  Tensor<float, 5, RowMajor> tensor(11,7,5,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:383:  typedef TensorEvaluator<decltype(tensor.chip<0>(3)), DefaultDevice> Evaluator0;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:396:  typedef TensorEvaluator<decltype(tensor.chip<1>(0)), DefaultDevice> Evaluator1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:400:  typedef TensorEvaluator<decltype(tensor.chip<2>(0)), DefaultDevice> Evaluator2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:404:  typedef TensorEvaluator<decltype(tensor.chip<3>(0)), DefaultDevice> Evaluator3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping.cpp:408:  typedef TensorEvaluator<decltype(tensor.chip<4>(0)), DefaultDevice> Evaluator4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:19:  Tensor<float, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:22:  Tensor<float, 1> vec2 = vec1.tanh();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:31:  Tensor<float, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_math.cpp:34:  Tensor<float, 1> vec2 = vec1.sigmoid();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:25:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:29:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:30:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:41:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:42:  Tensor<DataType, 4, DataLayout,IndexType> no_stride(tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:43:  Tensor<DataType, 4, DataLayout,IndexType> stride(stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:53:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_tensor(d_tensor, tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:54:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_no_stride(d_no_stride, tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:55:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_stride(d_stride, stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:89://Tensor<float, 4, DataLayout> stride;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:123:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:124:  Tensor<DataType, 4, DataLayout,IndexType> no_stride(stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:125:  Tensor<DataType, 4, DataLayout,IndexType> stride(stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:136:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_tensor(d_tensor, tensor_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:137:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_no_stride(d_no_stride, stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:138:  Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, IndexType> > gpu_stride(d_stride, stride_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:140:  //Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:148://  Tensor<float, 4, DataLayout> result(3, 12, 10, 21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding_sycl.cpp:169://  Tensor<float, 4, DataLayout> result2(3, 12, 10, 21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:19:  Tensor<int, 0> scalar1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:20:  Tensor<int, 0, RowMajor> scalar2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:22:  TensorMap<Tensor<const int, 0> > scalar3(scalar1.data());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:23:  TensorMap<Tensor<const int, 0, RowMajor> > scalar4(scalar2.data());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:37:  Tensor<int, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:38:  Tensor<int, 1, RowMajor> vec2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:40:  TensorMap<Tensor<const int, 1> > vec3(vec1.data(), 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:41:  TensorMap<Tensor<const int, 1, RowMajor> > vec4(vec2.data(), 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:71:  Tensor<int, 2> mat1(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:72:  Tensor<int, 2, RowMajor> mat2(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:88:  TensorMap<Tensor<const int, 2> > mat3(mat1.data(), 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:89:  TensorMap<Tensor<const int, 2, RowMajor> > mat4(mat2.data(), 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:118:  Tensor<int, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:119:  Tensor<int, 3, RowMajor> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:132:  TensorMap<Tensor<const int, 3> > mat3(mat1.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:133:  TensorMap<Tensor<const int, 3, RowMajor> > mat4(mat2.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:162:  Tensor<int, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:163:  Tensor<int, 3, RowMajor> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:176:  TensorMap<Tensor<int, 3> > mat3(mat1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:177:  TensorMap<Tensor<int, 3, RowMajor> > mat4(mat2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:202:  TensorFixedSize<int, Sizes<2,3,7> > mat5;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:218:  TensorMap<TensorFixedSize<int, Sizes<2,3,7> > > mat6(mat5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:238:static int f(const TensorMap<Tensor<int, 3> >& tensor) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:242:  Tensor<int, 0> result = tensor.sum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:248:  Tensor<int, 3> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_map.cpp:260:  TensorMap<Tensor<int, 3> > map(tensor);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:19:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:28:  Tensor<float, 5, DataLayout> no_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:53:  Tensor<float, 5, DataLayout> single_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:78:  Tensor<float, 5, DataLayout> twod_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_patch.cpp:123:  Tensor<float, 5, DataLayout> threed_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:25:  Tensor<float, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:26:  Tensor<float, 1> result = vec.generate(Generator1D());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:45:  Tensor<float, 2> matrix(5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:46:  Tensor<float, 2> result = matrix.generate(Generator2D());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:69:  Tensor<float, 2> matrix(rows, cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator.cpp:70:  Tensor<float, 2> result = matrix.generate(gaussian_gen);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_lvalue.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_lvalue.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_lvalue.cpp:20:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_lvalue.cpp:21:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_lvalue.cpp:22:  Tensor<float, 3> mat3(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:19:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:20:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:21:  Tensor<bool, 3> lt(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:22:  Tensor<bool, 3> le(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:23:  Tensor<bool, 3> gt(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:24:  Tensor<bool, 3> ge(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:49:  Tensor<float, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:50:  Tensor<float, 3> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:64:  Tensor<bool, 3> eq(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_comparisons.cpp:65:  Tensor<bool, 3> ne(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:15:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:17:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:24:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:46:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:64:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_index.cpp:79:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:25:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:26:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:46:  Tensor<DataType, 4, DataLayout, IndexType>  input(in_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:47:  Tensor<DataType, 4, DataLayout, IndexType> out(out_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:59:  TensorMap<TensorFixedSize<DataType, Sizes<2, 3, 5, 7>, DataLayout, IndexType>> gpu_in(gpu_in_data, in_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:60:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_out(gpu_out_data, out_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:97:  Tensor<DataType, 4, DataLayout, IndexType>  input(in_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:98:  Tensor<DataType, 4, DataLayout, IndexType> out(out_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:110:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>>  gpu_in(gpu_in_data, in_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcast_sycl.cpp:111:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_out(gpu_out_data, out_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:33:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:34:  Tensor<DataType, 4, DataLayout, IndexType> reversed_tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:46:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:47:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu(gpu_out_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:112:  Tensor<DataType, 4, DataLayout, IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:113:  Tensor<DataType, 4, DataLayout, IndexType> expected(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:114:  Tensor<DataType, 4, DataLayout, IndexType> result(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:127:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:128:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu_expected(gpu_out_data_expected, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse_sycl.cpp:129:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType> >  out_gpu_result(gpu_out_data_result, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:19:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:27:  Tensor<float, 4, DataLayout> no_stride;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:49:  Tensor<float, 4, DataLayout> stride;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:72:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:80:  Tensor<float, 4, DataLayout> result(3, 12, 10, 21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_striding.cpp:98:  Tensor<float, 4, DataLayout> result2(3, 12, 10, 21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:21:  Tensor<Type, 1, DataLayout> tensor(size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:23:  Tensor<Type, 1, DataLayout> result = tensor.cumsum(0, Exclusive);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:55:  Tensor<Type, 4, DataLayout> tensor(size, size, size, size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:58:  Tensor<Type, 4, DataLayout> result(size, size, size, size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:89:  TensorMap<Tensor<int, 1, DataLayout> > tensor_map(inputs, 20);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_scan.cpp:92:  Tensor<int, 1, DataLayout> result = tensor_map.cumsum(0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:19:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:27:  Tensor<float, 4, DataLayout> no_broadcast;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:49:  Tensor<float, 4, DataLayout> broadcast;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:72:  Tensor<float, 3, DataLayout> tensor(8,3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:79:  Tensor<float, 3, DataLayout> broadcast;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:115:  Tensor<float, 3, DataLayout> tensor(8,3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:127:  Tensor<float, 3, DataLayout> broadcast;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:165:  Tensor<float, 1, DataLayout> t1(10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:167:  TensorFixedSize<float, Sizes<1>, DataLayout> t2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:170:  Tensor<float, 1, DataLayout> t3 = t1 + t2.broadcast(Eigen::array<int, 1>{{10}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:175:  TensorMap<TensorFixedSize<float, Sizes<1>, DataLayout> > t4(t2.data(), {{1}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_broadcasting.cpp:176:  Tensor<float, 1, DataLayout> t5 = t1 + t4.broadcast(Eigen::array<int, 1>{{10}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:16:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:25:  TensorMap<Tensor<float, 2> > mat1(m1.data(), 3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:26:  TensorMap<Tensor<float, 2> > mat2(m2.data(), 3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:28:  Tensor<float, 2> mat3(3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:31:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:58:  Tensor<float, 2>::Dimensions dims2d;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:64:  const TensorMap<Tensor<const float, 2> > input_tensor(input.data(), 3, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval.cpp:65:  Tensor<float, 2> output_tensor= (input_tensor - input_tensor.maximum(depth_dim).eval().reshape(dims2d).broadcast(bcast));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_dimension.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_dimension.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:35:  Tensor<DataType, 4, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:36:  Tensor<DataType, 4, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:41:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:42:  TensorMap<Tensor<DataType, 4, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:54:  array<IndexType, 5> patchColMajorTensorRange={{sizeDim1, 1, 1, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:55:  Tensor<DataType, 5, DataLayout,IndexType> single_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:56:  size_t patchTensorBuffSize =single_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:57:  DataType* gpu_data_single_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:58:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_single_patch_col_major(gpu_data_single_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:60:  sycl_device.memcpyDeviceToHost(single_patch_col_major.data(), gpu_data_single_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:69:  array<IndexType, 5> patchRowMajorTensorRange={{sizeDim4, sizeDim2*sizeDim3, 1, 1, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:70:  Tensor<DataType, 5, RowMajor,IndexType> single_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:71:  patchTensorBuffSize =single_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:72:  DataType* gpu_data_single_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:73:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_single_patch_row_major(gpu_data_single_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:75:  sycl_device.memcpyDeviceToHost(single_patch_row_major.data(), gpu_data_single_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:106:  patchColMajorTensorRange={{sizeDim1, sizeDim2, sizeDim3, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:107:  Tensor<DataType, 5, DataLayout,IndexType> entire_image_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:108:  patchTensorBuffSize =entire_image_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:109:  DataType* gpu_data_entire_image_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:110:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_entire_image_patch_col_major(gpu_data_entire_image_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:112:  sycl_device.memcpyDeviceToHost(entire_image_patch_col_major.data(), gpu_data_entire_image_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:121:  patchRowMajorTensorRange={{sizeDim4, sizeDim2*sizeDim3, sizeDim3, sizeDim2, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:122:  Tensor<DataType, 5, RowMajor,IndexType> entire_image_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:123:  patchTensorBuffSize =entire_image_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:124:  DataType* gpu_data_entire_image_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:125:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_entire_image_patch_row_major(gpu_data_entire_image_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:127:  sycl_device.memcpyDeviceToHost(entire_image_patch_row_major.data(), gpu_data_entire_image_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:172:  patchColMajorTensorRange={{sizeDim1, 2, 2, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:173:  Tensor<DataType, 5, DataLayout,IndexType> twod_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:174:  patchTensorBuffSize =twod_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:175:  DataType* gpu_data_twod_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:176:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_twod_patch_col_major(gpu_data_twod_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:178:  sycl_device.memcpyDeviceToHost(twod_patch_col_major.data(), gpu_data_twod_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:187:  patchRowMajorTensorRange={{sizeDim4, sizeDim2*sizeDim3, 2, 2, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:188:  Tensor<DataType, 5, RowMajor,IndexType> twod_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:189:  patchTensorBuffSize =twod_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:190:  DataType* gpu_data_twod_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:191:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_twod_patch_row_major(gpu_data_twod_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:193:  sycl_device.memcpyDeviceToHost(twod_patch_row_major.data(), gpu_data_twod_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:202:  // Based on the calculation described in TensorTraits.h, padding happens to be 0.
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:269:  Tensor<DataType, 4, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:270:  Tensor<DataType, 4, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:274:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:275:  TensorMap<Tensor<DataType, 4, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:291:  array<IndexType, 5> patchColMajorTensorRange={{input_depth, ksize, ksize, 1, input_batches}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:292:  Tensor<DataType, 5, DataLayout,IndexType> result_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:293:  size_t patchTensorBuffSize =result_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:294:  DataType* gpu_data_result_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:295:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_result_col_major(gpu_data_result_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:297:  sycl_device.memcpyDeviceToHost(result_col_major.data(), gpu_data_result_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:306:  array<IndexType, 5> patchRowMajorTensorRange={{input_batches, 1, ksize, ksize, input_depth }};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:307:  Tensor<DataType, 5, RowMajor,IndexType> result_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:308:  patchTensorBuffSize =result_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:309:  DataType* gpu_data_result_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:310:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_result_row_major(gpu_data_result_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:312:  sycl_device.memcpyDeviceToHost(result_row_major.data(), gpu_data_result_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:376:  Tensor<DataType, 4, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:377:  Tensor<DataType, 4, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:381:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:382:  TensorMap<Tensor<DataType, 4, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:392:  array<IndexType, 5> patchColMajorTensorRange={{input_depth, ksize, ksize, 4, input_batches}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:393:  Tensor<DataType, 5, DataLayout,IndexType> result_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:394:  size_t patchTensorBuffSize =result_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:395:  DataType* gpu_data_result_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:396:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_result_col_major(gpu_data_result_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:398:  sycl_device.memcpyDeviceToHost(result_col_major.data(), gpu_data_result_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:407:  array<IndexType, 5> patchRowMajorTensorRange={{input_batches, 4, ksize, ksize, input_depth }};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:408:  Tensor<DataType, 5, RowMajor,IndexType> result_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:409:  patchTensorBuffSize =result_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:410:  DataType* gpu_data_result_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:411:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_result_row_major(gpu_data_result_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:413:  sycl_device.memcpyDeviceToHost(result_row_major.data(), gpu_data_result_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:473:  Tensor<DataType, 4, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:474:  Tensor<DataType, 4, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:478:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:479:  TensorMap<Tensor<DataType, 4, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:495:array<IndexType, 5> patchColMajorTensorRange={{input_depth, ksize, ksize, 2, input_batches}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:496:Tensor<DataType, 5, DataLayout,IndexType> result_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:497:size_t patchTensorBuffSize =result_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:498:DataType* gpu_data_result_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:499:TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_result_col_major(gpu_data_result_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:501:sycl_device.memcpyDeviceToHost(result_col_major.data(), gpu_data_result_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:512:  array<IndexType, 5> patchRowMajorTensorRange={{input_batches, 2, ksize, ksize, input_depth }};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:513:  Tensor<DataType, 5, RowMajor,IndexType> result_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:514:  patchTensorBuffSize =result_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:515:  DataType* gpu_data_result_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:516:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_result_row_major(gpu_data_result_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:518:  sycl_device.memcpyDeviceToHost(result_row_major.data(), gpu_data_result_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:526:  // Based on the calculation described in TensorTraits.h, padding happens to be 0.
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:576:  Tensor<DataType, 3, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:578:  Tensor<DataType, 3, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:582:  TensorMap<Tensor<DataType, 3, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:583:  TensorMap<Tensor<DataType, 3, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:595:  array<IndexType, 4> patchColMajorTensorRange={{sizeDim1, 1, 1, sizeDim2*sizeDim3}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:596:  Tensor<DataType, 4, DataLayout,IndexType> single_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:597:  size_t patchTensorBuffSize =single_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:598:  DataType* gpu_data_single_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:599:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_single_patch_col_major(gpu_data_single_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:601:  sycl_device.memcpyDeviceToHost(single_patch_col_major.data(), gpu_data_single_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:609:  array<IndexType, 4> patchRowMajorTensorRange={{sizeDim2*sizeDim3, 1, 1, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:610:  Tensor<DataType, 4, RowMajor,IndexType> single_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:611:  patchTensorBuffSize =single_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:612:  DataType* gpu_data_single_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:613:  TensorMap<Tensor<DataType, 4, RowMajor,IndexType>> gpu_single_patch_row_major(gpu_data_single_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:615:  sycl_device.memcpyDeviceToHost(single_patch_row_major.data(), gpu_data_single_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:642:  patchColMajorTensorRange={{sizeDim1, sizeDim2, sizeDim3, sizeDim2*sizeDim3}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:643:  Tensor<DataType, 4, DataLayout,IndexType> entire_image_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:644:  patchTensorBuffSize =entire_image_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:645:  DataType* gpu_data_entire_image_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:646:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_entire_image_patch_col_major(gpu_data_entire_image_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:648:  sycl_device.memcpyDeviceToHost(entire_image_patch_col_major.data(), gpu_data_entire_image_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:656:patchRowMajorTensorRange={{sizeDim2*sizeDim3, sizeDim3, sizeDim2, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:657:Tensor<DataType, 4, RowMajor,IndexType> entire_image_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:658:patchTensorBuffSize =entire_image_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:659:DataType* gpu_data_entire_image_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:660:TensorMap<Tensor<DataType, 4, RowMajor,IndexType>> gpu_entire_image_patch_row_major(gpu_data_entire_image_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:662:sycl_device.memcpyDeviceToHost(entire_image_patch_row_major.data(), gpu_data_entire_image_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:701:  patchColMajorTensorRange={{sizeDim1, 2, 2, sizeDim2*sizeDim3}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:702:  Tensor<DataType, 4, DataLayout,IndexType> twod_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:703:  patchTensorBuffSize =twod_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:704:  DataType* gpu_data_twod_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:705:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_twod_patch_col_major(gpu_data_twod_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:707:  sycl_device.memcpyDeviceToHost(twod_patch_col_major.data(), gpu_data_twod_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:715:  patchRowMajorTensorRange={{sizeDim2*sizeDim3, 2, 2, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:716:  Tensor<DataType, 4, RowMajor,IndexType> twod_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:717:  patchTensorBuffSize =twod_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:718:  DataType* gpu_data_twod_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:719:  TensorMap<Tensor<DataType, 4, RowMajor,IndexType>> gpu_twod_patch_row_major(gpu_data_twod_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:721:  sycl_device.memcpyDeviceToHost(twod_patch_row_major.data(), gpu_data_twod_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:727:  // Based on the calculation described in TensorTraits.h, padding happens to be 0.
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:787:  Tensor<DataType, 4, DataLayout,IndexType> l_in_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:791:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>> gpu_l_in_col_major(gpu_data_l_in_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:795:  array<IndexType, 5> patchTensorRange={{sizeDim1, 11, 11, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:796:  Tensor<DataType, 5, DataLayout,IndexType> l_out_col_major(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:797:  size_t patchTensorBuffSize =l_out_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:798:  DataType* gpu_data_l_out_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:799:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_l_out_col_major(gpu_data_l_out_col_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:801:  sycl_device.memcpyDeviceToHost(l_out_col_major.data(), gpu_data_l_out_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:810:  patchTensorRange={{sizeDim4, sizeDim2*sizeDim3, 11, 11, sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:811:  Tensor<DataType, 5, RowMajor,IndexType> l_out_row_major(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:812:  patchTensorBuffSize =l_out_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:813:  DataType* gpu_data_l_out_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:814:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>> gpu_l_out_row_major(gpu_data_l_out_row_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:816:  sycl_device.memcpyDeviceToHost(l_out_row_major.data(), gpu_data_l_out_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:867:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>>gpu_l_in_col_major_resize1(gpu_data_l_in_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:869:  patchTensorRange={{sizeDim1, 9, 9, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:870:  l_out_col_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:871:  patchTensorBuffSize =l_out_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:872:  gpu_data_l_out_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:873:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>>gpu_l_out_col_major_resize1(gpu_data_l_out_col_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:876:  sycl_device.memcpyDeviceToHost(l_out_col_major.data(), gpu_data_l_out_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:885:  patchTensorRange={{sizeDim4, sizeDim2*sizeDim3, 9, 9 ,sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:886:  l_out_row_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:887:  patchTensorBuffSize =l_out_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:888:  gpu_data_l_out_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:889:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>>gpu_l_out_row_major_resize1(gpu_data_l_out_row_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:891:  sycl_device.memcpyDeviceToHost(l_out_row_major.data(), gpu_data_l_out_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:939:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>>gpu_l_in_col_major_resize2(gpu_data_l_in_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:941:  patchTensorRange={{sizeDim1, 7, 7, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:942:  l_out_col_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:943:  patchTensorBuffSize =l_out_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:944:  gpu_data_l_out_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:945:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>>gpu_l_out_col_major_resize2(gpu_data_l_out_col_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:948:  sycl_device.memcpyDeviceToHost(l_out_col_major.data(), gpu_data_l_out_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:958:  patchTensorRange={{sizeDim4, sizeDim2*sizeDim3, 7, 7 ,sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:959:  l_out_row_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:960:  patchTensorBuffSize =l_out_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:961:  gpu_data_l_out_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:962:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>>gpu_l_out_row_major_resize2(gpu_data_l_out_row_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:964:  sycl_device.memcpyDeviceToHost(l_out_row_major.data(), gpu_data_l_out_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1011:  TensorMap<Tensor<DataType, 4, ColMajor, IndexType>>gpu_l_in_col_major_resize3(gpu_data_l_in_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1013:  patchTensorRange={{sizeDim1, 3, 3, sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1014:  l_out_col_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1015:  patchTensorBuffSize =l_out_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1016:  gpu_data_l_out_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1017:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>>gpu_l_out_col_major_resize3(gpu_data_l_out_col_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1020:  sycl_device.memcpyDeviceToHost(l_out_col_major.data(), gpu_data_l_out_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1030:  patchTensorRange={{sizeDim4, sizeDim2*sizeDim3, 3, 3 ,sizeDim1}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1031:  l_out_row_major.resize(patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1032:  patchTensorBuffSize =l_out_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1033:  gpu_data_l_out_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1034:  TensorMap<Tensor<DataType, 5, RowMajor,IndexType>>gpu_l_out_row_major_resize3(gpu_data_l_out_row_major, patchTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_image_patch_sycl.cpp:1036:  sycl_device.memcpyDeviceToHost(l_out_row_major.data(), gpu_data_l_out_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:22:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:24:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:39:  Tensor<DataType, 1, DataLayout,IndexType> vec(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:40:  Tensor<DataType, 1, DataLayout,IndexType> result(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:46:  TensorMap<Tensor<DataType, 1, DataLayout,IndexType>> gpu_vec(gpu_data_vec, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:47:  TensorMap<Tensor<DataType, 1, DataLayout,IndexType>> gpu_result(gpu_data_result, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:73:  Tensor<DataType, 2, DataLayout,IndexType> matrix(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:74:  Tensor<DataType, 2, DataLayout,IndexType> result(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:80:  TensorMap<Tensor<DataType, 2, DataLayout,IndexType>> gpu_matrix(gpu_data_matrix, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:81:  TensorMap<Tensor<DataType, 2, DataLayout,IndexType>> gpu_result(gpu_data_result, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:108:  Tensor<DataType, 2, DataLayout,IndexType> matrix(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:109:  Tensor<DataType, 2, DataLayout,IndexType> result(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:115:  TensorMap<Tensor<DataType, 2, DataLayout,IndexType>> gpu_matrix(gpu_data_matrix, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_generator_sycl.cpp:116:  TensorMap<Tensor<DataType, 2, DataLayout,IndexType>> gpu_result(gpu_data_result, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:3:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:5:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:11:  Tensor<int, 3> t(6, 7, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:17:  Tensor<bool,0> b;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:37:  Tensor<float, 3> A(6, 7, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:38:  Tensor<float, 3> B(6, 7, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:46:  Tensor<float, 3> R = A.constant(gamma) + A * A.constant(alpha) + B * B.constant(beta);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:47:  Tensor<float, 3> S = A * alpha + B * beta + gamma;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:48:  Tensor<float, 3> T = gamma + alpha * A + beta * B;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:57:  Tensor<float, 3> A(6, 7, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:58:  Tensor<float, 3> B(6, 7, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:67:  Tensor<float, 3> R = A.constant(gamma) - A / A.constant(alpha)
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sugar.cpp:69:  Tensor<float, 3> S = gamma - A / alpha - beta / B - delta;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:24:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:28:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:29:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:39:  Tensor<DataType, 4, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:40:  Tensor<DataType, 4, DataLayout,IndexType> no_shuffle(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:53:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:54:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu2(gpu_data2, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:82:  Tensor<DataType, 4, DataLayout,IndexType> shuffle(tensorrangeShuffle);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_shuffling_sycl.cpp:84:  TensorMap<Tensor<DataType, 4,DataLayout,IndexType>> gpu3(gpu_data3, tensorrangeShuffle);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:13:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:18:  Tensor<int, 3> random(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:21:  TensorMap<Tensor<const int, 3> > constant(random.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:22:  Tensor<int, 3> result(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:37:  Tensor<int, 3> random(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:40:  TensorMap<Tensor<const int, 3> > constant1(random.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:41:  TensorMap<const Tensor<int, 3> > constant2(random.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:42:  const TensorMap<Tensor<int, 3> > constant3(random.data(), 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:44:  Tensor<int, 2> result1 = constant1.chip(0, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:45:  Tensor<int, 2> result2 = constant2.chip(0, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_const.cpp:46:  Tensor<int, 2> result3 = constant3.chip(0, 2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:41:  Tensor<DataType, 4, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:42:  Tensor<DataType, 4, DataLayout,IndexType> no_stride(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:56:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:57:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_no_stride(gpu_data_no_stride, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:88:  array<IndexType, 4> inflatedTensorRange = {{inflatedSizeDim1, inflatedSizeDim2, inflatedSizeDim3, inflatedSizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:90:  Tensor<DataType, 4, DataLayout, IndexType> inflated(inflatedTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:92:  const size_t inflatedTensorBuffSize =inflated.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:93:  DataType* gpu_data_inflated  = static_cast<DataType*>(sycl_device.allocate(inflatedTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:94:  TensorMap<Tensor<DataType, 4, DataLayout, IndexType>> gpu_inflated(gpu_data_inflated, inflatedTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_inflation_sycl.cpp:96:  sycl_device.memcpyDeviceToHost(inflated.data(), gpu_data_inflated, inflatedTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:37:Tensor<DataType, 5, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:38:Tensor<DataType, 5, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:44:  TensorMap<Tensor<DataType, 5, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:45:  TensorMap<Tensor<DataType, 5, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:52:  array<IndexType, 6> patchColMajorTensorRange={{sizeDim0,1, 1, 1, sizeDim1*sizeDim2*sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:53:  Tensor<DataType, 6, DataLayout,IndexType> single_voxel_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:54:  size_t patchTensorBuffSize =single_voxel_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:55:  DataType* gpu_data_single_voxel_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:56:  TensorMap<Tensor<DataType, 6, DataLayout,IndexType>> gpu_single_voxel_patch_col_major(gpu_data_single_voxel_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:58:  sycl_device.memcpyDeviceToHost(single_voxel_patch_col_major.data(), gpu_data_single_voxel_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:68:  array<IndexType, 6> patchRowMajorTensorRange={{sizeDim4, sizeDim1*sizeDim2*sizeDim3, 1, 1, 1, sizeDim0}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:69:  Tensor<DataType, 6, RowMajor,IndexType> single_voxel_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:70:  patchTensorBuffSize =single_voxel_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:71:  DataType* gpu_data_single_voxel_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:72:  TensorMap<Tensor<DataType, 6, RowMajor,IndexType>> gpu_single_voxel_patch_row_major(gpu_data_single_voxel_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:74:  sycl_device.memcpyDeviceToHost(single_voxel_patch_row_major.data(), gpu_data_single_voxel_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:108:  Tensor<DataType, 5, DataLayout,IndexType> tensor_col_major(tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:109:  Tensor<DataType, 5, RowMajor,IndexType> tensor_row_major(tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:115:    TensorMap<Tensor<DataType, 5, ColMajor, IndexType>> gpu_col_major(gpu_data_col_major, tensorColMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:116:    TensorMap<Tensor<DataType, 5, RowMajor, IndexType>> gpu_row_major(gpu_data_row_major, tensorRowMajorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:124:    array<IndexType, 6> patchColMajorTensorRange={{depth,patch_z, patch_y, patch_x, patch_z*patch_y*patch_x, batch}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:125:    Tensor<DataType, 6, DataLayout,IndexType> entire_volume_patch_col_major(patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:126:    size_t patchTensorBuffSize =entire_volume_patch_col_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:127:    DataType* gpu_data_entire_volume_patch_col_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:128:    TensorMap<Tensor<DataType, 6, DataLayout,IndexType>> gpu_entire_volume_patch_col_major(gpu_data_entire_volume_patch_col_major, patchColMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:130:    sycl_device.memcpyDeviceToHost(entire_volume_patch_col_major.data(), gpu_data_entire_volume_patch_col_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:133://  Tensor<float, 5> tensor(depth, patch_z, patch_y, patch_x, batch);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:135://  Tensor<float, 5, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:137:  //Tensor<float, 6> entire_volume_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:146://  Tensor<float, 6, RowMajor> entire_volume_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:149:  array<IndexType, 6> patchRowMajorTensorRange={{batch,patch_z*patch_y*patch_x, patch_x, patch_y, patch_z, depth}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:150:  Tensor<DataType, 6, RowMajor,IndexType> entire_volume_patch_row_major(patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:151:  patchTensorBuffSize =entire_volume_patch_row_major.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:152:  DataType* gpu_data_entire_volume_patch_row_major  = static_cast<DataType*>(sycl_device.allocate(patchTensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:153:  TensorMap<Tensor<DataType, 6, RowMajor,IndexType>> gpu_entire_volume_patch_row_major(gpu_data_entire_volume_patch_row_major, patchRowMajorTensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch_sycl.cpp:155:  sycl_device.memcpyDeviceToHost(entire_volume_patch_row_major.data(), gpu_data_entire_volume_patch_row_major, patchTensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:18:  Tensor<float, 4> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:33:  Tensor<float, 1> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:50:  Tensor<float, 5> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:81:  Tensor<float, 4> result0 = tensor.sum(reduction_axis0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:97:  Tensor<float, 3> result1 = tensor.sum(reduction_axis1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:113:  Tensor<float, 2> result2 = tensor.sum(reduction_axis2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:129:  Tensor<float, 1> result3 = tensor.sum(reduction_axis3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:145:  Tensor<float, 0> result4 = tensor.sum(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:164:  Tensor<float, 5> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:269:  Tensor<float, 4> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:285:  Tensor<float, 1> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:301:  Tensor<float, 4> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:344:  Tensor<float, 0> result1 = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:345:  Tensor<float, 0> result2 = tensor.sum(reduction_indices);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_index_list.cpp:346:  Tensor<float, 0> result3 = tensor.sum(reduction_list);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:19:  Tensor<double, 1, DataLayout> tensor(sequence_length);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:25:  Tensor<std::complex<double>, 1, DataLayout> tensor_after_fft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:26:  Tensor<std::complex<double>, 1, DataLayout> tensor_after_fft_ifft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:41:  Tensor<double, 2, DataLayout> tensor(dim0, dim1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:48:  Tensor<std::complex<double>, 2, DataLayout> tensor_after_fft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:49:  Tensor<std::complex<double>, 2, DataLayout> tensor_after_fft_ifft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:69:  Tensor<double, 3, DataLayout> tensor(dim0, dim1, dim2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:77:  Tensor<std::complex<double>, 3, DataLayout> tensor_after_fft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:78:  Tensor<std::complex<double>, 3, DataLayout> tensor_after_fft_ifft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:101:  Tensor<double, 4, DataLayout> tensor(dim0, dim1, dim2, dim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:108:  Tensor<std::complex<double>, 4, DataLayout> tensor_after_fft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_ifft.cpp:109:  Tensor<double, 4, DataLayout> tensor_after_fft_ifft;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:31:  Tensor<DataType, 2, DataLayout, IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:32:  Tensor<DataType, 0, DataLayout, IndexType> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:33:  Tensor<DataType, 0, DataLayout, IndexType> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:42:  TensorMap<Tensor<DataType, 2, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:43:  TensorMap<Tensor<DataType, 0, DataLayout, IndexType> >  out_gpu(gpu_out_data);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:62:  Tensor<DataType, 2, DataLayout, IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:63:  Tensor<DataType, 0, DataLayout, IndexType> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:64:  Tensor<DataType, 0, DataLayout, IndexType> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:73:  TensorMap<Tensor<DataType, 2, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:74:  TensorMap<Tensor<DataType, 0, DataLayout, IndexType> >  out_gpu(gpu_out_data);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:98:  Tensor<DataType, 3, DataLayout, IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:99:  Tensor<DataType, 2, DataLayout, IndexType> redux(reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:100:  Tensor<DataType, 2, DataLayout, IndexType> redux_gpu(reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:109:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:110:  TensorMap<Tensor<DataType, 2, DataLayout, IndexType> >  out_gpu(gpu_out_data, reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:137:  Tensor<DataType, 3, DataLayout, IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:138:  Tensor<DataType, 2, DataLayout, IndexType> redux(reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:139:  Tensor<DataType, 2, DataLayout, IndexType> redux_gpu(reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:148:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType> >  in_gpu(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_sycl.cpp:149:  TensorMap<Tensor<DataType, 2, DataLayout, IndexType> >  out_gpu(gpu_out_data, reduced_tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:19:  Tensor<float, 5> tensor1(2,3,1,7,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:22:  Tensor<float, 3> tensor2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:23:  Tensor<float, 2> tensor3(6,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:24:  Tensor<float, 2> tensor4(2,21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:26:  Tensor<float, 3>::Dimensions dim1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:28:  Tensor<float, 2>::Dimensions dim2(6,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:30:  Tensor<float, 2>::Dimensions dim3(2,21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:52:  TensorMap<Tensor<float, 5>> tensor1(m1.data(), 2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:53:  TensorMap<Tensor<float, 5>> tensor2(m2.data(), 3,5,7,11,13);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:54:  Tensor<float, 2>::Dimensions newDims1(2,3*5*7*11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:55:  Tensor<float, 2>::Dimensions newDims2(3*5*7*11,13);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:56:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:58:  Tensor<float, 2> tensor3(2,13);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:72:  Tensor<float, 3> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:75:  Tensor<float, 2> tensor2d(6,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:76:  Tensor<float, 3>::Dimensions dim(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:80:  TensorMap<Tensor<float, 5>> tensor5d(scratch, 2,3,1,7,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:96:  Tensor<float, 5, DataLayout> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:99:  Tensor<float, 5, DataLayout> slice1(1,1,1,1,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:105:  Tensor<float, 5, DataLayout> slice2(1,1,2,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:122:  TensorMap<Tensor<const float, 1> > m(b, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:125:  TensorRef<Tensor<const float, 1> > slice_ref(m.slice(offsets, m.dimensions()));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:139:  TensorMap<Tensor<float, 2, DataLayout>> tensor1(m1.data(), 7, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:140:  TensorMap<Tensor<float, 2, DataLayout>> tensor2(m2.data(), 3, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:141:  Tensor<float, 2, DataLayout> tensor3(3,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:142:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:159:  TensorMap<Tensor<const float, 2, DataLayout>> tensor4(m1.data(), 7, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:160:  Tensor<float, 1, DataLayout> tensor6 = tensor4.reshape(DSizes<ptrdiff_t, 1>(7*7)).exp().slice(DSizes<ptrdiff_t, 1>(0), DSizes<ptrdiff_t, 1>(35));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:169:  Tensor<float, 3, DataLayout> tensor1(2,2,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:171:  Tensor<float, 3, DataLayout> tensor2(2,2,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:173:  Tensor<float, 3, DataLayout> tensor3(4,3,5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:175:  Tensor<float, 3, DataLayout> tensor4(4,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:177:  Tensor<float, 3, DataLayout> tensor5(10,13,12);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:180:  Tensor<float, 3, DataLayout> result(4,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:229:  Tensor<float, 4, DataLayout> tensor(3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:234:  typedef TensorEvaluator<decltype(tensor.slice(offsets, extents)), DefaultDevice> SliceEvaluator;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:324:  typedef Tensor<float, 5, DataLayout> Tensor5f;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:326:  typedef Tensor<float, 2, DataLayout> Tensor2f;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:328:  Tensor<float, 5, DataLayout> tensor(2,3,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:329:  Tensor<float, 2, DataLayout> tensor2(7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:334:    Tensor2f slice(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:347:    Tensor2f slice(0,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:355:    Tensor2f slice(7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:368:    Tensor5f slice1(1,1,1,1,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:377:    Tensor5f slice(1,1,2,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:392:    Tensor5f slice(1,1,2,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:407:    Tensor5f slice(1,1,2,2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:418:  typedef Tensor<float, 2, DataLayout> Tensor2f;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:421:  Tensor<float, 2, DataLayout> tensor(7,11),tensor2(7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:424:  Tensor2f slice(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:445:  Eigen::Tensor<float, 2, DataLayout> matrix(7, 11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing.cpp:449:  Eigen::Tensor<float, 3, DataLayout> tensor =
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:15:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:21:  Tensor<std::complex<float>, 1> data1(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:22:  Tensor<std::complex<float>, 1> data2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:28:  Tensor<std::complex<float>, 1> sum = data1 + data2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:37:  Tensor<std::complex<float>, 1> data1(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:38:  Tensor<std::complex<double>, 1> data2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:42:  Tensor<float, 1> abs1 = data1.abs();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:43:  Tensor<double, 1> abs2 = data2.abs();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:53:  Tensor<std::complex<float>, 1> data1(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:54:  Tensor<std::complex<double>, 1> data2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:55:  Tensor<int, 1> data3(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:60:  Tensor<std::complex<float>, 1> conj1 = data1.conjugate();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:61:  Tensor<std::complex<double>, 1> conj2 = data2.conjugate();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:62:  Tensor<int, 1> conj3 = data3.conjugate();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:72:  Tensor<std::complex<float>, 4> t_left(30, 50, 8, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:73:  Tensor<std::complex<float>, 5> t_right(8, 31, 7, 20, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:74:  Tensor<std::complex<float>, 5> t_result(30, 50, 7, 20, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_complex.cpp:85:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:3:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:5:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:9:  Tensor<float, 5> tensor(4,2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:11:  Tensor<float, 5, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:13:  Tensor<float, 6> single_voxel_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:22:  Tensor<float, 6, RowMajor> single_voxel_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:47:  Tensor<float, 5> tensor(depth, patch_z, patch_y, patch_x, batch);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:49:  Tensor<float, 5, RowMajor> tensor_row_major = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:51:  Tensor<float, 6> entire_volume_patch;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_volume_patch.cpp:60:  Tensor<float, 6, RowMajor> entire_volume_patch_row_major;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:25:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:26:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:31:  Tensor<DataType, 3, Layout, DenseIndex> in(Eigen::array<DenseIndex, 3>{{2,2,2}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:32:  Tensor<DenseIndex, 0, Layout, DenseIndex> out_max;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:33:  Tensor<DenseIndex, 0, Layout, DenseIndex> out_min;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:46:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, Layout, DenseIndex> > gpu_in(d_in, Eigen::array<DenseIndex, 3>{{2,2,2}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:47:  Eigen::TensorMap<Eigen::Tensor<DenseIndex, 0, Layout, DenseIndex> > gpu_out_max(d_out_max);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:48:  Eigen::TensorMap<Eigen::Tensor<DenseIndex, 0, Layout, DenseIndex> > gpu_out_min(d_out_min);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:73:  Tensor<DataType, 4, DataLayout, DenseIndex> tensor(sizeDim0,sizeDim1,sizeDim2,sizeDim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:82:    Tensor<DenseIndex, 3, DataLayout, DenseIndex> tensor_arg(out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:104:    Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, DenseIndex> > gpu_in(d_in, Eigen::array<DenseIndex, 4>{{sizeDim0,sizeDim1,sizeDim2,sizeDim3}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:105:    Eigen::TensorMap<Eigen::Tensor<DenseIndex, 3, DataLayout, DenseIndex> > gpu_out(d_out, out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:153:  Tensor<DataType, 4, DataLayout, DenseIndex> tensor(sizeDim0,sizeDim1,sizeDim2,sizeDim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:162:    Tensor<DenseIndex, 3, DataLayout, DenseIndex> tensor_arg(out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:184:    Eigen::TensorMap<Eigen::Tensor<DataType, 4, DataLayout, DenseIndex> > gpu_in(d_in, Eigen::array<DenseIndex, 4>{{sizeDim0,sizeDim1,sizeDim2,sizeDim3}});
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_sycl.cpp:185:    Eigen::TensorMap<Eigen::Tensor<DenseIndex, 3, DataLayout, DenseIndex> > gpu_out(d_out, out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:19:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:21:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:24:  Tensor<float, 1, 0, int> in1(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:25:  Tensor<float, 1, 0, int> in2(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:41:  Eigen::TensorMap<Eigen::Tensor<float, 1, 0, int>, Eigen::Aligned> gpu_in1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:43:  Eigen::TensorMap<Eigen::Tensor<float, 1, 0, int>, Eigen::Aligned> gpu_in2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:49:  Tensor<float, 1, 0, int> new1(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:50:  Tensor<float, 1, 0, int> new2(2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:69:  Tensor<float, 1> in1(Eigen::array<Eigen::DenseIndex, 1>(2));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:70:  Tensor<float, 1> in2(Eigen::array<Eigen::DenseIndex, 1>(2));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:71:  Tensor<float, 1> out(Eigen::array<Eigen::DenseIndex, 1>(2));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:92:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_in1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:94:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_in2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:96:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_out(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:118:  Tensor<float, 3> in1(Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:119:  Tensor<float, 3> in2(Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:120:  Tensor<float, 3> in3(Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:121:  Tensor<float, 3> out(Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:147:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_in1(d_in1, Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:148:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_in2(d_in2, Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:149:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_in3(d_in3, Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:150:  Eigen::TensorMap<Eigen::Tensor<float, 3> > gpu_out(d_out, Eigen::array<Eigen::DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:172:  Tensor<float, 1> in1(200);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:173:  Tensor<bool, 1> out(200);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:189:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_in1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:191:  Eigen::TensorMap<Eigen::Tensor<bool, 1>, Eigen::Aligned> gpu_out(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:210:  Tensor<float, 4> in1(72,53,97,113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:211:  Tensor<float, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:227:  Eigen::TensorMap<Eigen::Tensor<float, 4> > gpu_in1(d_in1, 72,53,97,113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:228:  Eigen::TensorMap<Eigen::Tensor<float, 2> > gpu_out(d_out, 72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:262:  Tensor<float, 4, DataLayout> t_left(6, 50, 3, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:263:  Tensor<float, 5, DataLayout> t_right(Eigen::array<Eigen::DenseIndex, 5>(3, 31, 7, 20, 1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:264:  Tensor<float, 5, DataLayout> t_result(Eigen::array<Eigen::DenseIndex, 5>(6, 50, 7, 20, 1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:287:  Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout> > gpu_t_left(d_t_left, 6, 50, 3, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:288:  Eigen::TensorMap<Eigen::Tensor<float, 5, DataLayout> > gpu_t_right(d_t_right, 3, 31, 7, 20, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:289:  Eigen::TensorMap<Eigen::Tensor<float, 5, DataLayout> > gpu_t_result(d_t_result, 6, 50, 7, 20, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:296:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:321:  Tensor<float, 4, DataLayout> input(74,37,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:322:  Tensor<float, 1, DataLayout> kernel(4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:323:  Tensor<float, 4, DataLayout> out(74,34,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:344:  Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout> > gpu_input(d_input, 74,37,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:345:  Eigen::TensorMap<Eigen::Tensor<float, 1, DataLayout> > gpu_kernel(d_kernel, 4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:346:  Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout> > gpu_out(d_out, 74,34,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:374:  Tensor<float, 4, ColMajor> input(74,9,11,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:375:  Tensor<float, 1, ColMajor> kernel(4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:376:  Tensor<float, 4, ColMajor> out(71,9,11,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:397:  Eigen::TensorMap<Eigen::Tensor<float, 4, ColMajor> > gpu_input(d_input,74,9,11,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:398:  Eigen::TensorMap<Eigen::Tensor<float, 1, ColMajor> > gpu_kernel(d_kernel,4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:399:  Eigen::TensorMap<Eigen::Tensor<float, 4, ColMajor> > gpu_out(d_out,71,9,11,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:427:  Tensor<float, 4, RowMajor> input(7,9,11,74);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:428:  Tensor<float, 1, RowMajor> kernel(4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:429:  Tensor<float, 4, RowMajor> out(7,9,11,71);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:450:  Eigen::TensorMap<Eigen::Tensor<float, 4, RowMajor> > gpu_input(d_input, 7,9,11,74);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:451:  Eigen::TensorMap<Eigen::Tensor<float, 1, RowMajor> > gpu_kernel(d_kernel, 4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:452:  Eigen::TensorMap<Eigen::Tensor<float, 4, RowMajor> > gpu_out(d_out, 7,9,11,71);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:481:  Tensor<float, 4, DataLayout> input(74,37,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:482:  Tensor<float, 2, DataLayout> kernel(3,4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:483:  Tensor<float, 4, DataLayout> out(74,35,8,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:504:  Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout> > gpu_input(d_input,74,37,11,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:505:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> > gpu_kernel(d_kernel,3,4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:506:  Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout> > gpu_out(d_out,74,35,8,137);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:545:  Tensor<float, 5, DataLayout> input(Eigen::array<Eigen::DenseIndex, 5>(74,37,11,137,17));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:546:  Tensor<float, 3, DataLayout> kernel(3,4,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:547:  Tensor<float, 5, DataLayout> out(Eigen::array<Eigen::DenseIndex, 5>(74,35,8,136,17));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:568:  Eigen::TensorMap<Eigen::Tensor<float, 5, DataLayout> > gpu_input(d_input,74,37,11,137,17);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:569:  Eigen::TensorMap<Eigen::Tensor<float, 3, DataLayout> > gpu_kernel(d_kernel,3,4,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:570:  Eigen::TensorMap<Eigen::Tensor<float, 5, DataLayout> > gpu_out(d_out,74,35,8,136,17);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:624:  Tensor<Scalar, 2> in(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:627:  Tensor<Scalar, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:642:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_in(d_in, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:643:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_out(d_out, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:663:  Tensor<Scalar, 1> in(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:664:  Tensor<Scalar, 1> out(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:665:  Tensor<Scalar, 1> expected_out(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:696:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in(d_in, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:697:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_out(d_out, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:718:  Tensor<Scalar, 1> in_x(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:719:  Tensor<Scalar, 1> in_q(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:720:  Tensor<Scalar, 1> out(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:721:  Tensor<Scalar, 1> expected_out(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:760:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_x(d_in_x, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:761:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_q(d_in_q, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:762:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_out(d_out, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:786:  Tensor<Scalar, 1> in_x(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:787:  Tensor<Scalar, 1> in_n(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:788:  Tensor<Scalar, 1> out(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:789:  Tensor<Scalar, 1> expected_out(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:831:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_x(d_in_x, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:832:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_n(d_in_n, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:833:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_out(d_out, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:852:  Tensor<Scalar, 2> a(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:853:  Tensor<Scalar, 2> x(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:854:  Tensor<Scalar, 2> out(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:896:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_a(d_a, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:897:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_x(d_x, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:898:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_out(d_out, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:923:  Tensor<Scalar, 2> a(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:924:  Tensor<Scalar, 2> x(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:925:  Tensor<Scalar, 2> out(6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:966:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_a(d_a, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:967:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_x(d_x, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:968:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_out(d_out, 6, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:993:  Tensor<Scalar, 2> in(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:996:  Tensor<Scalar, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1011:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_in(d_in, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1012:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_out(d_out, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1032:  Tensor<Scalar, 2> in(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1035:  Tensor<Scalar, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1050:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_in(d_in, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1051:  Eigen::TensorMap<Eigen::Tensor<Scalar, 2> > gpu_out(d_out, 72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1071:  Tensor<Scalar, 1> in_x(125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1072:  Tensor<Scalar, 1> in_a(125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1073:  Tensor<Scalar, 1> in_b(125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1074:  Tensor<Scalar, 1> out(125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1075:  Tensor<Scalar, 1> expected_out(125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1190:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_x(d_in_x, 125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1191:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_a(d_in_a, 125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1192:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_in_b(d_in_b, 125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_cuda.cu:1193:  Eigen::TensorMap<Eigen::Tensor<Scalar, 1> > gpu_out(d_out, 125);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:21:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:30:  Tensor<float, 4, DataLayout> reversed_tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:99:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:108:  Tensor<float, 4, DataLayout> expected(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reverse.cpp:115:  Tensor<float, 4, DataLayout> result(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:20:  TensorMap<Tensor<const float, 2>> mat1(data1, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:22:  const TensorMap<Tensor<float, 2>> mat2(data2, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:29:  Tensor<float, 2> rslt1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:31:  Tensor<float, 2> rslt2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:34:  Tensor<float, 2> rslt3 = mat1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:35:  Tensor<float, 2> rslt4 = mat2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:37:  Tensor<float, 2> rslt5(mat1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:38:  Tensor<float, 2> rslt6(mat2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:56:  TensorMap<Tensor<const float, 2>> mat1(data1, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:58:  TensorMap<Tensor<float, 2>> mat2(data2, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:65:  Tensor<float, 2> sum1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:67:  Tensor<float, 2> sum2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:82:  TensorMap<Tensor<const float, 2>> mat1(data1, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_const_values.cpp:84:  TensorMap<Tensor<float, 2>> mat2(data2, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:23:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:25:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:37:  Tensor<DataType, 3, ColMajor, IndexType> tensor1(tensorColRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:38:  Tensor<DataType, 3, RowMajor, IndexType> tensor2(tensorRowRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:43:  TensorMap<Tensor<DataType, 3, ColMajor, IndexType>> gpu1(gpu_data1, tensorColRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:44:  TensorMap<Tensor<DataType, 3, RowMajor, IndexType>> gpu2(gpu_data2, tensorRowRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:51://  Tensor<float, 3, ColMajor> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:54://  Tensor<float, 3, RowMajor> tensor2 = tensor.swap_layout();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:80:  Tensor<DataType, 3, ColMajor, IndexType> tensor1(tensorColRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:81:  Tensor<DataType, 3, RowMajor, IndexType> tensor2(tensorRowRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:86:  TensorMap<Tensor<DataType, 3, ColMajor, IndexType>> gpu1(gpu_data1, tensorColRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:87:  TensorMap<Tensor<DataType, 3, RowMajor, IndexType>> gpu2(gpu_data2, tensorRowRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:94://  Tensor<float, 3, ColMajor> tensor(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_layout_swap_sycl.cpp:97:  //Tensor<float, 3, RowMajor> tensor2(7,3,2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:19:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:31:  Tensor<Type, 2, DataLayout> in(num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:34:  Tensor<Type, 0, DataLayout> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:43:  TensorMap<Tensor<Type, 2, DataLayout> > in_gpu(gpu_in_ptr, num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:44:  TensorMap<Tensor<Type, 0, DataLayout> > out_gpu(gpu_out_ptr);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:48:  Tensor<Type, 0, DataLayout> full_redux_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:65:  Tensor<Type, 3, DataLayout> in(dim_x, dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:70:  Tensor<Type, 2, DataLayout> redux = in.sum(red_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:79:  Eigen::TensorMap<Eigen::Tensor<Type, 3, DataLayout> > gpu_in(in_data, dim_x, dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:80:  Eigen::TensorMap<Eigen::Tensor<Type, 2, DataLayout> > gpu_out(out_data, dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:86:  Tensor<Type, 2, DataLayout> redux_gpu(dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:105:  Tensor<Type, 3, DataLayout> in(dim_x, dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:110:  Tensor<Type, 2, DataLayout> redux = in.sum(red_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:119:  Eigen::TensorMap<Eigen::Tensor<Type, 3, DataLayout> > gpu_in(in_data, dim_x, dim_y, dim_z);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:120:  Eigen::TensorMap<Eigen::Tensor<Type, 2, DataLayout> > gpu_out(out_data, dim_x, dim_y);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction_cuda.cu:126:  Tensor<Type, 2, DataLayout> redux_gpu(dim_x, dim_y);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:19:  Tensor<int, 0> scalar1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:20:  Tensor<int, 0, RowMajor> scalar2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:21:  Tensor<int, 0> scalar3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:22:  Tensor<int, 0, RowMajor> scalar4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:40:  Tensor<int, 0> scalar5(scalar1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:48:  Tensor<int, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:49:  Tensor<int, 1, RowMajor> vec2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:50:  Tensor<int, 1> vec3;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:51:  Tensor<int, 1, RowMajor> vec4;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:96:  Tensor<int, 1> vec5(vec1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:115:  Tensor<int, 2> mat1(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:116:  Tensor<int, 2, RowMajor> mat2(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:159:  Tensor<int, 3> epsilon(3,3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:202:  Tensor<int, 3> t1(dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:203:  Tensor<int, 3, RowMajor> t2(dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:277:  Tensor<int, 3> epsilon(3,3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:282:  Tensor<int, 3> e2(3,3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_simple.cpp:297:  Tensor<int, 3> epsilon;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:25:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:26:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:38:    Tensor<SCALAR, 3, Layout, int64_t> in(tensorRange);                        \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:39:    Tensor<SCALAR, 3, Layout, int64_t> out(tensorRange);                       \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:42:    Tensor<SCALAR, 3, Layout, int64_t> reference(out);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:47:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu(gpu_data, tensorRange);          \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:48:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);  \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:66:    Tensor<SCALAR, 3, Layout, int64_t> out(tensorRange);                       \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:68:    Tensor<SCALAR, 3, Layout, int64_t> reference(out);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:71:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);  \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:105:    Tensor<SCALAR, 3, Layout, int64_t> in(tensorRange);                        \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:106:    Tensor<bool, 3, Layout, int64_t> out(tensorRange);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:112:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu(gpu_data, tensorRange);          \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:113:    TensorMap<Tensor<bool, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);    \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:151:    Tensor<SCALAR, 3, Layout, int64_t> in_1(tensorRange);                      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:152:    Tensor<SCALAR, 3, Layout, int64_t> in_2(tensorRange);                      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:153:    Tensor<SCALAR, 3, Layout, int64_t> out(tensorRange);                       \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:156:    Tensor<SCALAR, 3, Layout, int64_t> reference(out);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:163:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_1(gpu_data_1, tensorRange);      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:164:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_2(gpu_data_2, tensorRange);      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:165:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);  \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:186:    Tensor<SCALAR, 3, Layout, int64_t> in_1(tensorRange);                      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:187:    Tensor<SCALAR, 3, Layout, int64_t> in_2(tensorRange);                      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:188:    Tensor<SCALAR, 3, Layout, int64_t> out(tensorRange);                       \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:191:    Tensor<SCALAR, 3, Layout, int64_t> reference(out);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:198:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_1(gpu_data_1, tensorRange);      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:199:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_2(gpu_data_2, tensorRange);      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:200:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);  \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:219:    Tensor<SCALAR, 3, Layout, int64_t> in_1(tensorRange);                      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:220:    Tensor<SCALAR, 3, Layout, int64_t> out(tensorRange);                       \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:222:    Tensor<SCALAR, 3, Layout, int64_t> reference(out);                         \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:227:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_1(gpu_data_1, tensorRange);      \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_builtins_sycl.cpp:228:    TensorMap<Tensor<SCALAR, 3, Layout, int64_t>> gpu_out(gpu_data_out, tensorRange);  \
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:19:  Tensor<int, 3, DataLayout> left(2, 3, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:20:  Tensor<int, 3, DataLayout> right(3, 3, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:25:  Tensor<int, 3, DataLayout> concatenation = left.concatenate(right, 0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:39:  Tensor<int, 2, DataLayout> left(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:40:  Tensor<int, 3, DataLayout> right(2, 3, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:45:  Tensor<int, 3, DataLayout> concatenation = left.concatenate(right, 0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:49:  Tensor<int, 3, DataLayout> concatenation = left
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:50:      .reshape(Tensor<int, 3>::Dimensions(2, 3, 1))
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:52:  Tensor<int, 2, DataLayout> alternative = left
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:53:      .concatenate(right.reshape(Tensor<int, 2>::Dimensions{{{2, 3}}}), 0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:59:  Tensor<int, 3, DataLayout> left(2, 3, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:60:  Tensor<int, 3, DataLayout> right(2, 3, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:64:  Tensor<int, 3, DataLayout> concatenation = left.concatenate(right, 0);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:108:  Tensor<int, 2> t1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:109:  Tensor<int, 2> t2(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_concatenation.cpp:113:  Tensor<int, 2> result(4, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:19:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:21:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:26:  Tensor<double, 3, Layout> in(Eigen::array<DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:27:  Tensor<DenseIndex, 1, Layout> out_max(Eigen::array<DenseIndex, 1>(1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:28:  Tensor<DenseIndex, 1, Layout> out_min(Eigen::array<DenseIndex, 1>(1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:49:  Eigen::TensorMap<Eigen::Tensor<double, 3, Layout>, Aligned > gpu_in(d_in, Eigen::array<DenseIndex, 3>(72,53,97));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:50:  Eigen::TensorMap<Eigen::Tensor<DenseIndex, 1, Layout>, Aligned > gpu_out_max(d_out_max, Eigen::array<DenseIndex, 1>(1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:51:  Eigen::TensorMap<Eigen::Tensor<DenseIndex, 1, Layout>, Aligned > gpu_out_min(d_out_min, Eigen::array<DenseIndex, 1>(1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:71:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:82:    Tensor<DenseIndex, 3, DataLayout> tensor_arg(out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:111:    Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout>, Aligned > gpu_in(d_in, Eigen::array<DenseIndex, 4>(2, 3, 5, 7));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:112:    Eigen::TensorMap<Eigen::Tensor<DenseIndex, 3, DataLayout>, Aligned > gpu_out(d_out, out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:160:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:171:    Tensor<DenseIndex, 3, DataLayout> tensor_arg(out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:200:    Eigen::TensorMap<Eigen::Tensor<float, 4, DataLayout>, Aligned > gpu_in(d_in, Eigen::array<DenseIndex, 4>(2, 3, 5, 7));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax_cuda.cu:201:    Eigen::TensorMap<Eigen::Tensor<DenseIndex, 3, DataLayout>, Aligned > gpu_out(d_out, out_shape);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:20:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:22:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:34:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:36:  Eigen::TensorMap<Eigen::Tensor<bool, 1>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:38:  Eigen::TensorMap<Eigen::Tensor<bool, 1>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:45:  Tensor<bool, 1> half_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:46:  Tensor<bool, 1> full_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:74:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:76:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:78:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_conv(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:85:  Tensor<float, 1> initial(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:86:  Tensor<float, 1> final(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:109:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:111:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:113:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:120:  Tensor<float, 1> half_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:121:  Tensor<float, 1> full_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:147:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:149:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:151:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:153:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:161:  Tensor<float, 1> half_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:162:  Tensor<float, 1> full_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:194:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float1(d_float1, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:195:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float2(d_float2, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:196:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float3(d_float3, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:197:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res1_half(d_res1_half, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:198:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res1_float(d_res1_float, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:199:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res2_half(d_res2_half, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:200:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res2_float(d_res2_float, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:201:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res3_half(d_res3_half, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:202:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res3_float(d_res3_float, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:203:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res4_half(d_res3_half, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:204:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res4_float(d_res3_float, num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:226:  Tensor<float, 1> input1(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:227:  Tensor<Eigen::half, 1> half_prec1(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:228:  Tensor<Eigen::half, 1> full_prec1(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:229:  Tensor<float, 1> input2(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:230:  Tensor<Eigen::half, 1> half_prec2(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:231:  Tensor<Eigen::half, 1> full_prec2(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:232:  Tensor<float, 1> input3(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:233:  Tensor<Eigen::half, 1> half_prec3(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:234:  Tensor<Eigen::half, 1> full_prec3(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:285:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:287:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:289:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 2>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:291:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 2>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:297:  typedef Tensor<float, 2>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:302:  Tensor<Eigen::half, 2> half_prec(rows, cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:303:  Tensor<Eigen::half, 2> full_prec(rows, cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:339:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:341:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:343:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:345:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 1>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:355:  Tensor<Eigen::half, 1> half_prec(result_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:356:  Tensor<Eigen::half, 1> full_prec(result_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:396:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:398:  Eigen::TensorMap<Eigen::Tensor<float, 2>, Eigen::Aligned> gpu_float2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:400:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 0>, Eigen::Aligned> gpu_res_half(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:402:  Eigen::TensorMap<Eigen::Tensor<Eigen::half, 0>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:411:  Tensor<Eigen::half, 0> half_prec;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:412:  Tensor<Eigen::half, 0> full_prec;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:445:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:447:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_half1(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:449: Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Unaligned> gpu_res_half2(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:451:  Eigen::TensorMap<Eigen::Tensor<float, 1>, Eigen::Aligned> gpu_res_float(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:462:  Tensor<float, 1> half_prec1(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:463:  Tensor<float, 1> half_prec2(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_float16_cuda.cu:464:  Tensor<float, 1> full_prec(num_elem);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:24:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:26:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:38:  array<IndexType, 4> chip1TensorRange = {{sizeDim2, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:40:  Tensor<DataType, 5, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:41:  Tensor<DataType, 4, DataLayout,IndexType> chip1(chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:46:  const size_t chip1TensorBuffSize =chip1.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:48:  DataType* gpu_data_chip1  = static_cast<DataType*>(sycl_device.allocate(chip1TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:50:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:51:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip1(gpu_data_chip1, chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:55:  sycl_device.memcpyDeviceToHost(chip1.data(), gpu_data_chip1, chip1TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:72:  array<IndexType, 4> chip2TensorRange = {{sizeDim1, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:73:  Tensor<DataType, 4, DataLayout,IndexType> chip2(chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:74:  const size_t chip2TensorBuffSize =chip2.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:75:  DataType* gpu_data_chip2  = static_cast<DataType*>(sycl_device.allocate(chip2TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:76:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip2(gpu_data_chip2, chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:79:  sycl_device.memcpyDeviceToHost(chip2.data(), gpu_data_chip2, chip2TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:96:  array<IndexType, 4> chip3TensorRange = {{sizeDim1, sizeDim2, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:97:  Tensor<DataType, 4, DataLayout,IndexType> chip3(chip3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:98:  const size_t chip3TensorBuffSize =chip3.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:99:  DataType* gpu_data_chip3  = static_cast<DataType*>(sycl_device.allocate(chip3TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:100:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip3(gpu_data_chip3, chip3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:103:  sycl_device.memcpyDeviceToHost(chip3.data(), gpu_data_chip3, chip3TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:120:  array<IndexType, 4> chip4TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:121:  Tensor<DataType, 4, DataLayout,IndexType> chip4(chip4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:122:  const size_t chip4TensorBuffSize =chip4.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:123:  DataType* gpu_data_chip4  = static_cast<DataType*>(sycl_device.allocate(chip4TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:124:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip4(gpu_data_chip4, chip4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:127:  sycl_device.memcpyDeviceToHost(chip4.data(), gpu_data_chip4, chip4TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:145:  array<IndexType, 4> chip5TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:146:  Tensor<DataType, 4, DataLayout,IndexType> chip5(chip5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:147:  const size_t chip5TensorBuffSize =chip5.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:148:  DataType* gpu_data_chip5  = static_cast<DataType*>(sycl_device.allocate(chip5TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:149:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip5(gpu_data_chip5, chip5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:152:  sycl_device.memcpyDeviceToHost(chip5.data(), gpu_data_chip5, chip5TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:187:  array<IndexType, 4> chip1TensorRange = {{sizeDim2, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:189:  Tensor<DataType, 5, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:190:  Tensor<DataType, 4, DataLayout,IndexType> chip1(chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:195:  const size_t chip1TensorBuffSize =chip1.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:197:  DataType* gpu_data_chip1  = static_cast<DataType*>(sycl_device.allocate(chip1TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:199:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:200:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip1(gpu_data_chip1, chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:204:  sycl_device.memcpyDeviceToHost(chip1.data(), gpu_data_chip1, chip1TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:221:  array<IndexType, 4> chip2TensorRange = {{sizeDim1, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:222:  Tensor<DataType, 4, DataLayout,IndexType> chip2(chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:223:  const size_t chip2TensorBuffSize =chip2.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:224:  DataType* gpu_data_chip2  = static_cast<DataType*>(sycl_device.allocate(chip2TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:225:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip2(gpu_data_chip2, chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:228:  sycl_device.memcpyDeviceToHost(chip2.data(), gpu_data_chip2, chip2TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:245:  array<IndexType, 4> chip3TensorRange = {{sizeDim1, sizeDim2, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:246:  Tensor<DataType, 4, DataLayout,IndexType> chip3(chip3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:247:  const size_t chip3TensorBuffSize =chip3.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:248:  DataType* gpu_data_chip3  = static_cast<DataType*>(sycl_device.allocate(chip3TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:249:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip3(gpu_data_chip3, chip3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:252:  sycl_device.memcpyDeviceToHost(chip3.data(), gpu_data_chip3, chip3TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:269:  array<IndexType, 4> chip4TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:270:  Tensor<DataType, 4, DataLayout,IndexType> chip4(chip4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:271:  const size_t chip4TensorBuffSize =chip4.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:272:  DataType* gpu_data_chip4  = static_cast<DataType*>(sycl_device.allocate(chip4TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:273:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip4(gpu_data_chip4, chip4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:276:  sycl_device.memcpyDeviceToHost(chip4.data(), gpu_data_chip4, chip4TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:294:  array<IndexType, 4> chip5TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:295:  Tensor<DataType, 4, DataLayout,IndexType> chip5(chip5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:296:  const size_t chip5TensorBuffSize =chip5.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:297:  DataType* gpu_data_chip5  = static_cast<DataType*>(sycl_device.allocate(chip5TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:298:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip5(gpu_data_chip5, chip5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:301:  sycl_device.memcpyDeviceToHost(chip5.data(), gpu_data_chip5, chip5TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:335:  array<IndexType, 4> chip1TensorRange = {{sizeDim2, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:337:  Tensor<DataType, 5, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:339:  Tensor<DataType, 4, DataLayout,IndexType> chip1(chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:340:  Tensor<DataType, 4, DataLayout,IndexType> tensor1(chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:345:  const size_t chip1TensorBuffSize =chip1.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:347:  DataType* gpu_data_chip1  = static_cast<DataType*>(sycl_device.allocate(chip1TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:348:  DataType* gpu_data_tensor1  = static_cast<DataType*>(sycl_device.allocate(chip1TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:350:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:351:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_chip1(gpu_data_chip1, chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:352:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_tensor1(gpu_data_tensor1, chip1TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:356:  sycl_device.memcpyHostToDevice(gpu_data_tensor1, tensor1.data(), chip1TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:358:  sycl_device.memcpyDeviceToHost(chip1.data(), gpu_data_chip1, chip1TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:371:  array<IndexType, 3> chip2TensorRange = {{sizeDim2, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:372:  Tensor<DataType, 3, DataLayout,IndexType> tensor2(chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:373:  Tensor<DataType, 3, DataLayout,IndexType> chip2(chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:375:  const size_t chip2TensorBuffSize =tensor2.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:376:  DataType* gpu_data_tensor2  = static_cast<DataType*>(sycl_device.allocate(chip2TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:377:  DataType* gpu_data_chip2  = static_cast<DataType*>(sycl_device.allocate(chip2TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:378:  TensorMap<Tensor<DataType, 3, DataLayout,IndexType>> gpu_tensor2(gpu_data_tensor2, chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:379:  TensorMap<Tensor<DataType, 3, DataLayout,IndexType>> gpu_chip2(gpu_data_chip2, chip2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:381:  sycl_device.memcpyHostToDevice(gpu_data_tensor2, tensor2.data(), chip2TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:383:  sycl_device.memcpyDeviceToHost(chip2.data(), gpu_data_chip2, chip2TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:411:  array<IndexType, 4> input2TensorRange = {{sizeDim2, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:413:  Tensor<DataType, 5, DataLayout,IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:414:  Tensor<DataType, 5, DataLayout,IndexType> input1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:415:  Tensor<DataType, 4, DataLayout,IndexType> input2(input2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:421:  const size_t input2TensorBuffSize =input2.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:424:  DataType* gpu_data_input2  = static_cast<DataType*>(sycl_device.allocate(input2TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:426:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_tensor(gpu_data_tensor, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:427:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_input1(gpu_data_input1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:428:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_input2(gpu_data_input2, input2TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:432:  sycl_device.memcpyHostToDevice(gpu_data_input2, input2.data(), input2TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:453:  array<IndexType, 4> input3TensorRange = {{sizeDim1, sizeDim3, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:454:  Tensor<DataType, 4, DataLayout,IndexType> input3(input3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:457:  const size_t input3TensorBuffSize =input3.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:458:  DataType* gpu_data_input3  = static_cast<DataType*>(sycl_device.allocate(input3TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:459:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_input3(gpu_data_input3, input3TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:461:  sycl_device.memcpyHostToDevice(gpu_data_input3, input3.data(), input3TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:482:  array<IndexType, 4> input4TensorRange = {{sizeDim1, sizeDim2, sizeDim4, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:483:  Tensor<DataType, 4, DataLayout,IndexType> input4(input4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:486:  const size_t input4TensorBuffSize =input4.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:487:  DataType* gpu_data_input4  = static_cast<DataType*>(sycl_device.allocate(input4TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:488:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_input4(gpu_data_input4, input4TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:490:  sycl_device.memcpyHostToDevice(gpu_data_input4, input4.data(), input4TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:511:  array<IndexType, 4> input5TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim5}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:512:  Tensor<DataType, 4, DataLayout,IndexType> input5(input5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:515:  const size_t input5TensorBuffSize =input5.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:516:  DataType* gpu_data_input5  = static_cast<DataType*>(sycl_device.allocate(input5TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:517:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_input5(gpu_data_input5, input5TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:519:  sycl_device.memcpyHostToDevice(gpu_data_input5, input5.data(), input5TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:539:  array<IndexType, 4> input6TensorRange = {{sizeDim1, sizeDim2, sizeDim3, sizeDim4}};
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:540:  Tensor<DataType, 4, DataLayout,IndexType> input6(input6TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:543:  const size_t input6TensorBuffSize =input6.size()*sizeof(DataType);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:544:  DataType* gpu_data_input6  = static_cast<DataType*>(sycl_device.allocate(input6TensorBuffSize));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:545:  TensorMap<Tensor<DataType, 4, DataLayout,IndexType>> gpu_input6(gpu_data_input6, input6TensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:547:  sycl_device.memcpyHostToDevice(gpu_data_input6, input6.data(), input6TensorBuffSize);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:569:  Tensor<DataType, 5, DataLayout,IndexType> input7(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_chipping_sycl.cpp:573:  TensorMap<Tensor<DataType, 5, DataLayout,IndexType>> gpu_input7(gpu_data_input7, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:24:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:28:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:29:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:34:  typename Tensor<DataType, 5 ,DataLayout, IndexType>::Dimensions dim1(2,3,1,7,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:35:  typename Tensor<DataType, 3 ,DataLayout, IndexType>::Dimensions dim2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:36:  typename Tensor<DataType, 2 ,DataLayout, IndexType>::Dimensions dim3(6,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:37:  typename Tensor<DataType, 2 ,DataLayout, IndexType>::Dimensions dim4(2,21);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:39:  Tensor<DataType, 5, DataLayout, IndexType> tensor1(dim1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:40:  Tensor<DataType, 3, DataLayout, IndexType> tensor2(dim2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:41:  Tensor<DataType, 2, DataLayout, IndexType> tensor3(dim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:42:  Tensor<DataType, 2, DataLayout, IndexType> tensor4(dim4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:51:  TensorMap<Tensor<DataType, 5,DataLayout, IndexType>> gpu1(gpu_data1, dim1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:52:  TensorMap<Tensor<DataType, 3,DataLayout, IndexType>> gpu2(gpu_data2, dim2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:53:  TensorMap<Tensor<DataType, 2,DataLayout, IndexType>> gpu3(gpu_data3, dim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:54:  TensorMap<Tensor<DataType, 2,DataLayout, IndexType>> gpu4(gpu_data4, dim4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:92:  typename Tensor<DataType, 3, DataLayout, IndexType>::Dimensions dim1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:93:  typename Tensor<DataType, 2, DataLayout, IndexType>::Dimensions dim2(6,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:94:  typename Tensor<DataType, 5, DataLayout, IndexType>::Dimensions dim3(2,3,1,7,1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:95:  Tensor<DataType, 3, DataLayout, IndexType> tensor(dim1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:96:  Tensor<DataType, 2, DataLayout, IndexType> tensor2d(dim2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:97:  Tensor<DataType, 5, DataLayout, IndexType> tensor5d(dim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:105:  TensorMap< Tensor<DataType, 3, DataLayout, IndexType> > gpu1(gpu_data1, dim1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:106:  TensorMap< Tensor<DataType, 2, DataLayout, IndexType> > gpu2(gpu_data2, dim2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:107:  TensorMap< Tensor<DataType, 5, DataLayout, IndexType> > gpu3(gpu_data3, dim3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:146:  Tensor<DataType, 5,DataLayout, IndexType> tensor(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:149:  Tensor<DataType, 5,DataLayout, IndexType> slice1(slice1_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:153:  TensorMap<Tensor<DataType, 5,DataLayout, IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:154:  TensorMap<Tensor<DataType, 5,DataLayout, IndexType>> gpu2(gpu_data2, slice1_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:164:  Tensor<DataType, 5,DataLayout, IndexType> slice2(slice2_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:166:  TensorMap<Tensor<DataType, 5,DataLayout, IndexType>> gpu3(gpu_data3, slice2_range);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:186:  typedef Tensor<DataType, 2, DataLayout, IndexType> Tensor2f;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:191:  Tensor<DataType, 2, DataLayout, IndexType> tensor(tensorRange),tensor2(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:195:  Tensor2f slice(sliceRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:204:  TensorMap<Tensor<DataType, 2,DataLayout,IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:205:  TensorMap<Tensor<DataType, 2,DataLayout,IndexType>> gpu2(gpu_data2, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_morphing_sycl.cpp:206:  TensorMap<Tensor<DataType, 2,DataLayout,IndexType>> gpu3(gpu_data3, sliceRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:24:typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:33:  Tensor<float, 2, DataLayout> t_left(m_size, k_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:34:  Tensor<float, 2, DataLayout> t_right(k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:35:  Tensor<float, 2, DataLayout> t_result(m_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:36:  Tensor<float, 2, DataLayout> t_result_gpu(m_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:60:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:62:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:64:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:97:  Tensor<float, 2, DataLayout> t_left(m_size, k_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:98:  Tensor<float, 2, DataLayout> t_right(k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:99:  Tensor<float, 0, DataLayout> t_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:100:  Tensor<float, 0, DataLayout> t_result_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:124:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:126:  Eigen::TensorMap<Eigen::Tensor<float, 2, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_cuda.cu:128:  Eigen::TensorMap<Eigen::Tensor<float, 0, DataLayout> >
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:24:template<typename TensorType>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:26:  DSizes<DenseIndex, 2> dimensions(const TensorType& input) const {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:34:  void eval(const TensorType& input, Output& output, const Device& device) const
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:55:  Eigen::Tensor<DataType, 2, DataLayout, IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:56:  Eigen::Tensor<DataType, 2, DataLayout, IndexType> out(tensorResultRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:61:  typedef Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > TensorType;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:62:  TensorType gpu_in1(gpu_in1_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:63:  TensorType gpu_out(gpu_out_data, tensorResultRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:67:  gpu_out.device(sycl_device) = gpu_in1.customOp(InsertZeros<TensorType>());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:85:template<typename TensorType>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:87:  DSizes<DenseIndex, 3> dimensions(const TensorType& input1, const TensorType& input2) const {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:96:  void eval(const TensorType& input1, const TensorType& input2,
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:99:    typedef typename TensorType::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:116:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> in1(tensorRange1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:117:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> in2(tensorRange2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:118:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> out(tensorResultRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:124:  typedef Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType> > TensorType;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:125:  TensorType gpu_in1(gpu_in1_data, tensorRange1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:126:  TensorType gpu_in2(gpu_in2_data, tensorRange2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:127:  TensorType gpu_out(gpu_out_data, tensorResultRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:135:  gpu_out.device(sycl_device) = gpu_in1.customOp(gpu_in2, BatchMatMul<TensorType>());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:139:    typedef typename Eigen::Tensor<DataType, 3, DataLayout, IndexType>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:142:    Eigen::Tensor<DataType, 2, DataLayout, IndexType> reference = in1.template chip<2>(i).contract(in2.template chip<2>(i), dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_custom_op_sycl.cpp:143:    TensorRef<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > val = out.template chip<2>(i);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:15:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:20:  TensorMap<Tensor<std::string, 2>> mat1(data1, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:22:  const TensorMap<Tensor<const std::string, 2>> mat2(data2, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:33:  Tensor<std::string, 2> rslt1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:35:  Tensor<std::string, 2> rslt2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:38:  Tensor<std::string, 2> rslt3 = mat1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:39:  Tensor<std::string, 2> rslt4 = mat2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:41:  Tensor<std::string, 2> rslt5(mat1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:42:  Tensor<std::string, 2> rslt6(mat2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:59:  Tensor<std::string, 2> t1(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:60:  Tensor<std::string, 2> t2(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:73:  Tensor<std::string, 2> result = t1.concatenate(t2, 1);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:88:  Tensor<std::string, 2> data(2, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:101:  Tensor<std::string, 2> t1 = data.slice(first_half, half_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:102:  Tensor<std::string, 2> t2 = data.slice(second_half, half_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:115:  Tensor<std::string, 1> data1(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:116:  Tensor<std::string, 1> data2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:124:  Tensor<std::string, 1> sum = data1 + data2;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_of_strings.cpp:136:  Tensor<std::string, 2> a(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:24:using Eigen::internal::TensorUInt128;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:27:void VERIFY_EQUAL(TensorUInt128<uint64_t, uint64_t> actual, uint128_t expected) {
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:44:      TensorUInt128<uint64_t, uint64_t> i(i1, i2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:48:          TensorUInt128<uint64_t, uint64_t> j(j1, j2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:50:          TensorUInt128<uint64_t, uint64_t> actual = i + j;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:63:      TensorUInt128<uint64_t, uint64_t> i(i1, i2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:67:          TensorUInt128<uint64_t, uint64_t> j(j1, j2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:69:          TensorUInt128<uint64_t, uint64_t> actual = i - j;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:82:      TensorUInt128<uint64_t, uint64_t> i(i1, i2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:86:          TensorUInt128<uint64_t, uint64_t> j(j1, j2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:88:          TensorUInt128<uint64_t, uint64_t> actual = i * j;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:101:      TensorUInt128<uint64_t, uint64_t> i(i1, i2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:105:          TensorUInt128<uint64_t, uint64_t> j(j1, j2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:107:          TensorUInt128<uint64_t, uint64_t> actual = i / j;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:119:    TensorUInt128<static_val<0>, uint64_t> i(0, i2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:122:      TensorUInt128<static_val<0>, uint64_t> j(0, j2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_uint128.cpp:138:      TensorUInt128<uint64_t, uint64_t> result = (TensorUInt128<uint64_t, static_val<0> >(shift, 0) / TensorUInt128<static_val<0>, uint64_t>(divider) - TensorUInt128<static_val<1>, static_val<0> >(1, 0) + TensorUInt128<static_val<0>, static_val<1> >(1));
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:20:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:25:  Tensor<float, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:36:  Eigen::TensorMap<Eigen::Tensor<float, 2> > gpu_out(d_out, 72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:50:  Tensor<float, 2> out(72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:61:  Eigen::TensorMap<Eigen::Tensor<float, 2> > gpu_out(d_out, 72,97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_random_cuda.cu:72:  Tensor<std::complex<float>, 1> vec(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:23:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:27:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:28:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:36:  Tensor<DataType, 3, DataLayout, IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:37:  Tensor<DataType, 3, DataLayout, IndexType> out1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:38:  Tensor<DataType, 3, DataLayout, IndexType> out2(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:39:  Tensor<DataType, 3, DataLayout, IndexType> out3(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:46:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu1(gpu_data1, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:47:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu2(gpu_data2, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:72:  Tensor<DataType, 1, DataLayout, IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:73:  Tensor<DataType, 1, DataLayout, IndexType> in2(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:74:  Tensor<DataType, 1, DataLayout, IndexType> out(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:81:  TensorMap<Tensor<DataType, 1, DataLayout, IndexType>> gpu1(gpu_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:103:  Tensor<DataType, 3,DataLayout, IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:104:  Tensor<DataType, 3,DataLayout, IndexType> in2(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:105:  Tensor<DataType, 3,DataLayout, IndexType> in3(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:106:  Tensor<DataType, 3,DataLayout, IndexType> out(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:116:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu_in1(gpu_in1_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:117:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu_in2(gpu_in2_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:118:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu_in3(gpu_in3_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:119:  TensorMap<Tensor<DataType, 3, DataLayout, IndexType>> gpu_out(gpu_out_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:236:    Tensor<Scalar1, 1, DataLayout, IndexType> in(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:237:    Tensor<Scalar2, 1, DataLayout, IndexType> out(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:238:    Tensor<Scalar2, 1, DataLayout, IndexType> out_host(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:245:    TensorMap<Tensor<Scalar1, 1, DataLayout, IndexType>> gpu_in(gpu_in_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_sycl.cpp:246:    TensorMap<Tensor<Scalar2, 1, DataLayout, IndexType>> gpu_out(gpu_out_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:22:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:26:  Tensor<Tuple<DenseIndex, float>, 4, DataLayout> index_tuples(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:39:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:43:  Tensor<Tuple<DenseIndex, float>, 4, DataLayout> index_tuples(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:57:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:61:  Tensor<Tuple<DenseIndex, float>, 4, DataLayout> index_tuples(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:64:  Tensor<Tuple<DenseIndex, float>, 0, DataLayout> reduced;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:69:  Tensor<float, 0, DataLayout> maxi = tensor.maximum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:75:  Tensor<Tuple<DenseIndex, float>, 1, DataLayout> reduced_by_dims(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:79:  Tensor<float, 1, DataLayout> max_by_dims = tensor.maximum(reduce_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:89:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:93:  Tensor<Tuple<DenseIndex, float>, 4, DataLayout> index_tuples(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:96:  Tensor<Tuple<DenseIndex, float>, 0, DataLayout> reduced;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:101:  Tensor<float, 0, DataLayout> mini = tensor.minimum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:107:  Tensor<Tuple<DenseIndex, float>, 1, DataLayout> reduced_by_dims(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:111:  Tensor<float, 1, DataLayout> min_by_dims = tensor.minimum(reduce_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:121:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:126:  Tensor<DenseIndex, 0, DataLayout> tensor_argmax;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:142:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:147:  Tensor<DenseIndex, 0, DataLayout> tensor_argmin;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:163:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:170:    Tensor<DenseIndex, 3, DataLayout> tensor_argmax;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:221:  Tensor<float, 4, DataLayout> tensor(2,3,5,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_argmax.cpp:228:    Tensor<DenseIndex, 3, DataLayout> tensor_argmin;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:15:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:17:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:22:  Tensor<float, 3> in1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:23:  Tensor<float, 3> in2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:24:  Tensor<float, 3> out(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:45:  Tensor<float, 3> in1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:46:  Tensor<float, 3> in2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:47:  Tensor<float, 3> out(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:69:  Tensor<float, 4, DataLayout> t_left(30, 50, 37, 31);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:70:  Tensor<float, 5, DataLayout> t_right(37, 31, 70, 2, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:71:  Tensor<float, 5, DataLayout> t_result(30, 50, 70, 2, 10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:77:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:109:  Tensor<float, 2, DataLayout> t_left(32, 500);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:110:  Tensor<float, 2, DataLayout> t_right(32, 28*28);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:111:  Tensor<float, 2, DataLayout> t_result(500, 28*28);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:118:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:197:  Tensor<float, 3, DataLayout> left(internal::random<int>(1, 80),
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:201:  Tensor<float, 4, DataLayout> right(internal::random<int>(1, 25),
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:213:  typedef Tensor<float, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:219:  Tensor<float, 5, DataLayout> st_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:222:  Tensor<float, 5, DataLayout> tp_result(st_result.dimensions());
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:241:  Tensor<float, 2, DataLayout> left(contract_size1,
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:243:  Tensor<float, 2, DataLayout> right(contract_size1,
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:252:  typedef Tensor<float, 2>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:258:  Tensor<float, 0, DataLayout> st_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:261:  Tensor<float, 0, DataLayout> tp_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:280:  Tensor<float, 2, DataLayout> t1(num_rows, num_cols);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:283:  Tensor<float, 0, DataLayout> full_redux;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:286:  Tensor<float, 0, DataLayout> full_redux_tp;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:303:    Tensor<float, 1> t1(size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:318:  Tensor<float, 1> t(1 << 20);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:325:  Tensor<float, 4, DataLayout> tensor(17,5,7,11);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_thread_pool.cpp:332:  Tensor<float, 4, DataLayout> shuffle(7,5,11,17);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:13:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:15:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:20:    Tensor<float, 0, DataLayout> tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:24:    Tensor<float, 0, DataLayout> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:29:    Tensor<float, 1, DataLayout> tensor(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:33:    Tensor<float, 1, DataLayout> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:41:    Tensor<float, 2, DataLayout> tensor(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:45:    Tensor<float, 2, DataLayout> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:58:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:64:  Tensor<float, 2, DataLayout> result = tensor.sum(reduction_axis2);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:80:    Tensor<float, 0, DataLayout> sum1 = tensor.sum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:88:    Tensor<float, 0, DataLayout> sum2 = tensor.sum(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:112:    Tensor<float, 0, DataLayout> prod1 = tensor.prod();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:120:    Tensor<float, 0, DataLayout> prod2 = tensor.prod(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:144:    Tensor<float, 0, DataLayout> max1 = tensor.maximum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:152:    Tensor<float, 0, DataLayout> max2 = tensor.maximum(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:176:    Tensor<float, 0, DataLayout> min1 = tensor.minimum();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:184:    Tensor<float, 0, DataLayout> min2 = tensor.minimum(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:210:    Tensor<float, 0, DataLayout> mean1 = tensor.mean();
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:218:    Tensor<float, 0, DataLayout> mean2 = tensor.mean(reduction_axis4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:225:    Tensor<int, 1> ints(10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:228:    TensorFixedSize<bool, Sizes<> > all;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:234:    TensorFixedSize<bool, Sizes<> > any;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:245:  Tensor<float, 4, DataLayout> tensor(2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:251:  Tensor<float, 2, DataLayout> result(2, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:271:  Tensor<float, 2, DataLayout> tensor(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:277:  Tensor<float, 0, DataLayout> result = tensor.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:313:  Tensor<float, 2, DataLayout> tensor(5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:319:  Tensor<float, 1, DataLayout> result = tensor.reduce(reduction_axis, reducer);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:334:  TensorMap<Tensor<int, 4, DataLayout> > tensor_map(inputs, 2, 3, 5, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:335:  TensorMap<Tensor<const int, 4, DataLayout> > tensor_map_const(inputs, 2, 3, 5,
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:337:  const TensorMap<Tensor<const int, 4, DataLayout> > tensor_map_const_const(
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:345:  Tensor<int, 2, DataLayout> result = tensor_map.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:346:  Tensor<int, 2, DataLayout> result2 = tensor_map_const.sum(reduction_axis);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:347:  Tensor<int, 2, DataLayout> result3 =
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:367:  Tensor<float, 4, DataLayout> in(72, 53, 97, 113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:368:  Tensor<float, 2, DataLayout> out(72, 97);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:396:  Tensor<float, 4, DataLayout> in(72, 53, 97, 113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:397:  Tensor<float, 2, DataLayout> out(97, 113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:427:  Tensor<float, 4, DataLayout> in(72, 53, 97, 113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:428:  Tensor<float, 2, DataLayout> out(72, 53);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:458:  Tensor<float, 4, DataLayout> in(72, 53, 97, 113);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_reduction.cpp:459:  Tensor<float, 2, DataLayout> out(72, 53);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:25:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:29:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:30:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:34:  typedef typename Tensor<DataType, 1, DataLayout, IndexType>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:40:  Tensor<DataType, 2, DataLayout, IndexType> t_left(m_size, k_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:41:  Tensor<DataType, 2, DataLayout, IndexType> t_right(k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:42:  Tensor<DataType, 2, DataLayout, IndexType> t_result(m_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:43:  Tensor<DataType, 2, DataLayout, IndexType> t_result_gpu(m_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:61:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_left(d_t_left, left_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:62:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_right(d_t_right, right_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:63:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_result(d_t_result, result_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:92:  typedef typename Tensor<DataType, 1, DataLayout, IndexType>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:100:  Tensor<DataType, 2, DataLayout, IndexType> t_left(left_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:101:  Tensor<DataType, 2, DataLayout, IndexType> t_right(right_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:102:  Tensor<DataType, 2, DataLayout, IndexType> t_result_gpu(res_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:103:  Tensor<DataType, 2, DataLayout, IndexType> t_result(res_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:125:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_left(d_t_left, left_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:126:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_right(d_t_right, right_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:127:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_result(d_t_result, res_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:162:  typedef typename Tensor<DataType, 1, DataLayout, IndexType>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:164:  Tensor<DataType, 2, DataLayout, IndexType> t_left(m_size, k_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:165:  Tensor<DataType, 2, DataLayout, IndexType> t_right(k_size, n_size);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:166:  Tensor<DataType, 0, DataLayout, IndexType> t_result;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:167:  Tensor<DataType, 0, DataLayout, IndexType> t_result_gpu;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:183:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_left(d_t_left, left_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:184:  Eigen::TensorMap<Eigen::Tensor<DataType, 2, DataLayout, IndexType> > gpu_t_right(d_t_right, right_dims);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_contract_sycl.cpp:185:  Eigen::TensorMap<Eigen::Tensor<DataType, 0, DataLayout, IndexType> > gpu_t_result(d_t_result);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:13:#include <Eigen/CXX11/TensorSymmetry>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:18:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:661:  Tensor<int, 3> epsilon(3,3,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:678:  Tensor<int, 4> t(10,10,10,10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:707:  Tensor<int, 4> t(10,10,10,10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:746:  Tensor<int, 4> t(10,10,10,10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_symmetry.cpp:774:  Tensor<int, 4> t(10,10,10,10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:12:#include <Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:14:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:19:  Tensor<int, 1> vec1(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:20:  Tensor<int, 1, RowMajor> vec2(6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:32:  TensorMap<Tensor<int, 1> > vec3(col_major, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:33:  TensorMap<Tensor<int, 1, RowMajor> > vec4(row_major, 6);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:74:  Tensor<int, 2> mat1(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:75:  Tensor<int, 2, RowMajor> mat2(2,3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:95:  TensorMap<Tensor<int, 2> > mat3(row_major, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:96:  TensorMap<Tensor<int, 2, RowMajor> > mat4(col_major, 2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:137:  Tensor<int, 3> mat1(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:138:  Tensor<int, 3, RowMajor> mat2(2,3,7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:155:  TensorMap<Tensor<int, 3> > mat3(col_major, 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:156:  TensorMap<Tensor<int, 3, RowMajor> > mat4(row_major, 2, 3, 7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:191:  Tensor<int, 1> orig_tensor(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:192:  Tensor<int, 1> dest_tensor(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:204:  TensorFixedSize<int, Sizes<5> > orig_array;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:205:  TensorFixedSize<int, Sizes<5> > dest_array;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:219:  TensorMap<Tensor<int, 1> > orig_map(orig, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:220:  TensorMap<Tensor<int, 1> > dest_map(dest, 5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:233:  Tensor<int, 1> tensor1;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:234:  Tensor<int, 1> tensor2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:235:  Tensor<int, 1> tensor3(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:236:  Tensor<int, 1> tensor4(7);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:238:  Tensor<int, 1> new_tensor(5);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:258:  Tensor<int, 1> start_tensor(10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:259:  Tensor<int, 1> offset_tensor(10);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:263:  Tensor<int, 1> tensor = start_tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:290:  Tensor<int, 1> a(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:303:  Tensor<int, 1> a2(3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:312:  Tensor<int, 2> b(2, 3);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_assign.cpp:330:  Eigen::Tensor<int, 3> c(3, 2, 4);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:21:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:23:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:31:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> in1(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:32:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> in2(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:33:  Eigen::Tensor<DataType, 3, DataLayout, IndexType> out(tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:42:  // creating TensorMap from tensor
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:43:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_in1(gpu_in1_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:44:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_in2(gpu_in2_data, tensorRange);
build/third_party/eigen3/src/eigen3/unsupported/test/cxx11_tensor_forced_eval_sycl.cpp:45:  Eigen::TensorMap<Eigen::Tensor<DataType, 3, DataLayout, IndexType>> gpu_out(gpu_out_data, tensorRange);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:4:typedef int TensorIndex;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:7:#include "unsupported/Eigen/CXX11/Tensor"
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:13:using Eigen::Tensor;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:14:using Eigen::TensorMap;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:53:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:61:    const TensorMap<Tensor<int, 2, 0, TensorIndex>, Eigen::Aligned> A((int*)a_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:62:    TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(b_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:78:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:81:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:92:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:95:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:96:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:97:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:99:    const Eigen::DSizes<TensorIndex, 2> quarter_sizes(m_/2, m_/2);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:100:    const Eigen::DSizes<TensorIndex, 2> first_quadrant(0, 0);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:101:    const Eigen::DSizes<TensorIndex, 2> second_quadrant(0, m_/2);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:102:    const Eigen::DSizes<TensorIndex, 2> third_quadrant(m_/2, 0);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:103:    const Eigen::DSizes<TensorIndex, 2> fourth_quadrant(m_/2, m_/2);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:133:    Eigen::array<TensorIndex, 2> input_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:136:    const TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(b_, input_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:137:    Eigen::array<TensorIndex, 1> output_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:139:    TensorMap<Tensor<T, 1, 0, TensorIndex>, Eigen::Aligned> C(c_, output_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:154:    Eigen::array<TensorIndex, 2> input_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:157:    const TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(b_, input_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:158:    Eigen::array<TensorIndex, 1> output_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:160:    TensorMap<Tensor<T, 1, 0, TensorIndex>, Eigen::Aligned> C(c_, output_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:176:    Eigen::array<TensorIndex, 2> size_a;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:179:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, size_a);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:180:    Eigen::array<TensorIndex, 2> size_b;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:183:    TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, size_b);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:203:    Eigen::array<TensorIndex, 2> size_a;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:206:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, size_a);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:207:    Eigen::array<TensorIndex, 2> size_b;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:210:    TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, size_b);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:216:    Eigen::array<Eigen::IndexPair<TensorIndex>, 2> paddings;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:217:    paddings[0] = Eigen::IndexPair<TensorIndex>(0, 0);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:218:    paddings[1] = Eigen::IndexPair<TensorIndex>(2, 1);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:235:    Eigen::array<TensorIndex, 2> size_a;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:238:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, size_a);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:239:    Eigen::array<TensorIndex, 2> size_b;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:242:    TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, size_b);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:245:    Eigen::array<TensorIndex, 2> strides;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:268:    Eigen::array<TensorIndex, 2> size_a;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:271:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, size_a);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:272:    Eigen::array<TensorIndex, 2> size_c;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:275:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, size_c);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:303:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:306:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:307:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:308:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:325:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:328:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:329:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:330:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:348:    Eigen::array<TensorIndex, 2> sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:351:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:352:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:353:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:370:    Eigen::array<TensorIndex, 2> input_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:373:    const TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(b_, input_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:374:    Eigen::array<TensorIndex, 1> output_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:376:    TensorMap<Tensor<T, 1, 0, TensorIndex>, Eigen::Aligned> C(c_, output_size);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:379:    Eigen::array<TensorIndex, 1> sum_along_dim;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:402:    Eigen::array<TensorIndex, 2> input_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:405:    const TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:407:    Eigen::array<TensorIndex, 1> output_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:409:    TensorMap<Tensor<T, 1, 0, TensorIndex>, Eigen::Aligned> C(
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:413:    Eigen::array<TensorIndex, 1> sum_along_dim;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:436:    Eigen::array<TensorIndex, 2> input_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:439:    const TensorMap<Tensor<T, 2, 0, TensorIndex>, Eigen::Aligned> B(
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:441:    Eigen::array<TensorIndex, 0> output_size;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:442:    TensorMap<Tensor<T, 0, 0, TensorIndex>, Eigen::Aligned> C(
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:460:    Eigen::array<TensorIndex, 2> sizeA;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:463:    Eigen::array<TensorIndex, 2> sizeB;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:466:    Eigen::array<TensorIndex, 2> sizeC;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:470:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, sizeA);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:471:    const TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, sizeB);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:472:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, sizeC);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:474:    typedef typename Tensor<T, 2>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:492:    Eigen::array<TensorIndex, 2> input_sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:495:    TensorMap<Tensor<T, 2>, Eigen::Aligned> A(a_, input_sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:496:    Eigen::array<TensorIndex, 2> kernel_sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:499:    TensorMap<Tensor<T, 2>, Eigen::Aligned> B(b_, kernel_sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:500:    Eigen::array<TensorIndex, 2> result_sizes;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:503:    TensorMap<Tensor<T, 2>, Eigen::Aligned> C(c_, result_sizes);
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:504:    Eigen::array<TensorIndex, 2> dims;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:553:  TensorIndex m_;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:554:  TensorIndex k_;
build/third_party/eigen3/src/eigen3/bench/tensors/tensor_benchmarks.h:555:  TensorIndex n_;
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/CMakeLists.txt:8:  find_package(Tensor)
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:12:#include <unsupported/Eigen/CXX11/Tensor>
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:23:  typedef typename Eigen::Tensor<real,2>::Index Index;
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:28:  typedef Eigen::Tensor<real,2> gene_matrix;
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:29:  typedef Eigen::Tensor<real,1> gene_vector;
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:77:    typedef typename Eigen::Tensor<real_type, 1>::DimensionPair DimPair;
build/third_party/eigen3/src/eigen3/bench/btl/libs/tensors/tensor_interface.hh:83:    typedef typename Eigen::Tensor<real_type, 1>::DimensionPair DimPair;
匹配到二进制文件 build/mace/proto/libproto.a
匹配到二进制文件 build/mace/proto/CMakeFiles/proto.dir/mace.pb.cc.o
build/mace/proto/mace.pb.h:51:class ConstTensor;
build/mace/proto/mace.pb.h:52:class ConstTensorDefaultTypeInternal;
build/mace/proto/mace.pb.h:53:extern ConstTensorDefaultTypeInternal _ConstTensor_default_instance_;
build/mace/proto/mace.pb.h:76:template<> ::mace::ConstTensor* Arena::CreateMaybeMessage<::mace::ConstTensor>(Arena*);
build/mace/proto/mace.pb.h:112:class ConstTensor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.ConstTensor) */ {
build/mace/proto/mace.pb.h:114:  ConstTensor();
build/mace/proto/mace.pb.h:115:  virtual ~ConstTensor();
build/mace/proto/mace.pb.h:117:  ConstTensor(const ConstTensor& from);
build/mace/proto/mace.pb.h:119:  inline ConstTensor& operator=(const ConstTensor& from) {
build/mace/proto/mace.pb.h:124:  ConstTensor(ConstTensor&& from) noexcept
build/mace/proto/mace.pb.h:125:    : ConstTensor() {
build/mace/proto/mace.pb.h:129:  inline ConstTensor& operator=(ConstTensor&& from) noexcept {
build/mace/proto/mace.pb.h:145:  static const ConstTensor& default_instance();
build/mace/proto/mace.pb.h:148:  static inline const ConstTensor* internal_default_instance() {
build/mace/proto/mace.pb.h:149:    return reinterpret_cast<const ConstTensor*>(
build/mace/proto/mace.pb.h:150:               &_ConstTensor_default_instance_);
build/mace/proto/mace.pb.h:155:  void Swap(ConstTensor* other);
build/mace/proto/mace.pb.h:156:  friend void swap(ConstTensor& a, ConstTensor& b) {
build/mace/proto/mace.pb.h:162:  inline ConstTensor* New() const final {
build/mace/proto/mace.pb.h:163:    return CreateMaybeMessage<ConstTensor>(NULL);
build/mace/proto/mace.pb.h:166:  ConstTensor* New(::google::protobuf::Arena* arena) const final {
build/mace/proto/mace.pb.h:167:    return CreateMaybeMessage<ConstTensor>(arena);
build/mace/proto/mace.pb.h:171:  void CopyFrom(const ConstTensor& from);
build/mace/proto/mace.pb.h:172:  void MergeFrom(const ConstTensor& from);
build/mace/proto/mace.pb.h:188:  void InternalSwap(ConstTensor* other);
build/mace/proto/mace.pb.h:318:  // @@protoc_insertion_point(class_scope:mace.ConstTensor)
build/mace/proto/mace.pb.h:1548:  // repeated .mace.ConstTensor tensors = 3;
build/mace/proto/mace.pb.h:1551:  static const int kTensorsFieldNumber = 3;
build/mace/proto/mace.pb.h:1552:  ::mace::ConstTensor* mutable_tensors(int index);
build/mace/proto/mace.pb.h:1553:  ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >*
build/mace/proto/mace.pb.h:1555:  const ::mace::ConstTensor& tensors(int index) const;
build/mace/proto/mace.pb.h:1556:  ::mace::ConstTensor* add_tensors();
build/mace/proto/mace.pb.h:1557:  const ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >&
build/mace/proto/mace.pb.h:1601:  ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor > tensors_;
build/mace/proto/mace.pb.h:1616:// ConstTensor
build/mace/proto/mace.pb.h:1619:inline int ConstTensor::dims_size() const {
build/mace/proto/mace.pb.h:1622:inline void ConstTensor::clear_dims() {
build/mace/proto/mace.pb.h:1625:inline ::google::protobuf::int64 ConstTensor::dims(int index) const {
build/mace/proto/mace.pb.h:1626:  // @@protoc_insertion_point(field_get:mace.ConstTensor.dims)
build/mace/proto/mace.pb.h:1629:inline void ConstTensor::set_dims(int index, ::google::protobuf::int64 value) {
build/mace/proto/mace.pb.h:1631:  // @@protoc_insertion_point(field_set:mace.ConstTensor.dims)
build/mace/proto/mace.pb.h:1633:inline void ConstTensor::add_dims(::google::protobuf::int64 value) {
build/mace/proto/mace.pb.h:1635:  // @@protoc_insertion_point(field_add:mace.ConstTensor.dims)
build/mace/proto/mace.pb.h:1638:ConstTensor::dims() const {
build/mace/proto/mace.pb.h:1639:  // @@protoc_insertion_point(field_list:mace.ConstTensor.dims)
build/mace/proto/mace.pb.h:1643:ConstTensor::mutable_dims() {
build/mace/proto/mace.pb.h:1644:  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.dims)
build/mace/proto/mace.pb.h:1649:inline bool ConstTensor::has_data_type() const {
build/mace/proto/mace.pb.h:1652:inline void ConstTensor::set_has_data_type() {
build/mace/proto/mace.pb.h:1655:inline void ConstTensor::clear_has_data_type() {
build/mace/proto/mace.pb.h:1658:inline void ConstTensor::clear_data_type() {
build/mace/proto/mace.pb.h:1662:inline ::mace::DataType ConstTensor::data_type() const {
build/mace/proto/mace.pb.h:1663:  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_type)
build/mace/proto/mace.pb.h:1666:inline void ConstTensor::set_data_type(::mace::DataType value) {
build/mace/proto/mace.pb.h:1670:  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_type)
build/mace/proto/mace.pb.h:1674:inline int ConstTensor::float_data_size() const {
build/mace/proto/mace.pb.h:1677:inline void ConstTensor::clear_float_data() {
build/mace/proto/mace.pb.h:1680:inline float ConstTensor::float_data(int index) const {
build/mace/proto/mace.pb.h:1681:  // @@protoc_insertion_point(field_get:mace.ConstTensor.float_data)
build/mace/proto/mace.pb.h:1684:inline void ConstTensor::set_float_data(int index, float value) {
build/mace/proto/mace.pb.h:1686:  // @@protoc_insertion_point(field_set:mace.ConstTensor.float_data)
build/mace/proto/mace.pb.h:1688:inline void ConstTensor::add_float_data(float value) {
build/mace/proto/mace.pb.h:1690:  // @@protoc_insertion_point(field_add:mace.ConstTensor.float_data)
build/mace/proto/mace.pb.h:1693:ConstTensor::float_data() const {
build/mace/proto/mace.pb.h:1694:  // @@protoc_insertion_point(field_list:mace.ConstTensor.float_data)
build/mace/proto/mace.pb.h:1698:ConstTensor::mutable_float_data() {
build/mace/proto/mace.pb.h:1699:  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.float_data)
build/mace/proto/mace.pb.h:1704:inline int ConstTensor::int32_data_size() const {
build/mace/proto/mace.pb.h:1707:inline void ConstTensor::clear_int32_data() {
build/mace/proto/mace.pb.h:1710:inline ::google::protobuf::int32 ConstTensor::int32_data(int index) const {
build/mace/proto/mace.pb.h:1711:  // @@protoc_insertion_point(field_get:mace.ConstTensor.int32_data)
build/mace/proto/mace.pb.h:1714:inline void ConstTensor::set_int32_data(int index, ::google::protobuf::int32 value) {
build/mace/proto/mace.pb.h:1716:  // @@protoc_insertion_point(field_set:mace.ConstTensor.int32_data)
build/mace/proto/mace.pb.h:1718:inline void ConstTensor::add_int32_data(::google::protobuf::int32 value) {
build/mace/proto/mace.pb.h:1720:  // @@protoc_insertion_point(field_add:mace.ConstTensor.int32_data)
build/mace/proto/mace.pb.h:1723:ConstTensor::int32_data() const {
build/mace/proto/mace.pb.h:1724:  // @@protoc_insertion_point(field_list:mace.ConstTensor.int32_data)
build/mace/proto/mace.pb.h:1728:ConstTensor::mutable_int32_data() {
build/mace/proto/mace.pb.h:1729:  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.int32_data)
build/mace/proto/mace.pb.h:1734:inline bool ConstTensor::has_name() const {
build/mace/proto/mace.pb.h:1737:inline void ConstTensor::set_has_name() {
build/mace/proto/mace.pb.h:1740:inline void ConstTensor::clear_has_name() {
build/mace/proto/mace.pb.h:1743:inline void ConstTensor::clear_name() {
build/mace/proto/mace.pb.h:1747:inline const ::std::string& ConstTensor::name() const {
build/mace/proto/mace.pb.h:1748:  // @@protoc_insertion_point(field_get:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1751:inline void ConstTensor::set_name(const ::std::string& value) {
build/mace/proto/mace.pb.h:1754:  // @@protoc_insertion_point(field_set:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1757:inline void ConstTensor::set_name(::std::string&& value) {
build/mace/proto/mace.pb.h:1761:  // @@protoc_insertion_point(field_set_rvalue:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1764:inline void ConstTensor::set_name(const char* value) {
build/mace/proto/mace.pb.h:1768:  // @@protoc_insertion_point(field_set_char:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1770:inline void ConstTensor::set_name(const char* value, size_t size) {
build/mace/proto/mace.pb.h:1774:  // @@protoc_insertion_point(field_set_pointer:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1776:inline ::std::string* ConstTensor::mutable_name() {
build/mace/proto/mace.pb.h:1778:  // @@protoc_insertion_point(field_mutable:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1781:inline ::std::string* ConstTensor::release_name() {
build/mace/proto/mace.pb.h:1782:  // @@protoc_insertion_point(field_release:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1789:inline void ConstTensor::set_allocated_name(::std::string* name) {
build/mace/proto/mace.pb.h:1796:  // @@protoc_insertion_point(field_set_allocated:mace.ConstTensor.name)
build/mace/proto/mace.pb.h:1800:inline bool ConstTensor::has_offset() const {
build/mace/proto/mace.pb.h:1803:inline void ConstTensor::set_has_offset() {
build/mace/proto/mace.pb.h:1806:inline void ConstTensor::clear_has_offset() {
build/mace/proto/mace.pb.h:1809:inline void ConstTensor::clear_offset() {
build/mace/proto/mace.pb.h:1813:inline ::google::protobuf::int64 ConstTensor::offset() const {
build/mace/proto/mace.pb.h:1814:  // @@protoc_insertion_point(field_get:mace.ConstTensor.offset)
build/mace/proto/mace.pb.h:1817:inline void ConstTensor::set_offset(::google::protobuf::int64 value) {
build/mace/proto/mace.pb.h:1820:  // @@protoc_insertion_point(field_set:mace.ConstTensor.offset)
build/mace/proto/mace.pb.h:1824:inline bool ConstTensor::has_data_size() const {
build/mace/proto/mace.pb.h:1827:inline void ConstTensor::set_has_data_size() {
build/mace/proto/mace.pb.h:1830:inline void ConstTensor::clear_has_data_size() {
build/mace/proto/mace.pb.h:1833:inline void ConstTensor::clear_data_size() {
build/mace/proto/mace.pb.h:1837:inline ::google::protobuf::int64 ConstTensor::data_size() const {
build/mace/proto/mace.pb.h:1838:  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_size)
build/mace/proto/mace.pb.h:1841:inline void ConstTensor::set_data_size(::google::protobuf::int64 value) {
build/mace/proto/mace.pb.h:1844:  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_size)
build/mace/proto/mace.pb.h:1848:inline bool ConstTensor::has_scale() const {
build/mace/proto/mace.pb.h:1851:inline void ConstTensor::set_has_scale() {
build/mace/proto/mace.pb.h:1854:inline void ConstTensor::clear_has_scale() {
build/mace/proto/mace.pb.h:1857:inline void ConstTensor::clear_scale() {
build/mace/proto/mace.pb.h:1861:inline float ConstTensor::scale() const {
build/mace/proto/mace.pb.h:1862:  // @@protoc_insertion_point(field_get:mace.ConstTensor.scale)
build/mace/proto/mace.pb.h:1865:inline void ConstTensor::set_scale(float value) {
build/mace/proto/mace.pb.h:1868:  // @@protoc_insertion_point(field_set:mace.ConstTensor.scale)
build/mace/proto/mace.pb.h:1872:inline bool ConstTensor::has_zero_point() const {
build/mace/proto/mace.pb.h:1875:inline void ConstTensor::set_has_zero_point() {
build/mace/proto/mace.pb.h:1878:inline void ConstTensor::clear_has_zero_point() {
build/mace/proto/mace.pb.h:1881:inline void ConstTensor::clear_zero_point() {
build/mace/proto/mace.pb.h:1885:inline ::google::protobuf::int32 ConstTensor::zero_point() const {
build/mace/proto/mace.pb.h:1886:  // @@protoc_insertion_point(field_get:mace.ConstTensor.zero_point)
build/mace/proto/mace.pb.h:1889:inline void ConstTensor::set_zero_point(::google::protobuf::int32 value) {
build/mace/proto/mace.pb.h:1892:  // @@protoc_insertion_point(field_set:mace.ConstTensor.zero_point)
build/mace/proto/mace.pb.h:1896:inline bool ConstTensor::has_minval() const {
build/mace/proto/mace.pb.h:1899:inline void ConstTensor::set_has_minval() {
build/mace/proto/mace.pb.h:1902:inline void ConstTensor::clear_has_minval() {
build/mace/proto/mace.pb.h:1905:inline void ConstTensor::clear_minval() {
build/mace/proto/mace.pb.h:1909:inline float ConstTensor::minval() const {
build/mace/proto/mace.pb.h:1910:  // @@protoc_insertion_point(field_get:mace.ConstTensor.minval)
build/mace/proto/mace.pb.h:1913:inline void ConstTensor::set_minval(float value) {
build/mace/proto/mace.pb.h:1916:  // @@protoc_insertion_point(field_set:mace.ConstTensor.minval)
build/mace/proto/mace.pb.h:1920:inline bool ConstTensor::has_maxval() const {
build/mace/proto/mace.pb.h:1923:inline void ConstTensor::set_has_maxval() {
build/mace/proto/mace.pb.h:1926:inline void ConstTensor::clear_has_maxval() {
build/mace/proto/mace.pb.h:1929:inline void ConstTensor::clear_maxval() {
build/mace/proto/mace.pb.h:1933:inline float ConstTensor::maxval() const {
build/mace/proto/mace.pb.h:1934:  // @@protoc_insertion_point(field_get:mace.ConstTensor.maxval)
build/mace/proto/mace.pb.h:1937:inline void ConstTensor::set_maxval(float value) {
build/mace/proto/mace.pb.h:1940:  // @@protoc_insertion_point(field_set:mace.ConstTensor.maxval)
build/mace/proto/mace.pb.h:1944:inline bool ConstTensor::has_quantized() const {
build/mace/proto/mace.pb.h:1947:inline void ConstTensor::set_has_quantized() {
build/mace/proto/mace.pb.h:1950:inline void ConstTensor::clear_has_quantized() {
build/mace/proto/mace.pb.h:1953:inline void ConstTensor::clear_quantized() {
build/mace/proto/mace.pb.h:1957:inline bool ConstTensor::quantized() const {
build/mace/proto/mace.pb.h:1958:  // @@protoc_insertion_point(field_get:mace.ConstTensor.quantized)
build/mace/proto/mace.pb.h:1961:inline void ConstTensor::set_quantized(bool value) {
build/mace/proto/mace.pb.h:1964:  // @@protoc_insertion_point(field_set:mace.ConstTensor.quantized)
build/mace/proto/mace.pb.h:1968:inline bool ConstTensor::has_node_id() const {
build/mace/proto/mace.pb.h:1971:inline void ConstTensor::set_has_node_id() {
build/mace/proto/mace.pb.h:1974:inline void ConstTensor::clear_has_node_id() {
build/mace/proto/mace.pb.h:1977:inline void ConstTensor::clear_node_id() {
build/mace/proto/mace.pb.h:1981:inline ::google::protobuf::uint32 ConstTensor::node_id() const {
build/mace/proto/mace.pb.h:1982:  // @@protoc_insertion_point(field_get:mace.ConstTensor.node_id)
build/mace/proto/mace.pb.h:1985:inline void ConstTensor::set_node_id(::google::protobuf::uint32 value) {
build/mace/proto/mace.pb.h:1988:  // @@protoc_insertion_point(field_set:mace.ConstTensor.node_id)
build/mace/proto/mace.pb.h:3312:// repeated .mace.ConstTensor tensors = 3;
build/mace/proto/mace.pb.h:3319:inline ::mace::ConstTensor* NetDef::mutable_tensors(int index) {
build/mace/proto/mace.pb.h:3323:inline ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >*
build/mace/proto/mace.pb.h:3328:inline const ::mace::ConstTensor& NetDef::tensors(int index) const {
build/mace/proto/mace.pb.h:3332:inline ::mace::ConstTensor* NetDef::add_tensors() {
build/mace/proto/mace.pb.h:3336:inline const ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >&
build/mace/proto/mace.pb.cc:21:extern PROTOBUF_INTERNAL_EXPORT_protobuf_mace_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ConstTensor;
build/mace/proto/mace.pb.cc:29:class ConstTensorDefaultTypeInternal {
build/mace/proto/mace.pb.cc:31:  ::google::protobuf::internal::ExplicitlyConstructed<ConstTensor>
build/mace/proto/mace.pb.cc:33:} _ConstTensor_default_instance_;
build/mace/proto/mace.pb.cc:71:static void InitDefaultsConstTensor() {
build/mace/proto/mace.pb.cc:75:    void* ptr = &::mace::_ConstTensor_default_instance_;
build/mace/proto/mace.pb.cc:76:    new (ptr) ::mace::ConstTensor();
build/mace/proto/mace.pb.cc:79:  ::mace::ConstTensor::InitAsDefaultInstance();
build/mace/proto/mace.pb.cc:82:::google::protobuf::internal::SCCInfo<0> scc_info_ConstTensor =
build/mace/proto/mace.pb.cc:83:    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsConstTensor}, {}};
build/mace/proto/mace.pb.cc:188:      &protobuf_mace_2eproto::scc_info_ConstTensor.base,
build/mace/proto/mace.pb.cc:192:  ::google::protobuf::internal::InitSCC(&scc_info_ConstTensor.base);
build/mace/proto/mace.pb.cc:232:void ConstTensor::InitAsDefaultInstance() {
build/mace/proto/mace.pb.cc:235:const int ConstTensor::kDimsFieldNumber;
build/mace/proto/mace.pb.cc:236:const int ConstTensor::kDataTypeFieldNumber;
build/mace/proto/mace.pb.cc:237:const int ConstTensor::kFloatDataFieldNumber;
build/mace/proto/mace.pb.cc:238:const int ConstTensor::kInt32DataFieldNumber;
build/mace/proto/mace.pb.cc:239:const int ConstTensor::kNameFieldNumber;
build/mace/proto/mace.pb.cc:240:const int ConstTensor::kOffsetFieldNumber;
build/mace/proto/mace.pb.cc:241:const int ConstTensor::kDataSizeFieldNumber;
build/mace/proto/mace.pb.cc:242:const int ConstTensor::kScaleFieldNumber;
build/mace/proto/mace.pb.cc:243:const int ConstTensor::kZeroPointFieldNumber;
build/mace/proto/mace.pb.cc:244:const int ConstTensor::kMinvalFieldNumber;
build/mace/proto/mace.pb.cc:245:const int ConstTensor::kMaxvalFieldNumber;
build/mace/proto/mace.pb.cc:246:const int ConstTensor::kQuantizedFieldNumber;
build/mace/proto/mace.pb.cc:247:const int ConstTensor::kNodeIdFieldNumber;
build/mace/proto/mace.pb.cc:250:ConstTensor::ConstTensor()
build/mace/proto/mace.pb.cc:253:      &protobuf_mace_2eproto::scc_info_ConstTensor.base);
build/mace/proto/mace.pb.cc:255:  // @@protoc_insertion_point(constructor:mace.ConstTensor)
build/mace/proto/mace.pb.cc:257:ConstTensor::ConstTensor(const ConstTensor& from)
build/mace/proto/mace.pb.cc:272:  // @@protoc_insertion_point(copy_constructor:mace.ConstTensor)
build/mace/proto/mace.pb.cc:275:void ConstTensor::SharedCtor() {
build/mace/proto/mace.pb.cc:283:ConstTensor::~ConstTensor() {
build/mace/proto/mace.pb.cc:284:  // @@protoc_insertion_point(destructor:mace.ConstTensor)
build/mace/proto/mace.pb.cc:288:void ConstTensor::SharedDtor() {
build/mace/proto/mace.pb.cc:292:void ConstTensor::SetCachedSize(int size) const {
build/mace/proto/mace.pb.cc:295:const ConstTensor& ConstTensor::default_instance() {
build/mace/proto/mace.pb.cc:296:  ::google::protobuf::internal::InitSCC(&protobuf_mace_2eproto::scc_info_ConstTensor.base);
build/mace/proto/mace.pb.cc:301:void ConstTensor::Clear() {
build/mace/proto/mace.pb.cc:302:// @@protoc_insertion_point(message_clear_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:327:bool ConstTensor::MergePartialFromCodedStream(
build/mace/proto/mace.pb.cc:337:  // @@protoc_insertion_point(parse_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:557:  // @@protoc_insertion_point(parse_success:mace.ConstTensor)
build/mace/proto/mace.pb.cc:560:  // @@protoc_insertion_point(parse_failure:mace.ConstTensor)
build/mace/proto/mace.pb.cc:565:void ConstTensor::SerializeWithCachedSizes(
build/mace/proto/mace.pb.cc:567:  // @@protoc_insertion_point(serialize_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:652:  // @@protoc_insertion_point(serialize_end:mace.ConstTensor)
build/mace/proto/mace.pb.cc:655:size_t ConstTensor::ByteSizeLong() const {
build/mace/proto/mace.pb.cc:656:// @@protoc_insertion_point(message_byte_size_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:772:void ConstTensor::CheckTypeAndMergeFrom(
build/mace/proto/mace.pb.cc:774:  MergeFrom(*::google::protobuf::down_cast<const ConstTensor*>(&from));
build/mace/proto/mace.pb.cc:777:void ConstTensor::MergeFrom(const ConstTensor& from) {
build/mace/proto/mace.pb.cc:778:// @@protoc_insertion_point(class_specific_merge_from_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:827:void ConstTensor::CopyFrom(const ConstTensor& from) {
build/mace/proto/mace.pb.cc:828:// @@protoc_insertion_point(class_specific_copy_from_start:mace.ConstTensor)
build/mace/proto/mace.pb.cc:834:bool ConstTensor::IsInitialized() const {
build/mace/proto/mace.pb.cc:838:void ConstTensor::Swap(ConstTensor* other) {
build/mace/proto/mace.pb.cc:842:void ConstTensor::InternalSwap(ConstTensor* other) {
build/mace/proto/mace.pb.cc:862:::std::string ConstTensor::GetTypeName() const {
build/mace/proto/mace.pb.cc:863:  return "mace.ConstTensor";
build/mace/proto/mace.pb.cc:3132:const int NetDef::kTensorsFieldNumber;
build/mace/proto/mace.pb.cc:3236:      // repeated .mace.ConstTensor tensors = 3;
build/mace/proto/mace.pb.cc:3337:  // repeated .mace.ConstTensor tensors = 3;
build/mace/proto/mace.pb.cc:3404:  // repeated .mace.ConstTensor tensors = 3;
build/mace/proto/mace.pb.cc:3506:template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::mace::ConstTensor* Arena::CreateMaybeMessage< ::mace::ConstTensor >(Arena* arena) {
build/mace/proto/mace.pb.cc:3507:  return Arena::CreateInternal< ::mace::ConstTensor >(arena);
匹配到二进制文件 build/mace/core/CMakeFiles/core.dir/memory_optimizer.cc.o
匹配到二进制文件 build/mace/core/CMakeFiles/core.dir/net.cc.o
匹配到二进制文件 build/mace/core/CMakeFiles/core.dir/workspace.cc.o
匹配到二进制文件 build/mace/core/CMakeFiles/core.dir/net_def_adapter.cc.o
匹配到二进制文件 build/mace/core/CMakeFiles/core.dir/operator.cc.o
匹配到二进制文件 build/mace/core/libcore.a
匹配到二进制文件 build/mace/tools/CMakeFiles/mace_run.dir/mace_run.cc.o
匹配到二进制文件 build/mace/tools/mace_run
匹配到二进制文件 build/mace/libmace/libmace.so
匹配到二进制文件 build/mace/libmace/libmace_static.a
匹配到二进制文件 build/mace/libmace/CMakeFiles/mace_static.dir/mace.cc.o
匹配到二进制文件 build/mace/libmace/CMakeFiles/mace_static.dir/capability.cc.o
匹配到二进制文件 build/mace/libmace/CMakeFiles/mace.dir/mace.cc.o
匹配到二进制文件 build/mace/libmace/CMakeFiles/mace.dir/capability.cc.o
匹配到二进制文件 build/mace/ops/libops.a
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/reshape.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/scalar_math.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/target_rms_norm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/squeeze.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/gather.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/prior_box.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/bias_add.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/batch_to_space.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/sum_group.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/depthwise_deconv2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/batch_norm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/slice.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/reverse.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/channel_shuffle.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/cast.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/kaldi_batch_norm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/stack.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/transpose.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/space_to_depth.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/depth_to_space.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/dynamic_lstm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/conv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/fully_connected.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/delay.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/eltwise.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/extract_pooling.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/resize_bilinear.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/sqrdiff_mean.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/split.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/splice.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/resize_bicubic.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/one_hot.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/depthwise_conv2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/expand_dims.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/pad_context.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/argmax.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/reduce.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/pad.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/shape.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/fill.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/resize_nearest_neighbor.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/crop.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/softmax.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/pooling.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/cumsum.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/pnorm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/infer_conv2d_shape.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/unstack.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/space_to_batch.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/strided_slice.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/deconv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/identity.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/activation.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/local_response_norm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/matmul.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/bias_add.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/gemm.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/conv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/gemv.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/depthwise_deconv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/depthwise_conv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/deconv_2d.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/ref/activation.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/unsqueeze.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/addn.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/lstm_nonlinear.cc.o
匹配到二进制文件 build/mace/ops/CMakeFiles/ops.dir/concat.cc.o
include/mace/public/mace.h:325:class MACE_API MaceTensor {
include/mace/public/mace.h:339:  MaceTensor(const std::vector<int64_t> &shape,
include/mace/public/mace.h:342:  MaceTensor();
include/mace/public/mace.h:343:  MaceTensor(const MaceTensor &other);
include/mace/public/mace.h:344:  MaceTensor(const MaceTensor &&other);
include/mace/public/mace.h:345:  MaceTensor &operator=(const MaceTensor &other);
include/mace/public/mace.h:346:  MaceTensor &operator=(const MaceTensor &&other);
include/mace/public/mace.h:347:  ~MaceTensor();
include/mace/public/mace.h:387:  MaceStatus Run(const std::map<std::string, MaceTensor> &inputs,
include/mace/public/mace.h:388:                 std::map<std::string, MaceTensor> *outputs);
include/mace/public/mace.h:390:  MaceStatus Run(const std::map<std::string, MaceTensor> &inputs,
include/mace/public/mace.h:391:                 std::map<std::string, MaceTensor> *outputs,
